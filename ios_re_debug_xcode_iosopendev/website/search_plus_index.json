{"./":{"url":"./","title":"前言","keywords":"","body":"iOS逆向调试：Xcode+iOSOpenDev 最新版本：v1.0.1 更新时间：20241126 简介 介绍iOS逆向的动态调试期间的，常用的好用的调试方式：Xcode+iOSOpenDev。主要包括先是概览；再介绍为何要实现可调式debuggable；以及对应底层机制；以及如何实现可调试，包括用unc0ver、XinaA15等工具越狱后自带可调试、用codesign加上权限重签名、用jailbreakd_client加上权限等，以及用插件XcodeRootDebug等；然后介绍具体的调试方式，包括Attach挂载模式和Spawn孵化模式；然后给出具体的调试的例子，包括Xcode汇编代码、函数调用堆栈、hook代码加断点等等效果；最后加上附录、包括如何查看进程PID。 源码+浏览+下载 本书的各种源码、在线浏览地址、多种格式文件下载如下： HonKit源码 crifan/ios_re_debug_xcode_iosopendev: iOS逆向调试：Xcode+iOSOpenDev 如何使用此HonKit源码去生成发布为电子书 详见：crifan/honkit_template: demo how to use crifan honkit template and demo 在线浏览 iOS逆向调试：Xcode+iOSOpenDev book.crifan.org iOS逆向调试：Xcode+iOSOpenDev crifan.github.io 离线下载阅读 iOS逆向调试：Xcode+iOSOpenDev PDF iOS逆向调试：Xcode+iOSOpenDev ePub iOS逆向调试：Xcode+iOSOpenDev Mobi 版权和用途说明 此电子书教程的全部内容，如无特别说明，均为本人原创。其中部分内容参考自网络，均已备注了出处。如发现有侵权，请通过邮箱联系我 admin 艾特 crifan.com，我会尽快删除。谢谢合作。 各种技术类教程，仅作为学习和研究使用。请勿用于任何非法用途。如有非法用途，均与本人无关。 鸣谢 感谢我的老婆陈雪的包容理解和悉心照料，才使得我crifan有更多精力去专注技术专研和整理归纳出这些电子书和技术教程，特此鸣谢。 其他 作者的其他电子书 本人crifan还写了其他150+本电子书教程，感兴趣可移步至： crifan/crifan_ebook_readme: Crifan的电子书的使用说明 关于作者 关于作者更多介绍，详见： 关于CrifanLi李茂 – 在路上 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-11-26 15:16:06 "},"overview_xcode_iosopendev/":{"url":"overview_xcode_iosopendev/","title":"Xcode+iOSOpenDev概览","keywords":"","body":"Xcode+iOSOpenDev概览 关于iOS逆向中的动态调试，之前已有完整的成套的教程： iOS逆向开发：动态调试 而此处是单独介绍其中的，最常用的，最好用的部分： 用Xcode+iOSOpenDev实现GUI图形方式去调试 对比 和command line=命令行方式的debugserver+lldb调试方式相比 GUI=图形界面方式的调试：Xcode+iOSOpenDev 图形界面中，调试更加直观 Xcode中加函数断点 Xcode中给hook代码加断点 Xcode中查看和调试汇编代码 前提 （app/二进制文件等）调试目标必须是：可调试=Debuggable的 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-01-27 17:39:54 "},"app_debuggable/":{"url":"app_debuggable/","title":"app可调试","keywords":"","body":"app可调试debuggable 什么是：app可调试debuggable = 可调试debuggable = （GUI的Xcode 和 命令行的debugserver）可以调试 = 有权限调试 任意的目标（app、二进制 的 进程） 包括 Xcode可以调试任意app、二进制、进程 debugserver(+lldb)可以调试任意app、二进制、进程 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-01-27 17:45:54 "},"app_debuggable/why_need.html":{"url":"app_debuggable/why_need.html","title":"为何要","keywords":"","body":"为何要可调试debuggable iOS逆向期间，尝试用Xcode去调试iPhone中的目标（app或二进制）时，如果目标不可调试，则会报错： Not allowed to attach to process 所以被调试目标（app或二进制），必须：可调试=debuggable，才可以顺利调试。 报错举例 Could not attach to pid : “5439” attach failed (Not allowed to attach to process. Look in the console messages (Console.app), near the debugserver entries, when the attach failed. The subsystem that denied the attach permission will likely have logged an informative message about why it was denied.) Details Details Could not attach to pid : “5439” Domain: IDEDebugSessionErrorDomain Code: 3 Failure Reason: attach failed (Not allowed to attach to process. Look in the console messages (Console.app), near the debugserver entries, when the attach failed. The subsystem that denied the attach permission will likely have logged an informative message about why it was denied.) User Info: { DVTErrorCreationDateKey = \"2023-03-02 09:53:45 +0000\"; DVTRadarComponentKey = 855031; IDERunOperationFailingWorker = DBGLLDBLauncher; RawUnderlyingErrorMessage = \"attach failed (Not allowed to attach to process. Look in the console messages (Console.app), near the debugserver entries, when the attach failed. The subsystem that denied the attach permission will likely have logged an informative message about why it was denied.)\"; } -- Analytics Event: com.apple.dt.IDERunOperationWorkerFinished : { \"device_model\" = \"iPhone10,1\"; \"device_osBuild\" = \"15.0 (19A346)\"; \"device_platform\" = \"com.apple.platform.iphoneos\"; \"launchSession_schemeCommand\" = Run; \"launchSession_state\" = 1; \"launchSession_targetArch\" = arm64; \"operation_duration_ms\" = 105483; \"operation_errorCode\" = 3; \"operation_errorDomain\" = IDEDebugSessionErrorDomain; \"operation_errorWorker\" = DBGLLDBLauncher; \"operation_name\" = IDEiPhoneRunOperationWorkerGroup; \"param_consoleMode\" = 0; \"param_debugger_attachToExtensions\" = 0; \"param_debugger_attachToXPC\" = 1; \"param_debugger_type\" = 3; \"param_destination_isProxy\" = 0; \"param_destination_platform\" = \"com.apple.platform.iphoneos\"; \"param_diag_MainThreadChecker_stopOnIssue\" = 0; \"param_diag_MallocStackLogging_enableDuringAttach\" = 0; \"param_diag_MallocStackLogging_enableForXPC\" = 0; \"param_diag_allowLocationSimulation\" = 0; \"param_diag_gpu_frameCapture_enable\" = 3; \"param_diag_gpu_shaderValidation_enable\" = 0; \"param_diag_gpu_validation_enable\" = 1; \"param_diag_memoryGraphOnResourceException\" = 0; \"param_diag_queueDebugging_enable\" = 1; \"param_diag_runtimeProfile_generate\" = 0; \"param_diag_sanitizer_asan_enable\" = 0; \"param_diag_sanitizer_tsan_enable\" = 0; \"param_diag_sanitizer_tsan_stopOnIssue\" = 0; \"param_diag_sanitizer_ubsan_stopOnIssue\" = 0; \"param_diag_showNonLocalizedStrings\" = 0; \"param_diag_viewDebugging_enabled\" = 1; \"param_diag_viewDebugging_insertDylibOnLaunch\" = 1; \"param_install_style\" = 2; \"param_launcher_UID\" = 2; \"param_launcher_allowDeviceSensorReplayData\" = 0; \"param_launcher_kind\" = 0; \"param_launcher_style\" = 99; \"param_launcher_substyle\" = 256; \"param_runnable_appExtensionHostRunMode\" = 0; \"param_runnable_type\" = 0; \"param_testing_launchedForTesting\" = 0; \"param_testing_suppressSimulatorApp\" = 0; \"param_testing_usingCLI\" = 0; \"sdk_canonicalName\" = \"iphoneos15.2\"; \"sdk_osVersion\" = \"15.2\"; \"sdk_variant\" = iphoneos; } -- System Information macOS Version 11.7.3 (Build 20G1116) Xcode 13.2.1 (19586) (Build 13C100) Timestamp: 2023-03-02T17:53:45+08:00 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-01-27 12:02:15 "},"app_debuggable/internal_logic.html":{"url":"app_debuggable/internal_logic.html","title":"底层机制","keywords":"","body":"可调试debuggable的底层机制和原理 task_for_pid函数 根据前面的报错细节中的Look in the console messages (Console.app)所示，去查看Console.app=控制台中日志，往往可以看到相关错误细节： 默认 21:37:03.838148+0800 debugserver error: [LaunchAttach] MachTask::TaskPortForProcessID task_for_pid(15266) failed: ::task_for_pid ( target_tport = 0x0203, pid = 15266, &task ) => err = 0x00000005 ((os/kern) failure) 默认 21:37:03.838202+0800 debugserver 1 +0.000000 sec [3bb1/0103]: error: ::task_for_pid ( target_tport = 0x0203, pid = 15266, &task ) => err = 0x00000005 ((os/kern) failure) err = ::task_for_pid ( target_tport = 0x0203, pid = 15266, &task ) => err = 0x00000005 ((os/kern) failure) (0x00000005) 核心错误 debugserver error: [LaunchAttach] MachTask::TaskPortForProcessID task_for_pid(15266) failed: ::task_for_pid ( target_tport = 0x0203, pid = 15266, &task ) => err = 0x00000005 ((os/kern) failure) 即： 核心原因 task_for_pid()返回失败 -》无法获取task 解决办法 能想办法给被调试的app加上task_for_pid-allow（和get-task-allow）的权限entitlement即可 但是无法直接修改debugserver去加权限 因为这个/Developer/usr/bin/debugserver 最早来源是：DeveloperDiskImage.dmg 是挂载到Ramdisk中 -> 是只读的 所以无法简单的直接修改 所以只能用其他办法 详见后续内容 如何实现 csflags中的CS_GET_TASK_ALLOW 而决定进程函数task_for_pid()返回是否成功，再底层决定因素是：进程的csflags中的CS_GET_TASK_ALLOW 举例 WhatsApp的进程的flag 含义解释 0x04000000 = CS_PLATFORM_BINARY 0x00004000 = CS_ENTITLEMENTS_VALIDATED 0x00000004 = CS_GET_TASK_ALLOW 具体定义详见 进程csflags定义 说明 不过，目前也发现过：iOS进程中csflags中有CS_GET_TASK_ALLOW也还是无法被调试 所以底层相关细节，暂时不是完全清楚，待深究。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-01-27 17:31:55 "},"app_debuggable/how_implement/":{"url":"app_debuggable/how_implement/","title":"如何实现","keywords":"","body":"如何实现可调试debuggable 如何实现app可调试Debuggable 概述 全局的 越狱工具越狱后，系统全局自动支持app可调式 部分机型用unc0ver越狱后，自带：app可调式 A12+的机型，用XinaA15越狱后，自带：app可调式 借助于插件XcodeRootDebug实现 针对特定app的 （用codesign）给app二进制文件重新签名，加上可调试权限 下面详细解释： crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-01-27 16:45:13 "},"app_debuggable/how_implement/unc0ver_jail.html":{"url":"app_debuggable/how_implement/unc0ver_jail.html","title":"unc0ver越狱","keywords":"","body":"用unc0ver越狱自动实现可调试 部分机型用unc0ver越狱后的自带app可调式 说明 实测部分机型 iOS 13.3.1的iPhone7 iOS 14.3的iPhone8 在用unc0ver 最新版v8.0.2 越狱后，确认是自动拥有全局的app可调试 优点 无需额外操作，即可支持可调试 缺点 之前unc0ver越狱的iPhone，好像不是自动支持可调试？ crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-01-27 15:18:05 "},"app_debuggable/how_implement/xinaa15_jail.html":{"url":"app_debuggable/how_implement/xinaa15_jail.html","title":"XinaA15越狱","keywords":"","body":"用XinaA15越狱自动实现可调试 XinaA15越狱后：自带app可调试 说明 关键点 越狱期间 Signature Debugserver=重签名Debugserver 越狱后 进程管理器中的debugserver的entitlement权限中，就有了：task_for_pid-allow -> 给debugserver加上可调试权限 -》 可以调试任意app/进程了 缺点 只适用于：A12+芯片的iPhone机型 注：XinaA15只支持A12+的机型 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-01-27 17:33:03 "},"app_debuggable/how_implement/resign_add_ent.html":{"url":"app_debuggable/how_implement/resign_add_ent.html","title":"重签名加权限","keywords":"","body":"重签名添加权限实现可调试 重签名添加权限实现可调试 概述 方式1：用codesign重新签名，加上可调试的entitlement权限 方式2：用jailbreakd_client加可调试的权限 详解： 用codesign重签名加可调试权限 用codesign重新签名，加上可调试的entitlement权限 优点 此方式相对比较通用，适用于各种机型和系统 缺点 需要熟悉codesign签名和entitlement权限等细节 举例 给akd重签名，使其可调试 从iPhone中导出akdscp root@192.168.1.22:/System/Library/PrivateFrameworks/AuthKit.framework/akd akd_origin 导出adk的entitlement权限ldid -e akd_origin > akd_entitlements.xml 修改entitlement，增加可调式相关权限 修改akd_entitlements.xml 加上权限 get-task-allow=true task_for_pid-allow=true run-unsigned-code=true -> get-task-allow task_for_pid-allow run-unsigned-code 去掉权限 seatbelt-profiles seatbelt-profiles akd com.apple.security.network.client com.apple.security.network.client 保存为akd_entitlements_debuggable.xml 用新的entitlement去重新签名cp akd_origin akd_debuggable codesign -f -s - --entitlements akd_entitlements_debuggable.xml akd_debuggable 再把重签名后的akd放回越狱iPhone中scp akd_debuggable root@192.168.1.22:/System/Library/PrivateFrameworks/AuthKit.framework/akd 详见 手动重签名 · iOS逆向开发：签名和权限 (crifan.org) 用jailbreakd_client加可调试的权限 用jailbreakd_client加可调试的权限 说明 jailbreakd_client是部分越狱系统才有的工具，好像是 用的coolstar系越狱（Electra或者Chimera）后，有对应文件xia0:/chimera root# ls -la total 1100 drwxr-xr-x 8 root wheel 256 Feb 26 13:19 ./ drwxr-xr-x 28 root wheel 896 Sep 16 17:44 ../ -rwxr-xr-x 1 root wheel 168736 Sep 17 10:21 inject_criticald* -rwxr-xr-x 1 root wheel 207920 Sep 17 10:21 jailbreakd* -rwxr-xr-x 1 root wheel 133840 Sep 17 10:21 jailbreakd_client* -rwxr-xr-x 1 root wheel 167296 Sep 17 10:21 libjailbreak.dylib* ... 基本用法/electra/jailbreakd_client 1 暂未成功使用，之前的折腾详见 【未解决】iOS逆向：寻找可用的jailbreakd_client用于给进程加可调试权限 【未解决】iOS逆向：用jailbreakd_client给debugserver去加上entitle和platformize crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-01-27 17:39:07 "},"app_debuggable/how_implement/via_plugin.html":{"url":"app_debuggable/how_implement/via_plugin.html","title":"用插件实现","keywords":"","body":"借助插件实现可调式 借助插件实现可调式 XcodeRootDebug Github https://github.com/lemon4ex/XcodeRootDebug Repo源 https://repo.byteage.com 说明 之前在iOS15中用过：不起效果 不过对于，应该是可以工作的 前提 把重签名加了可调试权限的debugserver放到iPhone中的对应位置 位置举例 /usr/bin/debugserver 关于如何重签名debugserver，详见 确保debugserver权限 · iOS逆向调试：debugserver+lldb (crifan.org) 安装后 设置中能看到XcodeRootDebug 进入后可以配置XcodeRootDebug的参数 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-01-27 17:44:02 "},"debug_type/":{"url":"debug_type/","title":"调试方式","keywords":"","body":"调试方式 调试方式 概述 Attach模式 进程已运行：Xcode中Attach时输入Name或PID，即可调试 Spawn模式 进程未运行：Xcode中Attach时输入Name，再去启动（app或二进制文件对应的）进程，即可调试 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-01-27 17:47:59 "},"debug_type/attach_mode.html":{"url":"debug_type/attach_mode.html","title":"Attach挂载","keywords":"","body":"以Attach挂载模式启动调试 Attach模式=挂载模式 前提：已经启动=app正在运行 方式1：手动输入PID或Name 步骤：Xcode->Debug->Attach to Process by PID or name->输入PID或name 图 方式1：Name 举例：WhatsApp 方式2：PID 举例：Preferences的PID=7993 说明 关于如何查看进程PID，详见：查看进程PID 方式2：从进程列表中点击选择 步骤：Xcode->Debug->Attach to Process->等待（一会，即可）显示出进程的列表-》点击选择对应进程 举例 akd crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-01-27 17:48:33 "},"debug_type/spawn_mode.html":{"url":"debug_type/spawn_mode.html","title":"Spawn孵化","keywords":"","body":"以Spawn孵化模式启动调试 Spawn模式=孵化模式 用途： 用于app启动阶段时的相关逻辑 举例 调试反越狱检测 调试app首次启动初始化相关过程 比如app中只初始化一次的相关代码逻辑 举例 WhatsApp中的初始化创建WAUUID、WAFBUUID等相关逻辑 前提：Xcode中可以通过name找到被调试的app或二进制 步骤： Xcode中 操作：Xcode->Debug->Attach to Process by PID or name->输入name 说明：Name是app或二进制文件的name 举例 WhatsApp这个app的主入口二进制：WhatsApp Preferences的二进制名称：Preferences akd的二进制名称：akd Xcode中会显示：正在等待挂载 对于PID：Attaching to PID xxx 举例 PID=16848 说明 关于如何查看进程PID，详见：查看进程PID 对于Name：Waiting to attach to xxx 举例 akd iPhone中： 确保进程运行 （手动点击）启动app 点击app桌面图标 举例 WhatsApp 或：以某种方式，触发二进制服务进程加载 举例 akd 点击iOS系统的设置=Preferences=包名com.apple.Preferences 内部会触发XPC的服务，去请求到akd，从而触发启动akd进程 比如，Apple ID账号登录 说明： akd完整路径：/System/Library/PrivateFrameworks/AuthKit.framework/akd Xcode中： 说明：需要稍等一段时间，才能挂载上 一般都很快：大概几秒 偶尔：很多秒（之后，才能挂载上，注意此时要多等一会） 即可挂载成功 具体现象 描述 右下角：调试窗口：显示出进程PID值/Name 右上角：状态信息显示：Running PID值/Name on iPhone 左上角：Debug Navigator中显示出PID值/Name和当前硬件信息：CPU、Memory等等 图 对于PID 对于Name 然后即可正常（Spawn方式去）调试 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-01-27 17:48:47 "},"effect_example/":{"url":"effect_example/","title":"效果举例","keywords":"","body":"效果举例 此处举例说明iOS逆向的Xcode+iOSOpenDev的图形界面调试的效果： 方便查看和调试 Xcode Xcode中查看汇编代码 查看函数调用堆栈 除了lldb命令行中的bt 还可以GUI图形界面中查看： lldb中 查看寄存器变量 用po查看变量的值 对于hook代码 用iOSOpenDev写插件代码，加断点，实时调试，触发断点后的）效果 能看到各种参数值和当前变量的值，甚至包括全局变量的值 对于hook代码的%orig，（多次）Ctrl+F7后，可以进入对应的Xcode汇编代码 辅助 Console.app=控制台 另外，hook代码中加上的os_log日志打印，还可以单独在Console.app中看到： -> 如此即可实现：用Xcode去方便的、深入的，调试每一行代码，以及搞懂hook代码和汇编代码的底层逻辑和细节。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-01-27 16:57:07 "},"appendix/":{"url":"appendix/","title":"附录","keywords":"","body":"附录 下面列出相关参考资料。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-01-27 11:21:50 "},"appendix/check_pid.html":{"url":"appendix/check_pid.html","title":"查看进程PID","keywords":"","body":"如何查看进程PID 如何查看进程PID 用ssh中ps查看PID 举例 akdiPhone11-151:~ root# ps -A | grep akd 125 ?? 0:36.25 /System/Library/PrivateFrameworks/AuthKit.framework/akd 352 ?? 0:01.53 /var/bin/jailbreakd_safe 353 ?? 0:07.82 /var/bin/jailbreakd 14933 ttys001 0:00.01 grep akd -> akd的PID是125 用frida-ps查看PIDcrifan@licrifandeMacBook-Pro  ~/dev/dev_src/ios_reverse/dumpdecrypted/stefanesser/dumpdecrypted   master ●  frida-ps -U | grep Store 2042 App Store 3744 Apple Store 1559 TrollStore -> Apple Store的PID是3744 用越狱后的工具查看 XinaA15->进程 CocoaTop64 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-11-26 15:15:52 "},"appendix/process_csflags.html":{"url":"appendix/process_csflags.html","title":"进程csflags定义","keywords":"","body":"进程的csflags的定义 来源 cs_blobs.h (apple.com) codesign.h (apple.com) 常用定义 #define CS_GET_TASK_ALLOW 0x00000004 /* has get-task-allow entitlement */ #define CS_ENTITLEMENTS_VALIDATED 0x00004000 /* code signature permits restricted entitlements */ #define CS_PLATFORM_BINARY 0x04000000 /* this is a platform binary */ #define CS_DEBUGGED 0x10000000 /* process is currently or has previously been debugged and allowed to run with invalid pages */ 全部定义 #ifndef _KERN_CODESIGN_H_ #define _KERN_CODESIGN_H_ /* code signing attributes of a process */ #define CS_VALID 0x00000001 /* dynamically valid */ #define CS_ADHOC 0x00000002 /* ad hoc signed */ #define CS_GET_TASK_ALLOW 0x00000004 /* has get-task-allow entitlement */ #define CS_INSTALLER 0x00000008 /* has installer entitlement */ #define CS_FORCED_LV 0x00000010 /* Library Validation required by Hardened System Policy */ #define CS_INVALID_ALLOWED 0x00000020 /* (macOS Only) Page invalidation allowed by task port policy */ #define CS_HARD 0x00000100 /* don't load invalid pages */ #define CS_KILL 0x00000200 /* kill process if it becomes invalid */ #define CS_CHECK_EXPIRATION 0x00000400 /* force expiration checking */ #define CS_RESTRICT 0x00000800 /* tell dyld to treat restricted */ #define CS_ENFORCEMENT 0x00001000 /* require enforcement */ #define CS_REQUIRE_LV 0x00002000 /* require library validation */ #define CS_ENTITLEMENTS_VALIDATED 0x00004000 /* code signature permits restricted entitlements */ #define CS_NVRAM_UNRESTRICTED 0x00008000 /* has com.apple.rootless.restricted-nvram-variables.heritable entitlement */ #define CS_RUNTIME 0x00010000 /* Apply hardened runtime policies */ #define CS_ALLOWED_MACHO (CS_ADHOC | CS_HARD | CS_KILL | CS_CHECK_EXPIRATION | \\ CS_RESTRICT | CS_ENFORCEMENT | CS_REQUIRE_LV | CS_RUNTIME) #define CS_EXEC_SET_HARD 0x00100000 /* set CS_HARD on any exec'ed process */ #define CS_EXEC_SET_KILL 0x00200000 /* set CS_KILL on any exec'ed process */ #define CS_EXEC_SET_ENFORCEMENT 0x00400000 /* set CS_ENFORCEMENT on any exec'ed process */ #define CS_EXEC_INHERIT_SIP 0x00800000 /* set CS_INSTALLER on any exec'ed process */ #define CS_KILLED 0x01000000 /* was killed by kernel for invalidity */ #define CS_DYLD_PLATFORM 0x02000000 /* dyld used to load this is a platform binary */ #define CS_PLATFORM_BINARY 0x04000000 /* this is a platform binary */ #define CS_PLATFORM_PATH 0x08000000 /* platform binary by the fact of path (osx only) */ #define CS_DEBUGGED 0x10000000 /* process is currently or has previously been debugged and allowed to run with invalid pages */ #define CS_SIGNED 0x20000000 /* process has a signature (may have gone invalid) */ #define CS_DEV_CODE 0x40000000 /* code is dev signed, cannot be loaded into prod signed code (will go away with rdar://problem/28322552) */ #define CS_DATAVAULT_CONTROLLER 0x80000000 /* has Data Vault controller entitlement */ #define CS_ENTITLEMENT_FLAGS (CS_GET_TASK_ALLOW | CS_INSTALLER | CS_DATAVAULT_CONTROLLER | CS_NVRAM_UNRESTRICTED) /* executable segment flags */ #define CS_EXECSEG_MAIN_BINARY 0x1 /* executable segment denotes main binary */ #define CS_EXECSEG_ALLOW_UNSIGNED 0x10 /* allow unsigned pages (for debugging) */ #define CS_EXECSEG_DEBUGGER 0x20 /* main binary is debugger */ #define CS_EXECSEG_JIT 0x40 /* JIT enabled */ #define CS_EXECSEG_SKIP_LV 0x80 /* OBSOLETE: skip library validation */ #define CS_EXECSEG_CAN_LOAD_CDHASH 0x100 /* can bless cdhash for execution */ #define CS_EXECSEG_CAN_EXEC_CDHASH 0x200 /* can execute blessed cdhash */ ... crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-01-27 17:30:03 "},"appendix/reference.html":{"url":"appendix/reference.html","title":"参考资料","keywords":"","body":"参考资料 手动重签名 · iOS逆向开发：签名和权限 (crifan.org) unc0ver XinaA15 iOS逆向开发：动态调试 debugserver+lldb 确保debugserver权限 · iOS逆向调试：debugserver+lldb (crifan.org) 【记录】Xcode用debugserver调试报错Not allowed to attach to process的核心原因：task_for_pid()调用失败 【未解决】Xcode调试Preferences报错：Could not attach to pid attach failed Not allowed to attach to process 【已解决】用新版1.1.8的XinaA15重新越狱 【记录】看看新版1.1.8的XinaA15各个功能和界面 【未解决】iOS逆向：如何查看进程详细信息 【已解决】iOS逆向进程可调试：给akd加上可调试的entitlement权限 【未解决】iOS逆向：用插件XcodeRootDebug实现debugserver允许调试任意进程 【整理】Xcode去Attach挂载调试app或二进制：通过PID或进程名 【未解决】iOS逆向：XCode去Attach调试启动时间有快有慢 【未解决】iOS逆向akd：动态调试 【已解决】iOS逆向akd：手动启动akd服务进程 【已解决】iOS逆向akd：用Xcode直接去调试akd的进程 【已解决】iOS逆向：查看越狱iPhone中Apple Store进程 【记录】用CocoaTop查看WhatsApp进程的flag属性 【未解决】iOS逆向：寻找可用的jailbreakd_client用于给进程加可调试权限 【未解决】iOS逆向：用jailbreakd_client给debugserver去加上entitle和platformize 【未解决】iOS逆向：iPhone中如何修改DeveloperDiskImage.dmg中的/Developer/usr/bin/debugserver 【记录】Xcode用debugserver调试报错Not allowed to attach to process的核心原因：task_for_pid()调用失败 【未解决】越狱iPhone中允许Xcode调试任意进程= 【未解决】iOS逆向：借助Frida实现任意目标进程可调试 【未解决】iOS逆向：允许进程被调试的csflags中的CS_GET_TASK_ALLOW 【已解决】iOS中进程的flag定义 【未解决】iOS进程中csflags中有CS_GET_TASK_ALLOW也还是无法被调试 【未解决】iOS逆向：iPhone中如何修改Ramdisk中的/Developer/usr/bin/debugserver 【未解决】Xcode调试Preferences报错：Could not attach to pid attach failed Not allowed to attach to process 【已解决】Xcode调试报错：Failed to start remote service com.apple.debugserver on device 【已解决】Xcode调试抖音报错：Failed to start remote service com.apple.debugserver on device Please check your connection to your device 【已解决】Xcode调试iPhoneX中抖音报错：Failed to start remote service com.apple.debugserver on device 【已解决】XCode调试iPhone报错：Failed to start remote service com.apple.debugserver on device crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-01-27 17:43:55 "}}