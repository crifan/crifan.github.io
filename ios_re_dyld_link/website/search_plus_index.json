{"./":{"url":"./","title":"前言","keywords":"","body":"iOS逆向开发：dyld动态链接 最新版本：v1.0.0 更新时间：20241015 简介 整理关于iOS逆向期间涉及到的dyld动态链接的各种内容。先是dyld概述；然后是分别详细介绍dyld和libdyld.dylib的具体内容；dyld包括，二进制工具的man page；如何查看dyld的版本；哪里可以找到dyld的源码；dyld的app的加载过程；以及相关函数，包括dyld的API，具体有dlfcn.h的dladdr、dlsym、dlinfo、dlopen、dlclose、dlopen_preflight；dyld.h的_dyld_image_count、_dyld_get_image_header、_dyld_get_image_vmaddr_slide、_dyld_get_image_name、_dyld_register_func_for_add_image、_dyld_register_func_for_remove_image、NSVersionOfRunTimeLibrary、NSVersionOfLinkTimeLibrary、_NSGetExecutablePath；dyld_priv.h的dyld_image_header_containing_address、dyld_program_sdk_at_least、dyld_shared_cache_file_path、_dyld_get_all_image_infos；dyld-interposing.h的DYLD_INTERPOSE，以及一些其他函数start、_dyld_start和相关变量，比如gProcessInfo和一些定义dyld_all_image_infos等；以及相关涉及到的地方；再介绍libdyld.dylib中的内容，包括man page，相关函数dyld_stub_binder等；以及其他dyld相关的内容，包括getsect.h的getsectdata、getsectdatafromFramework、getsectiondata、getsectbyname、getsegbyname、getsegmentdata、getsectdatafromheader、getsectdatafromheader_64、getsectbynamefromheader、getsectbynamefromheader_64、getsectbynamefromheaderwithswap、getsectbynamefromheaderwithswap_64；DYLD环境变量的DYLD_LIBRARY_PATH、DYLD_INSERT_LIBRARIES、DYLD_PRINT_LIBRARIES、DYLD_PRINT_STATISTICS、DYLD_IMAGE_SUFFIX、DYLD_PRINT_APIS、DYLD_PRINT_WARNINGS；相关工具dyldinfo等；Mach-O中Load Command的详细定义和具体command，比如LC_DYLD_CHAINED_FIXUPS，和其他涉及到的地方；以及相关结构体dyld_info_command、linkedit_data_command等定义。 源码+浏览+下载 本书的各种源码、在线浏览地址、多种格式文件下载如下： HonKit源码 crifan/ios_re_dyld_link: iOS逆向开发：dyld动态链接 如何使用此HonKit源码去生成发布为电子书 详见：crifan/honkit_template: demo how to use crifan honkit template and demo 在线浏览 iOS逆向开发：dyld动态链接 book.crifan.org iOS逆向开发：dyld动态链接 crifan.github.io 离线下载阅读 iOS逆向开发：dyld动态链接 PDF iOS逆向开发：dyld动态链接 ePub iOS逆向开发：dyld动态链接 Mobi 版权和用途说明 此电子书教程的全部内容，如无特别说明，均为本人原创。其中部分内容参考自网络，均已备注了出处。如发现有侵权，请通过邮箱联系我 admin 艾特 crifan.com，我会尽快删除。谢谢合作。 各种技术类教程，仅作为学习和研究使用。请勿用于任何非法用途。如有非法用途，均与本人无关。 鸣谢 感谢我的老婆陈雪的包容理解和悉心照料，才使得我crifan有更多精力去专注技术专研和整理归纳出这些电子书和技术教程，特此鸣谢。 其他 作者的其他电子书 本人crifan还写了其他150+本电子书教程，感兴趣可移步至： crifan/crifan_ebook_readme: Crifan的电子书的使用说明 关于作者 关于作者更多介绍，详见： 关于CrifanLi李茂 – 在路上 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-15 10:59:24 "},"dyld_overview/":{"url":"dyld_overview/","title":"dyld概述","keywords":"","body":"dyld概述 dyld 名词解析 =DYLD = DYnamic LoaDing =the dynamic link editor=苹果的动态链接器 作用 Apple系统（iOS、Mac等）中的应用app和动态库的（主要格式是Mach-O）的加载和解析 主要包括 二进制的: dyld 典型位置：/usr/lib/dyld 动态库的：libdyld.dylib 典型位置：/usr/lib/system/libdyld.dylib crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-15 10:44:39 "},"dyld_overview/dyld_versions.html":{"url":"dyld_overview/dyld_versions.html","title":"dyld库的版本和架构","keywords":"","body":"dyld库的版本和架构 dyld库的版本和架构 历史版本 最新：dyld4 之前：dyld3 更早：dyld2 对比 dyld2 vs dyld3 图 文字 dyld2 和 dyld3 的主要变化体现在源码上就是 dyld-400 和 dyld-600的版本，比如较低版本的模拟器采用的仍然是 dyld-433 的版本，而 iOS12 之后的真机基本上都采用 dyld-655 以后的版本 dyld3 在很早就引入，但是一开始只用于 Apple 相关的 App 或者系统库（库还是 App 有待考究）。而在 iOS13 之后，dyld3 正式替代 dyld2，用于加载所有的 App dyld-433 版本的源码是比较纯粹 dyld2 的逻辑，而 dyld-655 就能看到很多 dyld3 的优化代码了。dyld3 在流程上有所改进，且源码上也有了很多变化，但是 dyld2 仍然是基础，源码的参考价值仍然比较高，因此本文采用 dyld-433.5 的版本研究 dyld2 的基础流程。偶尔也会对比 dyld-655.1.1 和 dyld-733.6的版本 最新：dyld4 源码 https://github.com/apple-oss-distributions/dyld dyld模型 dyld：包括绝大多数运行时的代码逻辑 libdyld.dylib：代码量较少，瘦身设计 源码结构 dyld/doc/dyld4.md at main · apple-oss-distributions/dyld dyld/ - the code that contributes to dyld libdyld/ - the code that contibutes to libdyld.dylib cache-builder/ - code for tools such as dyld_usage, dyld_info, dyld_shared_cache_builder, etc other-tools/ - code for tools such as dyld_usage, dyld_info, dyld_shared_cache_builder, etc common/ - common code shared between dyld and cache-builder include/ - public headers testing/ - everything used to test dyld doc/ - man pages and other documentation configs/ - xcconfig files used by targets build-scripts/ - shell script phase scripts crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-15 10:46:29 "},"dyld_overview/dyld_functions.html":{"url":"dyld_overview/dyld_functions.html","title":"dyld函数概览","keywords":"","body":"dyld函数概览 dyld 是什么：二进制文件=工具 位置 /cores/dyld /usr/lib/dyld 内部结构 section dyld.__TEXT.__text 函数 概述 包括绝大多数dyld相关的函数 举例 iPhone11_151/dyld_rabin2_s_symbols.txt dlfcn.h dladdr dyld3::dladdr dlsym dlinfo dlopen dyld3::AllImages::dlopen dlclose dlopen_preflight dyld.h _dyld_image_count _dyld_get_image_header _dyld_get_image_vmaddr_slide _dyld_get_image_name _dyld_register_func_for_add_image _dyld_register_func_for_remove_image NSVersionOfRunTimeLibrary NSVersionOfLinkTimeLibrary _NSGetExecutablePath dyld_priv.h dyld_image_header_containing_address dyld_program_sdk_at_least dyld_shared_cache_file_path _dyld_get_all_image_infos dyld-interposing.h DYLD_INTERPOSE 其他 dyld类的函数 dyld::notifySingle dyld::initializeMainExecutable dyld::_main dyld::registerAddCallback ImageLoaderMachO类的函数 ImageLoaderMachO::doModInitFunctions ImageLoaderMachO::doInitialization ImageLoader类的函数 ImageLoader::recursiveInitialization ImageLoader::processInitializers ImageLoader::runInitializers dyldbootstrap类的函数 dyldbootstrap::start dyld3类的函数 dyld3::OverflowSafeArray dyld3::MachOFile::forEachLoadCommand dyld3::MachOFile::getUuid dyld4类的函数 dyld4::RuntimeState::initialize dyld4::APIs::_libdyld_initialize 全局变量 dyld`_main_thread dyld`initialPoolContent gProcessInfo dyld4::gProcessInfo dyld::gProcessInfo 相关定义 dyld_images.h dyld_all_image_infos ->别处引用 下划线开头的函数：_xxx 举例 /usr/lib/libSystem.B.dylib __dyld_get_image_header __dyld_get_image_name __dyld_get_image_vmaddr_slide __dyld_image_count __dyld_register_func_for_add_image __dyld_register_func_for_remove_image libdyld.dylib 是什么：动态库 位置 /usr/lib/system/libdyld.dylib 函数 dyld_stub_binder 相关 getsect.h getsectdata getsectdatafromFramework getsectiondata getsectbyname getsegbyname getsegmentdata getsectdatafromheader getsectdatafromheader_64 getsectbynamefromheader getsectbynamefromheader_64 getsectbynamefromheaderwithswap getsectbynamefromheaderwithswap_64 DYLD环境变量 DYLD_LIBRARY_PATH DYLD_INSERT_LIBRARIES DYLD_PRINT_LIBRARIES DYLD_PRINT_STATISTICS DYLD_IMAGE_SUFFIX DYLD_PRINT_APIS DYLD_PRINT_WARNINGS crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-15 10:44:48 "},"dyld/":{"url":"dyld/","title":"dyld","keywords":"","body":"dyld dyld头文件位置：mach-o/dyld.h 导入头文件#import crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-03-25 10:12:54 "},"dyld/man_help/":{"url":"dyld/man_help/","title":"man page=help","keywords":"","body":"dyld的：man page=help=语法 dyld(1) dyld(1) dyld(1) NAME dyld - the dynamic link editor SYNOPSIS DYLD_FRAMEWORK_PATH DYLD_FALLBACK_FRAMEWORK_PATH DYLD_VERSIONED_FRAMEWORK_PATH DYLD_LIBRARY_PATH DYLD_FALLBACK_LIBRARY_PATH DYLD_VERSIONED_LIBRARY_PATH DYLD_ROOT_PATH DYLD_SHARED_REGION DYLD_INSERT_LIBRARIES DYLD_FORCE_FLAT_NAMESPACE DYLD_IMAGE_SUFFIX DYLD_PRINT_OPTS DYLD_PRINT_ENV DYLD_PRINT_LIBRARIES DYLD_PRINT_LIBRARIES_POST_LAUNCH DYLD_BIND_AT_LAUNCH DYLD_NO_FIX_PREBINDING DYLD_DISABLE_DOFS DYLD_PRINT_APIS DYLD_PRINT_BINDINGS DYLD_PRINT_INITIALIZERS DYLD_PRINT_REBASINGS DYLD_PRINT_SEGMENTS DYLD_PRINT_STATISTICS DYLD_PRINT_DOFS DYLD_PRINT_RPATHS DYLD_SHARED_CACHE_DIR DYLD_SHARED_CACHE_DONT_VALIDATE DESCRIPTION The dynamic linker uses the following environment variables. They affect any program that uses the dynamic linker. DYLD_FRAMEWORK_PATH This is a colon separated list of directories that contain frameworks. The dynamic linker searches these directories before it searches for the framework by its install name. It allows you to test new versions of existing frameworks. (A framework is a library install name that ends in the form XXX.framework/Versions/YYY/XXX or XXX.framework/XXX, where XXX and YYY are any name.) For each framework that a program uses, the dynamic linker looks for the framework in each directory in DYLD_FRAMEWORK_PATH in turn. If it looks in all the directories and can't find the framework, it searches the directories in DYLD_LIBRARY_PATH in turn. If it still can't find the framework, it then searches DYLD_FALLBACK_FRAMEWORK_PATH and DYLD_FALLBACK_LIBRARY_PATH in turn. Use the -L option to otool(1). to discover the frameworks and shared libraries that the executable is linked against. DYLD_FALLBACK_FRAMEWORK_PATH This is a colon separated list of directories that contain frameworks. It is used as the default location for frameworks not found in their install path. By default, it is set to /Library/Frameworks:/Net- work/Library/Frameworks:/System/Library/Frameworks DYLD_VERSIONED_FRAMEWORK_PATH This is a colon separated list of directories that contain potential override frameworks. The dynamic linker searches these directories for frameworks. For each framework found dyld looks at its LC_ID_DYLIB and gets the current_version and install name. Dyld then looks for the framework at the install name path. Whichever has the larger current_version value will be used in the process whenever a framework with that install name is required. This is similar to DYLD_FRAMEWORK_PATH except instead of always overriding, it only overrides is the supplied framework is newer. Note: dyld does not check the framework's Info.plist to find its version. Dyld only checks the -cur- rrent_version number supplied when the framework was created. DYLD_LIBRARY_PATH This is a colon separated list of directories that contain libraries. The dynamic linker searches these directories before it searches the default locations for libraries. It allows you to test new versions of existing libraries. For each library that a program uses, the dynamic linker looks for it in each directory in DYLD_LIBRARY_PATH in turn. If it still can't find the library, it then searches DYLD_FALL- BACK_FRAMEWORK_PATH and DYLD_FALLBACK_LIBRARY_PATH in turn. Use the -L option to otool(1). to discover the frameworks and shared libraries that the executable is linked against. DYLD_FALLBACK_LIBRARY_PATH This is a colon separated list of directories that contain libraries. It is used as the default location for libraries not found in their install path. By default, it is set to $(HOME)/lib:/usr/local/lib:/lib:/usr/lib. DYLD_VERSIONED_LIBRARY_PATH This is a colon separated list of directories that contain potential override libraries. The dynamic linker searches these directories for dynamic libraries. For each library found dyld looks at its LC_ID_DYLIB and gets the current_version and install name. Dyld then looks for the library at the install name path. Whichever has the larger current_version value will be used in the process whenever a dylib with that install name is required. This is similar to DYLD_LIBRARY_PATH except instead of always overriding, it only overrides is the supplied library is newer. DYLD_ROOT_PATH This is a colon separated list of directories. The dynamic linker will prepend each of this directory paths to every image access until a file is found. DYLD_SHARED_REGION This can be \"use\" (the default), \"avoid\", or \"private\". Setting it to \"avoid\" tells dyld to not use the shared cache. All OS dylibs are loaded dynamically just like every other dylib. Set- ting it to \"private\" tells dyld to remove the shared region from the process address space and mmap() back in a private copy of the dyld shared cache in the shared region address range. This is only useful if the shared cache on disk has been updated and is different than the shared cache in use. DYLD_INSERT_LIBRARIES This is a colon separated list of dynamic libraries to load before the ones specified in the program. This lets you test new modules of existing dynamic shared libraries that are used in flat-namespace images by loading a temporary dynamic shared library with just the new modules. Note that this has no effect on images built a two-level namespace images using a dynamic shared library unless DYLD_FORCE_FLAT_NAMESPACE is also used. DYLD_FORCE_FLAT_NAMESPACE Force all images in the program to be linked as flat-namespace images and ignore any two-level namespace bindings. This may cause programs to fail to execute with a multiply defined symbol error if two-level namespace images are used to allow the images to have multiply defined symbols. DYLD_IMAGE_SUFFIX This is set to a string of a suffix to try to be used for all shared libraries used by the program. For libraries ending in \".dylib\" the suffix is applied just before the \".dylib\". For all other libraries the suffix is appended to the library name. This is useful for using conventional \"_profile\" and \"_debug\" libraries and frameworks. DYLD_PRINT_OPTS When this is set, the dynamic linker writes to file descriptor 2 (normally standard error) the command line options. DYLD_PRINT_ENV When this is set, the dynamic linker writes to file descriptor 2 (normally standard error) the environment variables. DYLD_PRINT_LIBRARIES When this is set, the dynamic linker writes to file descriptor 2 (normally standard error) the filenames of the libraries the program is using. This is useful to make sure that the use of DYLD_LIBRARY_PATH is getting what you want. DYLD_PRINT_LIBRARIES_POST_LAUNCH This does the same as DYLD_PRINT_LIBRARIES but the printing starts after the program gets to its entry point. DYLD_BIND_AT_LAUNCH When this is set, the dynamic linker binds all undefined symbols the program needs at launch time. This includes function symbols that can are normally lazily bound at the time of their first call. DYLD_PRINT_STATISTICS Right before the process's main() is called, dyld prints out information about how dyld spent its time. Useful for analyzing launch performance. DYLD_NO_FIX_PREBINDING Normally, dyld will trigger the dyld shared cache to be regener- ated if it notices the cache is out of date while launching a process. If this environment variable is set, dyld will not trigger a cache rebuild. This is useful to set while installing a large set of OS dylibs, to ensure the cache is not regenerated until the install is complete. DYLD_DISABLE_DOFS Causes dyld not register dtrace static probes with the kernel. DYLD_PRINT_INITIALIZERS Causes dyld to print out a line when running each initializers in every image. Initializers run by dyld included constructors for C++ statically allocated objects, functions marked with __attribute__((constructor)), and -init functions. DYLD_PRINT_APIS Causes dyld to print a line whenever a dyld API is called (e.g. NSAddImage()). DYLD_PRINT_SEGMENTS Causes dyld to print out a line containing the name and address range of each mach-o segment that dyld maps. In addition it prints information about if the image was from the dyld shared cache. DYLD_PRINT_BINDINGS Causes dyld to print a line each time a symbolic name is bound. DYLD_PRINT_DOFS Causes dyld to print out information about dtrace static probes registered with the kernel. DYLD_PRINT_RPATHS Cause dyld to print a line each time it expands an @rpath vari- able and whether that expansion was successful or not. DYLD_SHARED_CACHE_DIR This is a directory containing dyld shared cache files. This variable can be used in conjunction with DYLD_SHARED_REGION=pri- vate and DYLD_SHARED_CACHE_DONT_VALIDATE to run a process with an alternate shared cache. DYLD_SHARED_CACHE_DONT_VALIDATE Causes dyld to not check that the inode and mod-time of files in the shared cache match the requested dylib on disk. Thus a pro- gram can be made to run with the dylib in the shared cache even though the real dylib has been updated on disk. DYNAMIC LIBRARY LOADING Unlike many other operating systems, Darwin does not locate dependent dynamic libraries via their leaf file name. Instead the full path to each dylib is used (e.g. /usr/lib/libSys- tem.B.dylib). But there are times when a full path is not appropriate; for instance, may want your binaries to be instal- lable in anywhere on the disk. To support that, there are three @xxx/ variables that can be used as a path prefix. At runtime dyld substitutes a dynamically generated path for the @xxx/ pre- fix. @executable_path/ This variable is replaced with the path to the directory con- taining the main executable for the process. This is useful for loading dylibs/frameworks embedded in a .app directory. If the main executable file is at /some/path/My.app/Contents/MacOS/My and a framework dylib file is at /some/path/My.app/Con- tents/Frameworks/Foo.framework/Versions/A/Foo, then the frame- work load path could be encoded as @executable_path/../Frame- works/Foo.framework/Versions/A/Foo and the .app directory could be moved around in the file system and dyld will still be able to load the embedded framework. @loader_path/ This variable is replaced with the path to the directory con- taining the mach-o binary which contains the load command using @loader_path. Thus, in every binary, @loader_path resolves to a different path, whereas @executable_path always resolves to the same path. @loader_path is useful as the load path for a frame- work/dylib embedded in a plug-in, if the final file system loca- tion of the plugin-in unknown (so absolute paths cannot be used) or if the plug-in is used by multiple applications (so @exe- cutable_path cannot be used). If the plug-in mach-o file is at /some/path/Myfilter.plugin/Contents/MacOS/Myfilter and a frame- work dylib file is at /some/path/Myfilter.plugin/Contents/Frame- works/Foo.framework/Versions/A/Foo, then the framework load path could be encoded as @loader_path/../Frameworks/Foo.frame- work/Versions/A/Foo and the Myfilter.plugin directory could be moved around in the file system and dyld will still be able to load the embedded framework. @rpath/ Dyld maintains a current stack of paths called the run path list. When @rpath is encountered it is substituted with each path in the run path list until a loadable dylib if found. The run path stack is built from the LC_RPATH load commands in the depencency chain that lead to the current dylib load. You can add an LC_RPATH load command to an image with the -rpath option to ld(1). You can even add a LC_RPATH load command path that starts with @loader_path/, and it will push a path on the run path stack that relative to the image containing the LC_RPATH. The use of @rpath is most useful when you have a complex direc- tory structure of programs and dylibs which can be installed anywhere, but keep their relative positions. This scenario could be implemented using @loader_path, but every client of a dylib could need a different load path because its relative position in the file system is different. The use of @rpath introduces a level of indirection that simplies things. You pick a location in your directory structure as an anchor point. Each dylib then gets an install path that starts with @rpath and is the path to the dylib relative to the anchor point. Each main executable is linked with -rpath @loader_path/zzz, where zzz is the path from the executable to the anchor point. At runtime dyld sets it run path to be the anchor point, then each dylib is found relative to the anchor point. SEE ALSO libtool(1), ld(1), otool(1) Apple Inc. December 14, 2009 dyld(1) Mac OS X 10.7 - Generated Wed Aug 3 09:33:33 CDT 2011 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-09 09:33:41 "},"dyld/version.html":{"url":"dyld/version.html","title":"dyld版本","keywords":"","body":"dyld版本 iPhone中dyld的版本 iPhone中dyld的版本 概述 导出iPhone中/usr/lib/dyld，然后用工具（IDA、rabin2、jtool2等）分析出_dyldVersionString（和_dyldVersionNumber）中的版本号（字符串） 举例1 iPhone11 iPhone11中的dyld： /usr/lib/dyld 想要知道：dyld的版本号 最后是： （1）先是：根据源码 https://opensource.apple.com/source/dyld/dyld-433.5/include/mach-o/dyld_images.h 知道了其中有个： dyldVersion，其中会指向C字符串，其中包含：dyld-127.3这种值，其中就表示版本是：127.3 （2）去导出此处dyld二进制后，用工具（rabin2、jtool2等）查看到symbol中，包含dyldVersion字样的有： 1883 0x0004ddb8 0x0004ddb8 LOCAL FUNC 0 _dyldVersionString 1884 0x0004dde0 0x0004dde0 LOCAL FUNC 0 _dyldVersionNumber （3）去通过IDA分析二进制，而查看到： _dyldVersionString 地址：000000000004DDB8 值=字符串：@(#)PROGRAM:dyld PROJECT:dyld-932.4 -》即可从： dyld-932.4 找到最终要的值： dyld的版本号：932.4 iPhone7 导出iPhone7中的： iPhone7-1331:~ root# ls /usr/lib/dyld /usr/lib/dyld* iPhone7-1331:~ root# ls -lh /usr/lib/dyld -rwxr-xr-x 1 root wheel 650K Apr 14 2018 /usr/lib/dyld* 到Mac中： crifan@licrifandeMacBook-Pro  ~/dev/dev_root/iosReverse/AppleStore/debug/gProcessInfo/iPhone7_1331  scp root@192.168.2.6:/usr/lib/dyld dyld dyld 100% 650KB 6.5MB/s 00:00 crifan@licrifandeMacBook-Pro  ~/dev/dev_root/iosReverse/AppleStore/debug/gProcessInfo/iPhone7_1331  ll total 1304 -rwxr-xr-x 1 crifan staff 650K 1 13 22:58 dyld 去导出symbol： crifan@licrifandeMacBook-Pro  ~/dev/dev_root/iosReverse/AppleStore/debug/gProcessInfo/iPhone7_1331  rabin2 -s dyld > dyld_rabin2_s_symbols.txt Stack exhaustion prevented Stack exhaustion prevented Stack exhaustion prevented Stack exhaustion prevented Stack exhaustion prevented Stack exhaustion prevented crifan@licrifandeMacBook-Pro  ~/dev/dev_root/iosReverse/AppleStore/debug/gProcessInfo/iPhone7_1331  jtool2 -S dyld > dyld_jtool2_S_symbol.txt crifan@licrifandeMacBook-Pro  ~/dev/dev_root/iosReverse/AppleStore/debug/gProcessInfo/iPhone7_1331  ll total 2512 -rwxr-xr-x 1 crifan staff 650K 1 13 22:58 dyld -rw-r--r-- 1 crifan staff 186K 1 13 22:59 dyld_jtool2_S_symbol.txt -rw-r--r-- 1 crifan staff 412K 1 13 22:59 dyld_rabin2_s_symbols.txt 然后再去：搜dyldVersion /Users/crifan/dev/dev_root/iosReverse/AppleStore/debug/gProcessInfo/iPhone7_1331/dyld_rabin2_s_symbols.txt [Symbols] nth paddr vaddr bind type size lib name ―――――――――――――――――――――――――――――――――――――――――――――――――――― 0 0x0000e788 0x0000e788 GLOBAL FUNC 0 __dyld_debugger_notification 1 0x00052770 0x00052770 GLOBAL FUNC 0 _dyldVersionNumber 2 0x00052748 0x00052748 GLOBAL FUNC 0 _dyldVersionString 3 0x00068000 0x00068000 GLOBAL FUNC 0 _dyld_all_image_infos 4 0x00069180 0x00069180 GLOBAL FUNC 0 _error_string 5 0x00001000 0x00001000 LOCAL FUNC 0 __dyld_start ... -> _dyldVersionNumber: 0x00052770 _dyldVersionString: 0x00052748 再去用IDA查看版本号： 0x00052748 __const:0000000000052748 EXPORT _dyldVersionString __const:0000000000052748 _dyldVersionString DCB \"@(#)PROGRAM:dyld PROJECT:dyld-733.3.1\",0xA,0 __const:0000000000052770 EXPORT _dyldVersionNumber __const:0000000000052770 _dyldVersionNumber DCB 0x66 ; f __const:0000000000052771 DCB 0x66 ; f __const:0000000000052772 DCB 0x66 ; f __const:0000000000052773 DCB 0x66 ; f __const:0000000000052774 DCB 0x66 ; f __const:0000000000052775 DCB 0xEA __const:0000000000052776 DCB 0x86 __const:0000000000052777 DCB 0x40 ; @ __const:0000000000052778 ; `typeinfo name for'std::exception __const:0000000000052778 __ZTSSt9exception DCB \"St9exception\",0 -> _dyldVersionString @(#)PROGRAM:dyld PROJECT:dyld-733.3.1 -> dyld-733.3.1 dyld版本号：733.3.1 或许相关 当前（Mac或iPhone中）的dyld的版本 -> 或许是：dyld，就是ld？ -> 如果是，则 ld -v可以查看版本： 举例： ➜ ~ ld -v @(#)PROGRAM:ld PROJECT:ld64-711 BUILD 18:11:15 Aug 3 2021 configured to support archs: armv6 armv7 armv7s arm64 arm64e arm64_32 i386 x86_64 x86_64h armv6m armv7k armv7m armv7em LTO support using: LLVM version 13.0.0, (clang-1300.0.29.3) (static support for 27, runtime is 27) TAPI support using: Apple TAPI version 13.0.0 (tapi-1300.0.6.5) 其中，ld64-711中的711，好像就是：dyld的版本 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-12 11:45:04 "},"dyld/source/":{"url":"dyld/source/","title":"dyld源码","keywords":"","body":"dyld源码 dyld源码 opensource.apple.com 在线浏览 https://opensource.apple.com/source/dyld/ dyld-852.2 离线下载 https://opensource.apple.com/tarballs/dyld/ == https://github.com/apple-oss-distributions/dyld/tags dyld-1125.5 zip: https://github.com/apple-oss-distributions/dyld/archive/refs/tags/dyld-1125.5.zip tag.gz: https://github.com/apple-oss-distributions/dyld/archive/refs/tags/dyld-1125.5.tar.gz dyld-732.8 https://opensource.apple.com/tarballs/dyld/dyld-732.8.tar.gz == https://github.com/apple-oss-distributions/dyld/archive/refs/tags/dyld-732.8.tar.gz github https://github.com/opensource-apple/dyld 相关核心代码 相关核心代码 头文件 常用头文件: dyld.h、dyld_priv.h、dyld_images.h、dyld-interposing.h、dlfcn.h github.com https://github.com/opensource-apple/dyld/blob/master/include/mach-o/dyld.h https://github.com/opensource-apple/dyld/blob/master/include/mach-o/dyld_priv.h https://github.com/opensource-apple/dyld/blob/master/include/mach-o/dyld_images.h https://github.com/opensource-apple/dyld/blob/master/include/mach-o/dyld-interposing.h https://github.com/opensource-apple/dyld/blob/master/include/dlfcn.h opensource.apple.com dyld https://opensource.apple.com/source/dyld/dyld-852.2/include/mach-o/dyld.h.auto.html https://opensource.apple.com/source/dyld/dyld-852.2/include/mach-o/dyld_priv.h.auto.html https://opensource.apple.com/source/dyld/dyld-852.2/include/mach-o/dyld_images.h.auto.html https://opensource.apple.com/source/dyld/dyld-852.2/include/mach-o/dyld-interposing.h.auto.html https://opensource.apple.com/source/dyld/dyld-852.2/include/dlfcn.h.auto.html cctools https://opensource.apple.com/source/cctools/cctools-895/include/mach-o/dyld.h.auto.html https://opensource.apple.com/source/cctools/cctools-895/include/mach-o/dyld_priv.h.auto.html 其他头文件 dyld3/APIs.h https://opensource.apple.com/source/dyld/dyld-852.2/dyld3/APIs.h.auto.html mach-o/getsect.h https://opensource.apple.com/source/cctools/cctools-895/include/mach-o/getsect.h.auto.html 具体实现 dyld3 dyld3/APIs.cpp、dyldAPIs.cpp https://opensource.apple.com/source/dyld/dyld-852.2/dyld3/APIs.cpp.auto.html https://opensource.apple.com/source/dyld/dyld-852.2/src/dyldAPIs.cpp.auto.html dyld4 dyld.cpp、dyldAPIsInLibSystem.cpp、dyldAPIs.cpp https://github.com/opensource-apple/dyld/blob/master/src/dyld.cpp https://github.com/opensource-apple/dyld/blob/master/src/dyldAPIsInLibSystem.cpp https://github.com/opensource-apple/dyld/blob/master/src/dyldAPIs.cpp crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-15 10:38:36 "},"dyld/loading_process/":{"url":"dyld/loading_process/","title":"dyld加载过程","keywords":"","body":"dyld加载过程 iOS的app启动过程 iOS的app启动过程 概述 详细 iOS的app启动的不同阶段 Pre-main阶段 图 文字版 加载可执行文件（读取Mach-O） 加载动态库（Dylib） Rebase & Bind Objc Initializers main阶段 iOS的app启动调用函数 dyld加载过程 dyld加载过程 图 文字版 图 文字版：9步 第一步：设置运行环境 第二步：加载共享缓存 第三步：实例化主程序 第四步：加载插入的动态库 第五步：链接主程序 第六步：链接插入的动态库 第七步：执行弱符号绑定 第八步：执行初始化方法 第九步：查找入口点并返回 dyld(加载Mach-O)涉及到 校验代码签名codesign segment load commands 映射地址空间address space 即：多个段segment 设置load commands是可执行executable dyld3 dyld4 dyld加载过程1 (lldb) bt * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 23.2 * frame #0: 0x000000018d124174 libdyld.dylib`dladdr frame #1: 0x000000010b0bfbac AwemeCore`___lldb_unnamed_symbol13025$$AwemeCore + 80 frame #2: 0x000000018d041c38 libobjc.A.dylib`CALLING_SOME_+initialize_METHOD + 20 frame #3: 0x000000018d04742c libobjc.A.dylib`initializeNonMetaClass + 644 frame #4: 0x000000018d0471f8 libobjc.A.dylib`initializeNonMetaClass + 80 frame #5: 0x000000018d047ba8 libobjc.A.dylib`initializeAndMaybeRelock(objc_class*, objc_object*, mutex_tt&, bool) + 284 frame #6: 0x000000018d05450c libobjc.A.dylib`lookUpImpOrForward + 700 frame #7: 0x000000018d0448a8 libobjc.A.dylib`object_setClass + 104 frame #8: 0x000000018d29da70 CoreFoundation`_CFRuntimeCreateInstance + 580 frame #9: 0x000000018d2bcb74 CoreFoundation`__CFStringCreateImmutableFunnel3 + 1944 frame #10: 0x000000018d2bcef8 CoreFoundation`CFStringCreateWithCString + 92 frame #11: 0x000000018d29f610 CoreFoundation`__CFInitialize + 812 frame #12: 0x0000000104fddfac dyld`ImageLoaderMachO::doImageInit(ImageLoader::LinkContext const&) + 248 frame #13: 0x0000000104fde580 dyld`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext const&) + 40 frame #14: 0x0000000104fd95d0 dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&, unsigned int, char const*, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 548 frame #15: 0x0000000104fd953c dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&, unsigned int, char const*, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 400 frame #16: 0x0000000104fd8334 dyld`ImageLoader::processInitializers(ImageLoader::LinkContext const&, unsigned int, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 184 frame #17: 0x0000000104fd83fc dyld`ImageLoader::runInitializers(ImageLoader::LinkContext const&, ImageLoader::InitializerTimingList&) + 92 frame #18: 0x0000000104fca3d0 dyld`dyld::initializeMainExecutable() + 136 frame #19: 0x0000000104fcedb4 dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 4616 frame #20: 0x0000000104fc9208 dyld`dyldbootstrap::start(dyld3::MachOLoaded const*, int, char const**, dyld3::MachOLoaded const*, unsigned long*) + 396 frame #21: 0x0000000104fc9038 dyld`_dyld_start + 56 == dyld`_dyld_start dyld`dyldbootstrap::start dyld`dyld::_main dyld`dyld::initializeMainExecutable dyld`ImageLoader::runInitializers dyld`ImageLoader::processInitializers dyld`ImageLoader::recursiveInitialization dyld`ImageLoaderMachO::doInitialization dyld`ImageLoaderMachO::doImageInit ... libdyld.dylib`dladdr dyld加载过程2 _dyld_start dyldbootstrap: : start dyld: : _main dyld: : initializeMainExecutable ImageLoader::runInitializers ImageLoader::processInitializers ImageLoader::recursiveInitialization Dyld ::notifySingle libobjC.a. dylib load_images +[ViewController load] dyld加载过程3 (lldb) bt * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 6.1 * frame #0: 0x0000000102495310 libAwemeDylib.dylib`_logos_method$_ungrouped$NSString$stringByAppendingString$(self=\"https://\", _cmd=\"stringByAppendingString:\", aString=0x0000000000000000) at AwemeDylib.xm:175:29 frame #1: 0x0000000108532cf8 AwemeCore`___lldb_unnamed_symbol3548$$AwemeCore + 520 ... frame #38: 0x00000001c2ecf60c FrontBoardServices`-[FBSSerialQueue _performNextFromRunLoopSource] + 28 frame #39: 0x00000001bdcd0a00 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24 frame #40: 0x00000001bdcd0958 CoreFoundation`__CFRunLoopDoSource0 + 80 frame #41: 0x00000001bdcd00f0 CoreFoundation`__CFRunLoopDoSources0 + 180 frame #42: 0x00000001bdccb23c CoreFoundation`__CFRunLoopRun + 1080 frame #43: 0x00000001bdccaadc CoreFoundation`CFRunLoopRunSpecific + 464 frame #44: 0x00000001c7c6b328 GraphicsServices`GSEventRunModal + 104 frame #45: 0x00000001c1dd863c UIKitCore`UIApplicationMain + 1936 frame #46: 0x000000010efec094 AwemeCore`awemeMain + 200 frame #47: 0x0000000102267ca4 Aweme`___lldb_unnamed_symbol21$$Aweme + 12 frame #48: 0x00000001bdb54360 libdyld.dylib`start + 4 libdyld.dylib`start 开始的调用顺序 app相关逻辑：Aweme___lldb_unnamed_symbol21$$Aweme、AwemeCoreawemeMain 然后才是其他系统常见函数 UIKitCore`UIApplicationMain ... 相关 launchd launchd是第一个被内核启动的用户态进程，负责直接或间接的启动系统中的其他进程。它是用户模式里所有进程的父进程，同时也将负责两种后台作业：守护程序和代理程序。 守护程序：后台服务，通常和用户没有交互。比如push通知、外接设备插入的处理和XPC等。 代理程序：可以和用户交互，比如Mac的Finder或iOS的SpringBoard就是其中之一，即广义上我们理解的桌面。 launchd是如何被创建的，得先看下下面这张： XNU启动流程图 图 文字 start(iOS)：初始化MSR、物理页映射、安装中断处理函数 arm_init(iOS)：初始化平台，为启动内核做准备 machine_startup：解析命令行参数和调试参数 kernel_bootstrap：安装和初始化mach内核的子系统，包括：进程间通信、时钟、访问策略、进程和线程调度 kernel_bootstrap_thread：创建idle线程，初始化iokit设备驱动框架，初始化应用程序和dyld运行所需的共享模块。如果内核开启了mac(强制访问控制)策略，则会进行mac的初始化，以确系统的安全 bsd_init：内核部分剩余的事情都由其来做，初始化各个子系统。网络、文件系统、管道、内存cache、线程、进程、同步对象、权限策略等等。 一切完成后，会执行/sbin/launchd来创建一个launchd crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-15 10:41:37 "},"dyld/func/":{"url":"dyld/func/","title":"相关函数","keywords":"","body":"相关函数 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-15 10:47:14 "},"dyld/func/dyld_api/":{"url":"dyld/func/dyld_api/","title":"dyld的API","keywords":"","body":"dyld的API 关于dyld的各种函数，主要都是 定义在 dyld3/APIs.h 实现在： 最新的：dyld4 ? dyld/dyld-852.2 dyldAPIs dyldAPIs.cpp opensource-apple/dyld dyldAPIs.cpp dyldAPIsInLibSystem.cpp 之前的：dyld3 dyld/dyld-852.2 dyld3/APIs.cpp 别处引用在 dyld.h dyld/dyld-852.2 mach-o/dyld.h cctools/cctools-895 mach-o/dyld.h dyld_priv.h dyld/dyld-852.2 mach-o/dyld_priv.h opensource-apple/dyld dyld/include/mach-o/dyld_priv.h 下面具体介绍： crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-12 15:40:31 "},"dyld/func/dyld_api/dlfcn_h/":{"url":"dyld/func/dyld_api/dlfcn_h/","title":"dlfcn.h","keywords":"","body":"dlfcn.h 关于 dladdr dlclose dlerror dlopen dlsym 等函数，是： 别处引用在 dlfcn.h 相关 dlfcn.h头文件内容 举例： dyld-852.2 dlfcn.h /* * Copyright (c) 2004-2008 Apple Inc. All rights reserved. * * @APPLE_LICENSE_HEADER_START@ * * This file contains Original Code and/or Modifications of Original Code * as defined in and that are subject to the Apple Public Source License * Version 2.0 (the 'License'). You may not use this file except in * compliance with the License. Please obtain a copy of the License at * http://www.opensource.apple.com/apsl/ and read it before using this * file. * * The Original Code and all software distributed under the License are * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES, * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. * Please see the License for the specific language governing rights and * limitations under the License. * * @APPLE_LICENSE_HEADER_END@ */ /* Based on the dlcompat work done by: Jorge Acereda & Peter O'Gorman */ #ifndef _DLFCN_H_ #define _DLFCN_H_ #ifdef __cplusplus extern \"C\" { #endif #include #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE) #include #include #ifdef __DRIVERKIT_19_0 #define __DYLDDL_DRIVERKIT_UNAVAILABLE __API_UNAVAILABLE(driverkit) #else #define __DYLDDL_DRIVERKIT_UNAVAILABLE #endif /* * Structure filled in by dladdr(). */ typedef struct dl_info { const char *dli_fname; /* Pathname of shared object */ void *dli_fbase; /* Base address of shared object */ const char *dli_sname; /* Name of nearest symbol */ void *dli_saddr; /* Address of nearest symbol */ } Dl_info; extern int dladdr(const void *, Dl_info *); #else #define __DYLDDL_DRIVERKIT_UNAVAILABLE #endif /* not POSIX */ extern int dlclose(void * __handle) __DYLDDL_DRIVERKIT_UNAVAILABLE; extern char * dlerror(void) __DYLDDL_DRIVERKIT_UNAVAILABLE; extern void * dlopen(const char * __path, int __mode) __DYLDDL_DRIVERKIT_UNAVAILABLE; extern void * dlsym(void * __handle, const char * __symbol) __DYLDDL_DRIVERKIT_UNAVAILABLE; #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE) extern bool dlopen_preflight(const char* __path) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0) __DYLDDL_DRIVERKIT_UNAVAILABLE; #endif /* not POSIX */ #define RTLD_LAZY 0x1 #define RTLD_NOW 0x2 #define RTLD_LOCAL 0x4 #define RTLD_GLOBAL 0x8 #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE) #define RTLD_NOLOAD 0x10 #define RTLD_NODELETE 0x80 #define RTLD_FIRST 0x100 /* Mac OS X 10.5 and later */ /* * Special handle arguments for dlsym(). */ #define RTLD_NEXT ((void *) -1) /* Search subsequent objects. */ #define RTLD_DEFAULT ((void *) -2) /* Use default search algorithm. */ #define RTLD_SELF ((void *) -3) /* Search this and subsequent objects (Mac OS X 10.5 and later) */ #define RTLD_MAIN_ONLY ((void *) -5) /* Search main executable only (Mac OS X 10.5 and later) */ #endif /* not POSIX */ #ifdef __cplusplus } #endif #endif /* _DLFCN_H_ */ crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-15 10:05:09 "},"dyld/func/dyld_api/dlfcn_h/dladdr.html":{"url":"dyld/func/dyld_api/dlfcn_h/dladdr.html","title":"dladdr","keywords":"","body":"dladdr 所属头文件: dlfcn.h 语法定义int dladdr(const void* addr, Dl_info* info); man page DLADDR(3) BSD Library Functions Manual DLADDR(3) NAME dladdr -- find the image containing a given address SYNOPSIS #include int dladdr(const void* addr, Dl_info* info); DESCRIPTION The dladdr() function queries dyld (the dynamic linker) for information about the image containing the address addr. The information is returned in the structure specified by info. The structure contains at least the following members: const char* dli_fname The pathname of the shared object containing the address. void* dli_fbase The base address (mach_header) at which the image is mapped into the address space of the calling process. const char* dli_sname The name of the nearest run-time symbol with a value less than or equal to addr. void* dli_saddr The value of the symbol returned in dli_sname. The dladdr() function is available only in dynamically linked programs. ERRORS If an image containing addr cannot be found, dladdr() returns 0. On suc-cess, success, cess, a non-zero value is returned. If the image containing addr is found, but no nearest symbol was found, the dli_sname and dli_saddr fields are set to NULL. SEE ALSO dyld(3), dlopen(3) HISTORY The dladdr() function first appeared in the Solaris operating system. AUTHORS Mac OS X 10.3 incorporated the dlcompat package written by Jorge Acereda and Peter O'Gorman . In Mac OS X 10.4, dlopen was rewritten to be a native part of dyld. This man page was borrowed from FreeBSD and modified. BUGS This implementation is almost bug-compatible with the Solaris implementa-tion. implementation. tion. The following bugs are present: oo Returning 0 as an indication of failure goes against long-standing Unix tradition. BSD September 24, 2004 BSD 越狱检测 最新的逻辑 可以用代码： Dl_info dylib_info; int (*func_stat)(const char *, struct stat *) = stat; int ret = dladdr(func_stat, &dylib_info); 可以解析出动态库的信息了： usr/lib/system/libsystem_kernel.dylib 类似的： FILE* (*func_fopen)(const char *filename, const char *mode) = fopen; int ret = dladdr(func_fopen, &dylib_info); 是： /usr/lib/system/libsystem_c.dylib 此时： 非越狱手机（iOS 12.5.5的iPhone6P） 返回的是：（符合预期的）系统的库 但是： 已越狱手机（iOS 13.6.1的iPhone7 和 iOS 12.4.5的iPhone6） + 已hook对应函数：stat、fopen等 也是返回系统的库： 和预期不一样，应该返回：非系统库 后续才能用这个逻辑，去判断是否越狱 现在就是：此办法，无法用于检测是否是越狱了 目前没找到根本原因 推测是：苹果iOS系统早已升级dladdr的内部实现机制 使得，之前（多年前）生效的用dladdr检测是否是越狱的机制，现已失效。 最新的结论是： 是用 _dyld_image_count _dyld_get_image_name _dyld_get_image_header _dyld_get_image_vmaddr_slide 成套的hook，去实现的： 越狱检测 检测是否有反越狱库 其相关代码是： static NSString* checkImageResult = @\"未发现越狱库 -> 非越狱手机\"; NSMutableArray *checkImageFoundJbLibList = NULL; + (void)load { static dispatch_once_t onceToken; dispatch_once(&onceToken, ^{ checkImageFoundJbLibList = [NSMutableArray array]; _dyld_register_func_for_add_image(_check_image); }); } + (instancetype)sharedInstance { static id sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&onceToken, ^{ sharedInstance = [self new]; }); return sharedInstance; } static void _check_image(const struct mach_header *header, intptr_t slide) { Dl_info info; size_t dlInfoSize = sizeof(Dl_info); memset(&info, 0, dlInfoSize); dladdr(header, &info); const char* curImgName = info.dli_fname; if(curImgName != NULL) { if (isJailbreakDylib(curImgName)) { NSString *curImgNameNs = [NSString stringWithUTF8String: curImgName]; [checkImageFoundJbLibList addObject: curImgNameNs]; NSString *jbLibListStr = [CrifanLibiOS nsStrListToStr:checkImageFoundJbLibList isSortList:TRUE isAddIndexPrefix:TRUE]; checkImageResult = [NSString stringWithFormat: @\"发现越狱动态库 -> 越狱手机\\n%@\", jbLibListStr]; NSLog(@\"%@\", checkImageResult); // \"Found Jailbreak dylib: /usr/lib/substitute-inserter.dylib -> 越狱手机\" } } return; } 最新完整代码，详见： crifan/iOSJailbreakDetection: iOS的ObjC的app，实现iOS越狱检测 JbDetectOtherViewController.m static void _check_image(const struct mach_header *header, intptr_t slide) 别人的相关代码 #import void checkInject(void) { int ret ; Dl_info dylib_info; int (*func_stat)(const charchar *, struct stat *) = stat; if ((ret = dladdr(func_stat, &dylib_info))) { NSLog(@\"lib :%s\", dylib_info.dli_fname); } } #import #if！TARGET IPHONE SIMULATOR //check hook stat int ret； Dl info dylib info； int(*func_stat)(const char*，struct stat*)=stat； if((ret=dladdr(func_stat，&dylib info))){ NSLog(@\"lib：s\"，dylib info.dli_fname)； char *kernal=\"/usr/lib/system/libsystem_kernel.dylib\"； if(strcmp(dylib_info.dli_fname，kernal)!=0){ //device is jail break //Let it go } } #endif #import #import #if !TARGET_IPHONE_SIMULATOR //check hook stat int ret ; Dl_info dylib_info; int (*func_stat)(const char *, struct stat *) = stat; if ((ret = dladdr(func_stat, &dylib_info))) { NSLog(@\"lib :%s\", dylib_info.dli_fname); char* kernal = \"/usr/lib/system/libsystem_kernel.dylib\";//real device //usr/lib/system/libsystem_sim_kernel.dylib //simulator if (strcmp(dylib_info.dli_fname,kernal)!=0) { return YES; } } ... #endif #pragma mark 使用stat通过检测一些越狱后的关键文件是否可以访问来判断是否越狱，hook stat 方法和dladdr可以绕过 BOOL isStatNotSystemLib() { if(TARGET_IPHONE_SIMULATOR)return NO; int ret ; Dl_info dylib_info; int (*func_stat)(const char *, struct stat *) = stat; if ((ret = dladdr(func_stat, &dylib_info))) { NSString *fName = [NSString stringWithUTF8String: dylib_info.dli_fname]; if(![fName isEqualToString:@\"/usr/lib/system/libsystem_kernel.dylib\"]){ return YES; } } ... #include #include #include #include #include Dl_info info; IMP imp; Method orginalMethod = class_getClassMethod([NSArray class], @selector(description)); imp = method_getImplementation(orginalMethod); if (dladdr(imp, &info)) { printf(\"dli_fname: %s\\n\", info.dli_fname); printf(\"dli_sname: %s\\n\", info.dli_sname); printf(\"dli_fbase: %p\\n\", info.dli_fbase); printf(\"dli_saddr: %p\\n\", info.dli_saddr); } else { printf(\"error: can't find that symbol.\\n\"); } ... if(!dladdr(imp, &info)){ free(methods); return NO; } /*Validate image path*/ if(!strstr(info.dli_fname, fnamePre)){ goto FAIL; } Dl_info info; if (dladdr(exit, &info)) { printf(\"dli_fname: %s\\n\", info.dli_fname); printf(\"dli_sname: %s\\n\", info.dli_sname); printf(\"dli_fbase: %p\\n\", info.dli_fbase); printf(\"dli_saddr: %p\\n\", info.dli_saddr); } else { printf(\"error: can't find that symbol.\\n\"); } if (dladdr(syscall, &info)) { printf(\"dli_fname: %s\\n\", info.dli_fname); printf(\"dli_sname: %s\\n\", info.dli_sname); printf(\"dli_fbase: %p\\n\", info.dli_fbase); printf(\"dli_saddr: %p\\n\", info.dli_saddr); } else { printf(\"error: can't find that symbol.\\n\"); } if (dladdr(sysctl, &info)) { printf(\"dli_fname: %s\\n\", info.dli_fname); printf(\"dli_sname: %s\\n\", info.dli_sname); printf(\"dli_fbase: %p\\n\", info.dli_fbase); printf(\"dli_saddr: %p\\n\", info.dli_saddr); } else { printf(\"error: can't find that symbol.\\n\"); } ================================================ dli_fname: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Library/Developer/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/usr/lib/system/libsystem_c.dylib dli_sname: exit dli_fbase: 0x7fff51a76000 dli_saddr: 0x7fff51ad0046 dli_fname: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Library/Developer/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/usr/lib/system/libsystem_kernel.dylib dli_sname: __syscall dli_fbase: 0x7fff51b5a000 dli_saddr: 0x7fff51b5c9f0 dli_fname: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Library/Developer/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/usr/lib/system/libsystem_c.dylib dli_sname: sysctl dli_fbase: 0x7fff51a76000 dli_saddr: 0x7fff51aa1304 #include #include #include #include #include + (void)test { Dl_info info; IMP imp; Method orginalMethod = class_getClassMethod([NSObject class], @selector(load)); imp = method_getImplementation(orginalMethod); if (dladdr(imp, &info)) { printf(\"dli_fname: %s\\n\", info.dli_fname); printf(\"dli_sname: %s\\n\", info.dli_sname); printf(\"dli_fbase: %p\\n\", info.dli_fbase); printf(\"dli_saddr: %p\\n\", info.dli_saddr); } else { printf(\"error: can't find that symbol.\\n\"); } } ==================================================== dli_fname: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Library/Developer/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/Foundation.framework/Foundation dli_sname: +[NSObject(NSObject) load] dli_fbase: 0x7fff25888000 //模块地址 dli_saddr: 0x7fff2591bb43 //函数地址 反越狱检测 之前旧的代码： #include #include /*============================================================================== hook dladdr() ==============================================================================*/ void* generateHookedDladdrAddress(void *origAddr); const long DLADDR_HOOKED_ADDRESS_BASE = 0xF00000000000; //const unsigned long DLADDR_HOOKED_ADDRESS_MAX = 0xFFFF000000000000; void* generateHookedDladdrAddress(void *origAddr) { // if ((long)origAddr (long)DLADDR_HOOKED_ADDRESS_BASE) { hookedAddr = origAddr; } else { hookedAddr = (void*)((long)origAddr + DLADDR_HOOKED_ADDRESS_BASE); } return hookedAddr; } static bool isHookedDladdrAddress(const void *addr){ bool isHookedAddr = false; long addrLong = (long) addr; // if ((addrLong > DLADDR_HOOKED_ADDRESS_BASE) && (addrLong DLADDR_HOOKED_ADDRESS_BASE) { isHookedAddr = true; } return isHookedAddr; } static void* hookedToOrigDladdrAddr(const void *hookedAddr){ return (void*) ( (long)hookedAddr - DLADDR_HOOKED_ADDRESS_BASE ); } const int DLADDR_FAILED = 0; int dladdr(const void *, Dl_info *); //int dladdr(void *, Dl_info *); //extern int dladdr(const void *, Dl_info *); //%hookf(int, dladdr, void *addr, Dl_info *info){ %hookf(int, dladdr, const void *addr, Dl_info *info){ iosLogDebug(\"addr=%p,info=%p\", addr, info); void* origAddr = (void*)addr; bool isHookedAddr = isHookedDladdrAddress(addr); if (isHookedAddr) { origAddr = hookedToOrigDladdrAddr(addr); iosLogDebug(\"addr=%p -> isHookedAddr=%s -> origAddr=%p\", addr, boolToStr(isHookedAddr), origAddr); } // int origRet = %orig; int origRet = %orig(origAddr, info); int finalRet = origRet; bool isNotHookedAddr = !isHookedAddr; bool isNeedHook = cfgHookEnable_dylib_dladdr && isNotHookedAddr; if (isNeedHook) { // if (dladdrRetInt > 0) { if (DLADDR_FAILED != origRet) { if (NULL != info) { const char* curImageName = info->dli_fname; bool isJbDyib = isJailbreakDylib(curImageName); if (isJbDyib) { finalRet = DLADDR_FAILED; iosLogInfo(\"addr=%p -> origRet=%d -> dli_fname=%{public}s, dli_fbase=%p, dli_sname=%{public}s, dli_saddr=%p -> isJbDyib=%s -> finalRet=%d\", addr, origRet, info->dli_fname, info->dli_fbase, info->dli_sname, info->dli_saddr, boolToStr(isJbDyib), finalRet); // iosLogInfo(\"isJbDyib=%s\", boolToStr(isJbDyib)); // iosLogInfo(\"addr=%p -> origRet=%d\", addr, origRet); // iosLogInfo(\"dli_fname=%{public}s, dli_fbase=%p, dli_sname=%{public}s, dli_saddr=%p\", info->dli_fname, info->dli_fbase, info->dli_sname, info->dli_saddr); // iosLogInfo(\"finalRet=%d\", finalRet); size_t dlInfoSize = sizeof(Dl_info); memset(info, 0, dlInfoSize); } } } } return finalRet; } 实现了： 当有越狱库：返回0，且清空Dl_info 正常库：正常返回 输出举例： 默认 14:49:59.788331+0800 Aweme hook_dylib.xm dladdr: addr=0x10148c000 -> origRet=1 -> dli_fname=/usr/lib/substitute-inserter.dylib, dli_fbase=0x10148c000, dli_sname=__dso_handle, dli_saddr=0x10148c000 -> isJbDylib=True -> finalRet=0 默认 14:49:59.831705+0800 Aweme hook_dylib.xm dladdr: addr=0x1150d0000 -> origRet=1 -> dli_fname=/usr/lib/libsubstitute.dylib, dli_fbase=0x1150d0000, dli_sname=__dso_handle, dli_saddr=0x1150d0000 -> isJbDylib=True -> finalRet=0 默认 14:49:59.831804+0800 Aweme hook_dylib.xm dladdr: addr=0x116104000 -> origRet=1 -> dli_fname=/usr/lib/substitute-loader.dylib, dli_fbase=0x116104000, dli_sname=__dso_handle, dli_saddr=0x116104000 -> isJbDylib=True -> finalRet=0 默认 14:49:59.831856+0800 Aweme hook_dylib.xm dladdr: addr=0x11506c000 -> origRet=1 -> dli_fname=/usr/lib/libsubstrate.dylib, dli_fbase=0x11506c000, dli_sname=__dso_handle, dli_saddr=0x11506c000 -> isJbDylib=True -> finalRet=0 默认 14:49:59.831907+0800 Aweme hook_dylib.xm dladdr: addr=0x115740000 -> origRet=1 -> dli_fname=/Library/MobileSubstrate/DynamicLibraries/AppSyncUnified-FrontBoard.dylib, dli_fbase=0x115740000, dli_sname=__dso_handle, dli_saddr=0x115740000 -> isJbDylib=True -> finalRet=0 默认 14:49:59.831954+0800 Aweme hook_dylib.xm dladdr: addr=0x115750000 -> origRet=1 -> dli_fname=/Library/MobileSubstrate/DynamicLibraries/XxxTweak.dylib, dli_fbase=0x115750000, dli_sname=__dso_handle, dli_saddr=0x115750000 -> isJbDylib=True -> finalRet=0 最新代码详见： crifan/iOSBypassJailbreak: 越狱iOS的hook插件，实现反越狱检测 hook_dylib.xm crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-14 10:46:44 "},"dyld/func/dyld_api/dlfcn_h/dlsym.html":{"url":"dyld/func/dyld_api/dlfcn_h/dlsym.html","title":"dlsym","keywords":"","body":"dlsym 所属头文件: dlfcn.h> 函数定义void* dlsym(void* handle, const char* symbol); man page DLSYM(3) BSD Library Functions Manual DLSYM(3) NAME dlsym -- get address of a symbol SYNOPSIS #include void* dlsym(void* handle, const char* symbol); DESCRIPTION dlsym() returns the address of the code or data location specified by the null-terminated character string symbol. Which libraries and bundles are searched depends on the handle parameter. If dlsym() is called with a handle, returned by dlopen() then only that image and any libraries it depends on are searched for symbol. If dlsym() is called with the special handle RTLD_DEFAULT, then all mach-o macho o images in the process (except those loaded with dlopen(xxx, RTLD_LOCAL)) are searched in the order they were loaded. This can be a costly search and should be avoided. If dlsym() is called with the special handle RTLD_NEXT, then the search for the symbol is limited to the images which were loaded after the one issuing the call to dlsym(). RETURN VALUES The dlsym() function returns a null pointer if the symbol cannot be found, and sets an error condition which may be queried with dlerror(). NOTES Unlike other dyld API's, the symbol name passed to dlsym() must NOT be prepended with an underscore. SEE ALSO dlopen(3) dlsym(3) dlerror(3) dyld(3) NSModule(3) NSObjectFileImage(3) ld(1) cc(1) Sept 25, 2004 越狱检测 最新代码 crifan/iOSJailbreakDetection: iOS的ObjC的app，实现iOS越狱检测 JbDetectOtherViewController.m - (IBAction)dlopenDlsymBtnClicked:(UIButton *)sender 之前代码 _curBtnLbl.text = sender.titleLabel.text; NSLog(@\"dlopen + dlsym check\"); typedef void (*function_common) (void *para); // typedef void (*lib_MSHookFunction)(void *symbol, void *hook, void **old); char* dylibPathList[] = { // // for debug // \"/usr/lib/libstdc++.dylib\", // \"/usr/lib/libstdc++.6.dylib\", // \"/usr/lib/libstdc++.6.0.9.dylib\", // common: tweak plugin libs \"/usr/lib/libsubstrate.dylib\", // Cydia Substrate libs \"/Library/MobileSubstrate/MobileSubstrate.dylib\", \"/usr/lib/substrate/SubstrateInserter.dylib\", \"/usr/lib/substrate/SubstrateLoader.dylib\", \"/usr/lib/substrate/SubstrateBootstrap.dylib\", // Substitute libs \"/usr/lib/libsubstitute.dylib\", \"/usr/lib/substitute-inserter.dylib\", \"/usr/lib/substitute-loader.dylib\", // Other libs \"/usr/lib/tweakloader.dylib\", }; const int StrSize = sizeof(const char *); const int DylibLen = sizeof(dylibPathList) / StrSize; char* libFuncNameList[] = { \"MSGetImageByName\", \"MSFindSymbol\", \"MSHookFunction\", \"MSHookMessageEx\", \"SubGetImageByName\", \"SubFindSymbol\", \"SubHookFunction\", \"SubHookMessageEx\", }; const int LibFuncLen = sizeof(libFuncNameList) / StrSize; // NSMutableArray *detectedJbDylibList = [NSMutableArray array]; // NSMutableArray *detectedJbFuncNameList = [NSMutableArray array]; NSMutableArray *detectedJbLibAndFuncList = [NSMutableArray array]; for(int libIdx = 0; libIdx %s\", curDylib, curFuncName]; [detectedJbLibAndFuncList addObject:curLibAndFuncNs]; } } dlclose(curLibHandle); } } NSString* finalResult = @\"\"; // BOOL isJb = (detectedJbDylibList.count > 0) || (detectedJbFuncNameList.count > 0); // NSString *detectedJbDylibListStr = [CrifanLibiOS nsStrListToStr:detectedJbDylibList isSortList:FALSE isAddIndexPrefix:TRUE]; // NSString *detectedJbFuncNameListStr = [CrifanLibiOS nsStrListToStr:detectedJbFuncNameList isSortList:FALSE isAddIndexPrefix:TRUE]; // NSString* detectedLibAndFuncNameStr = [NSString stringWithFormat:@\"越狱库=%@\\n库函数=%@\", detectedJbDylibListStr, detectedJbFuncNameListStr] ; BOOL isJb = (detectedJbLibAndFuncList.count > 0); NSString *detectedJbLibAndFuncListStr = [CrifanLibiOS nsStrListToStr:detectedJbLibAndFuncList isSortList:FALSE isAddIndexPrefix:TRUE]; NSString* detectedLibAndFuncNameStr = [NSString stringWithFormat:@\"越狱库和库函数=%@\", detectedJbLibAndFuncListStr]; if (isJb){ finalResult = [NSString stringWithFormat:@\"检测出越狱库或库函数 -> 越狱手机\\n%@\", detectedLibAndFuncNameStr] ; } else { finalResult = @\"未检测出越狱库和库函数 -> 非越狱手机\"; } NSLog(@\"finalResult=%@\", finalResult); _detectResultTv.text = finalResult; 反越狱检测 最新代码 crifan/iOSBypassJailbreak: 越狱iOS的hook插件，实现反越狱检测 hook_dylib.xm 之前代码 /*============================================================================== Hook: dlsym() ==============================================================================*/ // https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dlsym.3.html void* dlsym(void* handle, const char* symbol); %hookf(void*, dlsym, void* handle, const char* symbol) { iosLogDebug(\"handle=%p, symbol=%{public}s\", handle, symbol); void* dlsymRetPtr = NULL; bool isJbFuncName = isJailbreakDylibFunctionName(symbol); if (isJbFuncName) { dlsymRetPtr = NULL; } else { dlsymRetPtr = %orig(handle, symbol); } if (isJbFuncName) { iosLogInfo(\"handle=%p, symbol=%{public}s -> isJbFuncName=%s -> dlsymRetPtr=%p\", handle, symbol, boolToStr(isJbFuncName), dlsymRetPtr); } return dlsymRetPtr; } /*============================================================================== Hook: dlopen() ==============================================================================*/ // https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dlopen.3.html void* dlopen(const char* path, int mode); %hookf(void*, dlopen, const char* path, int mode){ iosLogDebug(\"path=%{public}s, mode=0x%x\", path, mode); void* dlopenRetPtr = NULL; bool isJbDylib = isJailbreakDylib(path); if (isJbDylib) { dlopenRetPtr = NULL; } else { dlopenRetPtr = %orig(path, mode); } if (isJbDylib) { iosLogInfo(\"path=%{public}s, mode=0x%x -> isJbDylib=%s -> dlopenRetPtr=%p\", path, mode, boolToStr(isJbDylib), dlopenRetPtr); } return dlopenRetPtr; } 效果： 反越狱前： 反越狱后： crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-14 10:07:56 "},"dyld/func/dyld_api/dlfcn_h/dlinfo.html":{"url":"dyld/func/dyld_api/dlfcn_h/dlinfo.html","title":"dlinfo","keywords":"","body":"dlinfo dlinfo 概述：Linux系统中，ELF相关函数，用于获取动态链接库的信息 所属头文件: dlfcn.h 相关头文件: link.h 定义int dlinfo(void *restrict handle, int request, void *restrict info); 实现 glibc/dlfcn/dlinfo.c at master · lattera/glibc man page Linux dlinfo(3) - Linux manual page dlinfo(3) Library Functions Manual dlinfo(3) NAME top dlinfo - obtain information about a dynamically loaded object LIBRARY top Dynamic linking library (libdl, -ldl) SYNOPSIS top #define _GNU_SOURCE #include #include int dlinfo(void *restrict handle, int request, void *restrict info); DESCRIPTION top The dlinfo() function obtains information about the dynamically loaded object referred to by handle (typically obtained by an earlier call to dlopen(3) or dlmopen(3)). The request argument specifies which information is to be returned. The info argument is a pointer to a buffer used to store information returned by the call; the type of this argument depends on request. The following values are supported for request (with the corresponding type for info shown in parentheses): RTLD_DI_LMID (Lmid_t *) Obtain the ID of the link-map list (namespace) in which handle is loaded. RTLD_DI_LINKMAP (struct link_map **) Obtain a pointer to the link_map structure corresponding to handle. The info argument points to a pointer to a link_map structure, defined in as: struct link_map { ElfW(Addr) l_addr; /* Difference between the address in the ELF file and the address in memory */ char *l_name; /* Absolute pathname where object was found */ ElfW(Dyn) *l_ld; /* Dynamic section of the shared object */ struct link_map *l_next, *l_prev; /* Chain of loaded objects */ /* Plus additional fields private to the implementation */ }; RTLD_DI_ORIGIN (char *) Copy the pathname of the origin of the shared object corresponding to handle to the location pointed to by info. RTLD_DI_SERINFO (Dl_serinfo *) Obtain the library search paths for the shared object referred to by handle. The info argument is a pointer to a Dl_serinfo that contains the search paths. Because the number of search paths may vary, the size of the structure pointed to by info can vary. The RTLD_DI_SERINFOSIZE request described below allows applications to size the buffer suitably. The caller must perform the following steps: (1) Use a RTLD_DI_SERINFOSIZE request to populate a Dl_serinfo structure with the size (dls_size) of the structure needed for the subsequent RTLD_DI_SERINFO request. (2) Allocate a Dl_serinfo buffer of the correct size (dls_size). (3) Use a further RTLD_DI_SERINFOSIZE request to populate the dls_size and dls_cnt fields of the buffer allocated in the previous step. (4) Use a RTLD_DI_SERINFO to obtain the library search paths. The Dl_serinfo structure is defined as follows: typedef struct { size_t dls_size; /* Size in bytes of the whole buffer */ unsigned int dls_cnt; /* Number of elements in 'dls_serpath' */ Dl_serpath dls_serpath[1]; /* Actually longer, 'dls_cnt' elements */ } Dl_serinfo; Each of the dls_serpath elements in the above structure is a structure of the following form: typedef struct { char *dls_name; /* Name of library search path directory */ unsigned int dls_flags; /* Indicates where this directory came from */ } Dl_serpath; The dls_flags field is currently unused, and always contains zero. RTLD_DI_SERINFOSIZE (Dl_serinfo *) Populate the dls_size and dls_cnt fields of the Dl_serinfo structure pointed to by info with values suitable for allocating a buffer for use in a subsequent RTLD_DI_SERINFO request. RTLD_DI_TLS_MODID (size_t *, since glibc 2.4) Obtain the module ID of this shared object's TLS (thread- local storage) segment, as used in TLS relocations. If this object does not define a TLS segment, zero is placed in *info. RTLD_DI_TLS_DATA (void **, since glibc 2.4) Obtain a pointer to the calling thread's TLS block corresponding to this shared object's TLS segment. If this object does not define a PT_TLS segment, or if the calling thread has not allocated a block for it, NULL is placed in *info. RETURN VALUE top On success, dlinfo() returns 0. On failure, it returns -1; the cause of the error can be diagnosed using dlerror(3). ATTRIBUTES top For an explanation of the terms used in this section, see attributes(7). ┌─────────────────────────────────────┬───────────────┬─────────┐ │ Interface │ Attribute │ Value │ ├─────────────────────────────────────┼───────────────┼─────────┤ │ dlinfo() │ Thread safety │ MT-Safe │ └─────────────────────────────────────┴───────────────┴─────────┘ VERSIONS top The sets of requests supported by the various implementations overlaps only partially. STANDARDS top GNU. HISTORY top glibc 2.3.3. Solaris. EXAMPLES top The program below opens a shared objects using dlopen(3) and then uses the RTLD_DI_SERINFOSIZE and RTLD_DI_SERINFO requests to obtain the library search path list for the library. Here is an example of what we might see when running the program: $ ./a.out /lib64/libm.so.6 dls_serpath[0].dls_name = /lib64 dls_serpath[1].dls_name = /usr/lib64 Program source #define _GNU_SOURCE #include #include #include #include int main(int argc, char *argv[]) { void *handle; Dl_serinfo serinfo; Dl_serinfo *sip; if (argc != 2) { fprintf(stderr, \"Usage: %s \\n\", argv[0]); exit(EXIT_FAILURE); } /* Obtain a handle for shared object specified on command line. */ handle = dlopen(argv[1], RTLD_NOW); if (handle == NULL) { fprintf(stderr, \"dlopen() failed: %s\\n\", dlerror()); exit(EXIT_FAILURE); } /* Discover the size of the buffer that we must pass to RTLD_DI_SERINFO. */ if (dlinfo(handle, RTLD_DI_SERINFOSIZE, &serinfo) == -1) { fprintf(stderr, \"RTLD_DI_SERINFOSIZE failed: %s\\n\", dlerror()); exit(EXIT_FAILURE); } /* Allocate the buffer for use with RTLD_DI_SERINFO. */ sip = malloc(serinfo.dls_size); if (sip == NULL) { perror(\"malloc\"); exit(EXIT_FAILURE); } /* Initialize the 'dls_size' and 'dls_cnt' fields in the newly allocated buffer. */ if (dlinfo(handle, RTLD_DI_SERINFOSIZE, sip) == -1) { fprintf(stderr, \"RTLD_DI_SERINFOSIZE failed: %s\\n\", dlerror()); exit(EXIT_FAILURE); } /* Fetch and print library search list. */ if (dlinfo(handle, RTLD_DI_SERINFO, sip) == -1) { fprintf(stderr, \"RTLD_DI_SERINFO failed: %s\\n\", dlerror()); exit(EXIT_FAILURE); } for (size_t j = 0; j dls_serpath[j].dls_name); exit(EXIT_SUCCESS); } SEE ALSO top dl_iterate_phdr(3), dladdr(3), dlerror(3), dlopen(3), dlsym(3), ld.so(8) COLOPHON top This page is part of the man-pages (Linux kernel and C library user-space interface documentation) project. Information about the project can be found at ⟨https://www.kernel.org/doc/man-pages/⟩. If you have a bug report for this manual page, see ⟨https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING⟩. This page was obtained from the tarball man-pages-6.9.1.tar.gz fetched from ⟨https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/⟩ on 2024-06-26. If you discover any rendering problems in this HTML version of the page, or you believe there is a better or more up- to-date source for the page, or you have corrections or improvements to the information in this COLOPHON (which is not part of the original manual page), send a mail to man-pages@man7.org Linux man-pages 6.9.1 2024-06-15 dlinfo(3) FreeBSD dlinfo(3) DLINFO(3) Library Functions Manual DLINFO(3) NAME dlinfo -- information about dynamically loaded object LIBRARY Standard C Library (libc, -lc) SYNOPSIS #include #include int dlinfo(void * restrict handle, int request, void * restrict p); DESCRIPTION The dlinfo() function provides information about dynamically loaded ob- ject. The action taken by dlinfo() and exact meaning and type of p ar- gument depend on value of the request argument provided by caller. The handle argument is either the value returned from the dlopen(3) function call or special handle RTLD_SELF. If handle is the value re- turned from dlopen(3), the information returned by the dlinfo() func- tion pertains to the specified object. If handle is the special handle RTLD_SELF, the information returned pertains to the caller itself. Possible values for the request argument are: RTLD_DI_LINKMAP Retrieve the Link_map (struct link_map) structure pointer for the specified handle. On successful return, the p argument is filled with the pointer to the Link_map structure (Link_map **p) describing a shared object specified by the handle argu- ment. The Link_map structures are maintained as a doubly linked list by ld.so(1), in the same order as dlopen(3) and dlclose(3) are called. See \"EXAMPLES\", example 1. The Link_map structure is defined in and has the fol- lowing members: caddr_t l_addr; /* Base Address of library */ const char *l_name; /* Absolute Path to Library */ const void *l_ld; /* Pointer to .dynamic in memory */ struct link_map *l_next, /* linked list of mapped libs */ *l_prev; l_addr The base address of the object loaded into memory. l_name The full name of the loaded shared object. l_ld The address of the dynamic linking information segment (PT_DYNAMIC) loaded into memory. l_next The next Link_map structure on the link-map list. l_prev The previous Link_map structure on the link-map list. RTLD_DI_SERINFO Retrieve the library search paths associated with the given handle argument. The p argument should point to Dl_serinfo structure buffer (Dl_serinfo *p). The Dl_serinfo structure must be initialized first with the RTLD_DI_SERINFOSIZE request. The returned Dl_serinfo structure contains dls_cnt Dl_serpath entries. Each entry's dlp_name field points to the search path. The corresponding dlp_info field contains one of more flags indicating the origin of the path (see the LA_SER_* flags defined in the header file). See \"EXAMPLES\", example 2, for a usage example. RTLD_DI_SERINFOSIZE Initialize a Dl_serinfo structure for use in a RTLD_DI_SERINFO request. Both the dls_cnt and dls_size fields are returned to indicate the number of search paths applicable to the handle, and the total size of a Dl_serinfo buffer required to hold dls_cnt Dl_serpath entries and the associated search path strings. See \"EXAMPLES\", example 2, for a usage example. RTLD_DI_ORIGIN Retrieve the origin of the dynamic object associated with the handle. On successful return, p argument is filled with the char pointer (char *p). RETURN VALUES The dlinfo() function returns 0 on success, or -1 if an error occurred. Whenever an error has been detected, a message detailing it can be re- trieved via a call to dlerror(3). EXAMPLES Example 1: Using dlinfo() to retrieve Link_map structure. The following example shows how dynamic library can detect the list of shared libraries loaded after caller's one. For simplicity, error checking has been omitted. Link_map *map; dlinfo(RTLD_SELF, RTLD_DI_LINKMAP, &map); while (map != NULL) { printf(\"%p: %s\\n\", map->l_addr, map->l_name); map = map->l_next; } Example 2: Using dlinfo() to retrieve the library search paths. The following example shows how a dynamic object can inspect the li- brary search paths that would be used to locate a simple filename with dlopen(3). For simplicity, error checking has been omitted. Dl_serinfo _info, *info = &_info; Dl_serpath *path; unsigned int cnt; /* determine search path count and required buffer size */ dlinfo(RTLD_SELF, RTLD_DI_SERINFOSIZE, (void *)info); /* allocate new buffer and initialize */ info = malloc(_info.dls_size); info->dls_size = _info.dls_size; info->dls_cnt = _info.dls_cnt; /* obtain sarch path information */ dlinfo(RTLD_SELF, RTLD_DI_SERINFO, (void *)info); path = &info->dls_serpath[0]; for (cnt = 1; cnt dls_cnt; cnt++, path++) { (void) printf(\"%2d: %s\\n\", cnt, path->dls_name); } SEE ALSO rtld(1), dladdr(3), dlopen(3), dlsym(3) HISTORY The dlinfo() function first appeared in the Solaris operating system. In FreeBSD, it first appeared in FreeBSD 4.8. AUTHORS The FreeBSD implementation of the dlinfo() function was originally written by Alexey Zelkin and later extended and improved by Alexander Kabaev . The manual page for this function was written by Alexey Zelkin . FreeBSD 13.2 February 14, 2003 DLINFO(3) crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-15 09:38:47 "},"dyld/func/dyld_api/dlfcn_h/dlopen.html":{"url":"dyld/func/dyld_api/dlfcn_h/dlopen.html","title":"dlopen","keywords":"","body":"dlopen 所属头文件: dlfcn.h 语法定义void* dlopen(const char* path, int mode); man page DLOPEN(3) BSD Library Functions Manual DLOPEN(3) NAME dlopen -- load and link a dynamic library or bundle SYNOPSIS #include void* dlopen(const char* path, int mode); DESCRIPTION dlopen() examines the mach-o file specified by path. If the file is com-patible compatible patible with the current process and has not already been loaded into the current process, it is loaded and linked. After being linked, if it con-tains contains tains any initializer functions, they are called, before dlopen() returns. dlopen() can load dynamic libraries and bundles. It returns a handle that can be used with dlsym() and dlclose(). A second call to dlopen() with the same path will return the same handle, but the internal reference count for the handle will be incremented. Therefore all dlopen() calls should be balanced with a dlclose() call. If a null pointer is passed in path, dlopen() returns a handle equivalent to RTLD_DEFAULT. mode contains options to dlopen(). It must contain one or more of the following values, possibly ORed together: RTLD_LAZY Each external function reference is bound the first time the function is called. RTLD_NOW All external function references are bound immediately during the call to dlopen(). RTLD_LAZY is normally preferred, for reasons of efficiency. However, RTLD_NOW is useful to ensure that any undefined symbols are discovered during the call to dlopen(). If neither RTLD_LAZY nor RTLD_NOW is speci-fied, specified, fied, the default is RTLD_LAZY. One of the following flags may be ORed into the mode argument: RTLD_GLOBAL Symbols exported from this image (dynamic library or bundle) will be available to any images build with -flat_namespace option to ld(1) or to calls to dlsym() when using a special handle. RTLD_LOCAL Symbols exported from this image (dynamic library or bundle) are generally hidden and only availble to dlsym() when directly using the handle returned by this call to dlopen(). If neither RTLD_GLOBAL nor RTLD_LOCAL is specified, the default is RTLD_GLOBAL. One of the following may be ORed into the mode argument: RTLD_NOLOAD The specified image is not loaded. However, a valid handle is returned if the image already exists in the process. This provides a way to query if an image is already loaded. The handle returned is ref-counted, so you eventually need a corresponding call to dlclose() RTLD_NODELETE The specified image is tagged so that will never be removed from the address space, even after all clients have released it via dlclose() Additionally, the following may be ORed into the mode argument: RTLD_FIRST The retuned handle is tagged so that any dlsym() calls on the handle will only search the image specified, and not subsequent images. If path is NULL and the option RTLD_FIRST is used, the handle returned will only search the main executable. SEARCHING dlopen() searches for a compatible Mach-O file in the directories speci-fied specified fied by a set of environment variables and the process's current working directory. When set, the environment variables must contain a colon-sep-arated colon-separated arated list of directory paths, which can be absolute or relative to the current working directory. The environment variables are LD_LIBRARY_PATH, DYLD_LIBRARY_PATH, and DYLD_FALLBACK_LIBRARY_PATH. The first two vari-ables variables ables have no default value. The default value of DYLD_FALL-BACK_LIBRARY_PATH DYLD_FALLBACK_LIBRARY_PATH BACK_LIBRARY_PATH is $HOME/lib;/usr/local/lib;/usr/lib. dlopen() searches the directories specified in the environment variables in the order they are listed. When path doesn't contain a slash character (i.e. it is just a leaf name), dlopen() searches the following the following until it finds a compatible Mach-O file: $LD_LIBRARY_PATH, $DYLD_LIBRARY_PATH, current working directory, $DYLD_FALLBACK_LIBRARY_PATH. When path contains a slash (i.e. a full path or a partial path) dlopen() searches the following the following until it finds a compatible Mach-O file: $DYLD_LIBRARY_PATH (with leaf name from path ), current working directory (for partial paths), $DYLD_FALLBACK_LIBRARY_PATH (with leaf name from path ). Note: There are no configuration files to control dlopen searching. Note: If the main executable is a set[ug]id binary, then all environment variables are ignored, and only a full path can be used. Note: Mac OS X uses \"universal\" files to combine 32-bit and 64-bit libraries. This means there are no separate 32-bit and 64-bit search paths. RETURN VALUES If dlopen() fails, it returns a null pointer, and sets an error condition which may be interrogated with dlerror(). AUTHORS Mac OS X 10.3 incorporated the dlcompat package written by Jorge Acereda and Peter O'Gorman . In Mac OS X 10.4, dlopen was rewritten to be a native part of dyld. SEE ALSO dlopen_preflight(3) dlclose(3) dlsym(3) dlerror(3) dyld(3) ld(1) BSD Nov 6, 2006 BSD dlopen逆向调试 Xcode中反汇编代码 调试时相关内容： (lldb) p $arg1 (unsigned long) $4 = 4338636176 (lldb) p (SEL)$arg1 (SEL) $5 = \"/usr/lib/system/libdyld.dylib\" 后续多次触发时参数： (lldb) po (SEL)$arg1 \"/usr/lib/system/libdispatch.dylib\" (lldb) po (SEL)$arg1 \"/usr/lib/system/libdyld.dylib\" (lldb) po (SEL)$arg1 \"/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation\" (lldb) po (SEL)$arg1 \"/usr/lib/system/libsystem_c.dylib\" (lldb) po (SEL)$arg1 \"/usr/lib/system/libsystem_kernel.dylib\" (lldb) p (SEL)$arg1 (SEL) $1 = \"/usr/lib/system/libdyld.dylib\" (lldb) p (SEL)$arg1 (SEL) $2 = \"/usr/lib/system/libdispatch.dylib\" (lldb) p (SEL)$arg1 (SEL) $3 = \"/usr/lib/system/libdyld.dylib\" (lldb) p (SEL)$arg1 (SEL) $4 = \"/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation\" (lldb) p (SEL)$arg1 (SEL) $5 = \"/usr/lib/system/libsystem_c.dylib\" (lldb) p (SEL)$arg1 (SEL) $6 = \"/usr/lib/system/libsystem_kernel.dylib\" (lldb) po (SEL)$arg1 \"/System/Library/Frameworks/Foundation.framework/Foundation\" (lldb) po (SEL)$arg1 \"/usr/lib/libsubstitute.dylib\" (lldb) po (SEL)$arg1 \"/usr/lib/substitute-loader.dylib\" (lldb) po (SEL)$arg1 \"/usr/lib/system/libdyld.dylib\" (lldb) po (SEL)$arg1 \"/usr/lib/system/libdispatch.dylib\" 某次的函数调用堆栈： 反越狱检测 最新代码详见： crifan/iOSBypassJailbreak: 越狱iOS的hook插件，实现反越狱检测 hook_dylib.xm crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-12 15:45:15 "},"dyld/func/dyld_api/dlfcn_h/dlclose.html":{"url":"dyld/func/dyld_api/dlfcn_h/dlclose.html","title":"dlclose","keywords":"","body":"dlclose 所属头文件: dlfcn.h 语法定义int dlclose(void* handle); man page = help DLCLOSE(3) BSD Library Functions Manual DLCLOSE(3) NAME dlclose -- close a dynamic library or bundle SYNOPSIS #include int dlclose(void* handle); DESCRIPTION dlclose() releases a reference to the dynamic library or bundle refer-enced referenced enced by handle. If the reference count drops to 0, the bundle is removed from the address space, and handle is rendered invalid. Just before removing a dynamic library or bundle in this way, any termination routines in it are called. handle is the value returned by a previous call to dlopen. Prior to Mac OS X 10.5, only bundles could be unloaded. Starting in Mac OS X 10.5, dynamic libraries may also be unloaded. There are a couple of cases in which a dynamic library will never be unloaded: 1) the main exe-cutable executable cutable links against it, 2) An API that does not supoort unloading (e.g. NSAddImage()) was used to load it or some other dynnamic library that depends on it, 3) the dynamic library is in dyld's shared cache. RETURN VALUES If dlclose() is successful, it returns a value of 0. Otherwise it returns -1, and sets an error string that can be retrived with dlerror(). SEE ALSO dlopen(3) dlsym(3) dlerror(3) dyld(3) ld(1) cc(1) Nov 6, 2006 反越狱检测 最新代码详见： crifan/iOSBypassJailbreak: 越狱iOS的hook插件，实现反越狱检测 hook_dylib.xm crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-12 09:56:33 "},"dyld/func/dyld_api/dlfcn_h/dlopen_preflight.html":{"url":"dyld/func/dyld_api/dlfcn_h/dlopen_preflight.html","title":"dlopen_preflight","keywords":"","body":"dlopen_preflight 所属头文件: dlfcn.h 语法定义bool dlopen_preflight(const char* path); 详细定义 Mac中：usr/include/dlfcn.h#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE) extern bool dlopen_preflight(const char* __path) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0) __DYLDDL_DRIVERKIT_UNAVAILABLE; #endif /* not POSIX */ 图 man page DLOPEN_PREFLIGHT(3) BSD Library Functions Manual DLOPEN_PREFLIGHT(3) NAME dlopen_preflight -- preflight the load of a dynamic library or bundle SYNOPSIS #include bool dlopen_preflight(const char* path); DESCRIPTION dlopen_preflight() examines the mach-o file specified by path. It checks if the file and libraries it depends on are all compatible with the cur-rent current rent process. That is, they contain the correct architecture and are not otherwise ABI incompatible. dlopen_preflight() was first available in Mac OS X 10.5. SEARCHING dlopen_preflight() uses the same steps as dlopen() to find a compatible mach-o file. RETURN VALUES dlopen_preflight() returns true on if the mach-o file is compatible. If the file is not compatible, it returns false and sets an error string that can be examined with dlerror(). SEE ALSO dlopen(3) dlerror(3) BSD April 17, 2006 BSD hook代码 Frida Interceptor.attach(Module.findExportByName(null, \"dlopen_preflight\"), { onEnter: function(args) { if (args[0].isNull()) return; var path = args[0].readUtf8String(); if (!iswhite(path)) console.log(\"dlopen_preflight \" + path); } }) iOSOpenDev bool dlopen_preflight(const char* path); %hookf(bool, dlopen_preflight, const char* path){ bool isPreLoadOk = %orig; iosLogInfo(\"path=%{public}s -> isPreLoadOk=%s\", path, boolToStr(isPreLoadOk)); return isPreLoadOk; } 有log，但都是系统库，没有任何越狱库： 默认 15:05:11.453380+0800 Aweme hook_dylib.xm dlopen_preflight: path=/System/Library/Frameworks/CFNetwork.framework/CFNetwork -> isPreLoadOk=True 默认 15:05:19.144160+0800 Aweme hook_dylib.xm dlopen_preflight: path=/System/Library/Frameworks/AudioToolbox.framework/AudioToolbox -> isPreLoadOk=True 默认 15:05:19.415606+0800 Aweme hook_dylib.xm dlopen_preflight: path=/System/Library/Extensions/IOHIDFamily.kext/PlugIns/IOHIDLib.plugin/IOHIDLib -> isPreLoadOk=True C Swizzler/C_function_hooks_section3.xm at master · vtky/Swizzler (github.com) /* dlopen_preflight dlopen_preflight() examines the mach-o file specified by path. It checks if the file and libraries it depends on are all compatible with the current process. That is, they contain the correct architecture and are not otherwise ABI incompatible. bool dlopen_preflight(const char* path); */ bool (*orig_dlopen_preflight) (const char* path); bool replaced_dlopen_preflight (const char* path) { DDLogVerbose(@\"dlopen_preflight: %s\", path); if (disableJBDectection()) { return 0; } bool ret = orig_dlopen_preflight(path); return ret; } ... void C_function_hooks_section3() { ... // dl InstallHook(dlopen_preflight); ... 涉及到的地方 YouTube dyld: in dlopen_preflight() *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[__NSDictionaryM userInfo]: unrecognized selector sent to instance 0x280da9760' terminating with uncaught exception of type NSException crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-14 10:33:05 "},"dyld/func/dyld_api/dyld_h/":{"url":"dyld/func/dyld_api/dyld_h/","title":"dyld.h","keywords":"","body":"dyld.h 相关 dyld3/APIs.h的内容 dyld3/APIs.h /* * Copyright (c) 2017 Apple Inc. All rights reserved. * * @APPLE_LICENSE_HEADER_START@ * * This file contains Original Code and/or Modifications of Original Code * as defined in and that are subject to the Apple Public Source License * Version 2.0 (the 'License'). You may not use this file except in * compliance with the License. Please obtain a copy of the License at * http://www.opensource.apple.com/apsl/ and read it before using this * file. * * The Original Code and all software distributed under the License are * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES, * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. * Please see the License for the specific language governing rights and * limitations under the License. * * @APPLE_LICENSE_HEADER_END@ */ #ifndef __DYLD_APIS_H__ #define __DYLD_APIS_H__ #include #include #include #include #include #include \"dlfcn.h\" #define TEMP_HIDDEN __attribute__((visibility(\"hidden\"))) // // The implementation of all dyld load/unload API's must hold a global lock // so that the next load/unload does start until the current is complete. // This lock is recursive so that initializers can call dlopen(). // This is done using the macros DYLD_LOCK_THIS_BLOCK. // Example: // // void dyld_load_api() { // DYLD_LOAD_LOCK_THIS_BLOCK; // // free to do stuff here // // that accesses dyld internal data structures // } // // #define DYLD_LOAD_LOCK_THIS_BLOCK RecursiveAutoLock _dyld_load_lock; namespace dyld3 { class __attribute__((visibility(\"hidden\"))) RecursiveAutoLock { public: RecursiveAutoLock() { pthread_mutex_lock(&_sMutex); } ~RecursiveAutoLock() { pthread_mutex_unlock(&_sMutex); } private: static pthread_mutex_t _sMutex; }; uint32_t _dyld_image_count() TEMP_HIDDEN; const mach_header* _dyld_get_image_header(uint32_t imageIndex) TEMP_HIDDEN; intptr_t _dyld_get_image_slide(const mach_header* mh) TEMP_HIDDEN; intptr_t _dyld_get_image_vmaddr_slide(uint32_t imageIndex) TEMP_HIDDEN; const char* _dyld_get_image_name(uint32_t imageIndex) TEMP_HIDDEN; const struct mach_header * _dyld_get_prog_image_header() TEMP_HIDDEN; int32_t NSVersionOfLinkTimeLibrary(const char* libraryName) TEMP_HIDDEN; int32_t NSVersionOfRunTimeLibrary(const char* libraryName) TEMP_HIDDEN; uint32_t dyld_get_program_sdk_watch_os_version() TEMP_HIDDEN; uint32_t dyld_get_program_min_watch_os_version() TEMP_HIDDEN; uint32_t dyld_get_program_sdk_bridge_os_version() TEMP_HIDDEN; uint32_t dyld_get_program_min_bridge_os_version() TEMP_HIDDEN; uint32_t dyld_get_sdk_version(const mach_header* mh) TEMP_HIDDEN; uint32_t dyld_get_program_sdk_version() TEMP_HIDDEN; uint32_t dyld_get_min_os_version(const mach_header* mh) TEMP_HIDDEN; uint32_t dyld_get_program_min_os_version() TEMP_HIDDEN; dyld_platform_t dyld_get_active_platform(void) TEMP_HIDDEN; dyld_platform_t dyld_get_base_platform(dyld_platform_t platform) TEMP_HIDDEN; bool dyld_is_simulator_platform(dyld_platform_t platform) TEMP_HIDDEN; bool dyld_sdk_at_least(const struct mach_header* mh, dyld_build_version_t version) TEMP_HIDDEN; bool dyld_minos_at_least(const struct mach_header* mh, dyld_build_version_t version) TEMP_HIDDEN; bool dyld_program_sdk_at_least(dyld_build_version_t version) TEMP_HIDDEN; bool dyld_program_minos_at_least(dyld_build_version_t version) TEMP_HIDDEN; void dyld_get_image_versions(const struct mach_header* mh, void (^callback)(dyld_platform_t platform, uint32_t sdk_version, uint32_t min_version)) TEMP_HIDDEN; bool _dyld_get_image_uuid(const mach_header* mh, uuid_t uuid) TEMP_HIDDEN; int _NSGetExecutablePath(char* buf, uint32_t* bufsize) TEMP_HIDDEN; void _dyld_register_func_for_add_image(void (*func)(const mach_header *mh, intptr_t vmaddr_slide)) TEMP_HIDDEN; void _dyld_register_func_for_remove_image(void (*func)(const mach_header *mh, intptr_t vmaddr_slide)) TEMP_HIDDEN; void _dyld_objc_notify_register(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped) TEMP_HIDDEN; const mach_header* dyld_image_header_containing_address(const void* addr) TEMP_HIDDEN; const mach_header* _dyld_get_image_header_containing_address(const void* address) TEMP_HIDDEN; bool _dyld_image_containing_address(const void* address) TEMP_HIDDEN; const char* dyld_image_path_containing_address(const void* addr) TEMP_HIDDEN; bool _dyld_is_memory_immutable(const void* addr, size_t length) TEMP_HIDDEN; int dladdr(const void* addr, Dl_info* info) TEMP_HIDDEN; char* dlerror() TEMP_HIDDEN; int dlclose(void* handle) TEMP_HIDDEN; void* dlopen_internal(const char* path, int mode, void* callerAddress) TEMP_HIDDEN; bool dlopen_preflight_internal(const char* path) TEMP_HIDDEN; void* dlsym_internal(void* handle, const char* symbolName, void* callerAddress) TEMP_HIDDEN; const struct dyld_all_image_infos* _dyld_get_all_image_infos() TEMP_HIDDEN; bool dyld_shared_cache_some_image_overridden() TEMP_HIDDEN; bool _dyld_get_shared_cache_uuid(uuid_t uuid) TEMP_HIDDEN; const void* _dyld_get_shared_cache_range(size_t* length) TEMP_HIDDEN; bool _dyld_shared_cache_optimized() TEMP_HIDDEN; bool _dyld_shared_cache_is_locally_built() TEMP_HIDDEN; uint32_t _dyld_launch_mode() TEMP_HIDDEN; bool dyld_need_closure(const char* execPath, const char* dataContainerRootDir) TEMP_HIDDEN; void _dyld_images_for_addresses(unsigned count, const void* addresses[], struct dyld_image_uuid_offset infos[]) TEMP_HIDDEN; void _dyld_register_for_image_loads(void (*func)(const mach_header* mh, const char* path, bool unloadable)) TEMP_HIDDEN; void _dyld_register_for_bulk_image_loads(void (*func)(unsigned imageCount, const struct mach_header* mhs[], const char* paths[])) TEMP_HIDDEN; bool _dyld_find_unwind_sections(void* addr, dyld_unwind_sections* info) TEMP_HIDDEN; bool dyld_process_is_restricted() TEMP_HIDDEN; const char* dyld_shared_cache_file_path() TEMP_HIDDEN; bool dyld_has_inserted_or_interposing_libraries() TEMP_HIDDEN; void dyld_dynamic_interpose(const mach_header* mh, const dyld_interpose_tuple array[], size_t count) TEMP_HIDDEN; int dyld_shared_cache_find_iterate_text(const uuid_t cacheUuid, const char* extraSearchDirs[], void (^callback)(const dyld_shared_cache_dylib_text_info* info)) TEMP_HIDDEN; int dyld_shared_cache_iterate_text(const uuid_t cacheUuid, void (^callback)(const dyld_shared_cache_dylib_text_info* info)) TEMP_HIDDEN; void _dyld_atfork_prepare() TEMP_HIDDEN; void _dyld_atfork_parent() TEMP_HIDDEN; void _dyld_fork_child() TEMP_HIDDEN; void _dyld_missing_symbol_abort() TEMP_HIDDEN; const char* _dyld_get_objc_selector(const char* selName) TEMP_HIDDEN; void _dyld_for_each_objc_class(const char* className, void (^callback)(void* classPtr, bool isLoaded, bool* stop)) TEMP_HIDDEN; void _dyld_for_each_objc_protocol(const char* protocolName, void (^callback)(void* protocolPtr, bool isLoaded, bool* stop)) TEMP_HIDDEN; void _dyld_register_driverkit_main(void (*mainFunc)())TEMP_HIDDEN; // only in macOS and deprecated #if TARGET_OS_OSX NSObjectFileImageReturnCode NSCreateObjectFileImageFromFile(const char* pathName, NSObjectFileImage *objectFileImage) TEMP_HIDDEN; NSObjectFileImageReturnCode NSCreateObjectFileImageFromMemory(const void *address, size_t size, NSObjectFileImage *objectFileImage) TEMP_HIDDEN; bool NSDestroyObjectFileImage(NSObjectFileImage objectFileImage) TEMP_HIDDEN; uint32_t NSSymbolDefinitionCountInObjectFileImage(NSObjectFileImage objectFileImage) TEMP_HIDDEN; const char* NSSymbolDefinitionNameInObjectFileImage(NSObjectFileImage objectFileImage, uint32_t ordinal) TEMP_HIDDEN; uint32_t NSSymbolReferenceCountInObjectFileImage(NSObjectFileImage objectFileImage) TEMP_HIDDEN; const char* NSSymbolReferenceNameInObjectFileImage(NSObjectFileImage objectFileImage, uint32_t ordinal, bool *tentative_definition) TEMP_HIDDEN; bool NSIsSymbolDefinedInObjectFileImage(NSObjectFileImage objectFileImage, const char* symbolName) TEMP_HIDDEN; void* NSGetSectionDataInObjectFileImage(NSObjectFileImage objectFileImage, const char* segmentName, const char* sectionName, size_t *size) TEMP_HIDDEN; const char* NSNameOfModule(NSModule m) TEMP_HIDDEN; const char* NSLibraryNameForModule(NSModule m) TEMP_HIDDEN; NSModule NSLinkModule(NSObjectFileImage objectFileImage, const char* moduleName, uint32_t options) TEMP_HIDDEN; bool NSUnLinkModule(NSModule module, uint32_t options) TEMP_HIDDEN; bool NSIsSymbolNameDefined(const char* symbolName) TEMP_HIDDEN; bool NSIsSymbolNameDefinedWithHint(const char* symbolName, const char* libraryNameHint) TEMP_HIDDEN; bool NSIsSymbolNameDefinedInImage(const struct mach_header* image, const char* symbolName) TEMP_HIDDEN; NSSymbol NSLookupAndBindSymbol(const char* symbolName) TEMP_HIDDEN; NSSymbol NSLookupAndBindSymbolWithHint(const char* symbolName, const char* libraryNameHint) TEMP_HIDDEN; NSSymbol NSLookupSymbolInModule(NSModule module, const char* symbolName) TEMP_HIDDEN; NSSymbol NSLookupSymbolInImage(const struct mach_header* image, const char* symbolName, uint32_t options) TEMP_HIDDEN; const char* NSNameOfSymbol(NSSymbol symbol) TEMP_HIDDEN; void* NSAddressOfSymbol(NSSymbol symbol) TEMP_HIDDEN; NSModule NSModuleForSymbol(NSSymbol symbol) TEMP_HIDDEN; void NSLinkEditError(NSLinkEditErrors *c, int *errorNumber, const char** fileName, const char** errorString) TEMP_HIDDEN; bool NSAddLibrary(const char* pathName) TEMP_HIDDEN; bool NSAddLibraryWithSearching(const char* pathName) TEMP_HIDDEN; const struct mach_header* NSAddImage(const char* image_name, uint32_t options) TEMP_HIDDEN; void NSInstallLinkEditErrorHandlers(const NSLinkEditErrorHandlers *handlers) TEMP_HIDDEN; bool _dyld_present(void) TEMP_HIDDEN; bool _dyld_launched_prebound(void) TEMP_HIDDEN; bool _dyld_all_twolevel_modules_prebound(void) TEMP_HIDDEN; bool _dyld_bind_fully_image_containing_address(const void* address) TEMP_HIDDEN; bool _dyld_image_containing_address(const void* address) TEMP_HIDDEN; void _dyld_lookup_and_bind(const char* symbol_name, void **address, NSModule* module) TEMP_HIDDEN; void _dyld_lookup_and_bind_with_hint(const char* symbol_name, const char* library_name_hint, void** address, NSModule* module) TEMP_HIDDEN; void _dyld_lookup_and_bind_fully(const char* symbol_name, void** address, NSModule* module) TEMP_HIDDEN; const struct mach_header* _dyld_get_image_header_containing_address(const void* address) TEMP_HIDDEN; #endif } // namespace dyld3 #endif // __DYLD_APIS_H__ mach-o/dyld.h头文件内容 dyld的mach-o/dyld.h dyld mach-o/dyld.h /* * Copyright (c) 1999-2008 Apple Inc. All rights reserved. * * @APPLE_LICENSE_HEADER_START@ * * This file contains Original Code and/or Modifications of Original Code * as defined in and that are subject to the Apple Public Source License * Version 2.0 (the 'License'). You may not use this file except in * compliance with the License. Please obtain a copy of the License at * http://www.opensource.apple.com/apsl/ and read it before using this * file. * * The Original Code and all software distributed under the License are * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES, * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. * Please see the License for the specific language governing rights and * limitations under the License. * * @APPLE_LICENSE_HEADER_END@ */ #ifndef _MACH_O_DYLD_H_ #define _MACH_O_DYLD_H_ #include #include #include #include #include #if __cplusplus extern \"C\" { #endif #ifdef __DRIVERKIT_19_0 #define DYLD_DRIVERKIT_UNAVAILABLE __API_UNAVAILABLE(driverkit) #else #define DYLD_DRIVERKIT_UNAVAILABLE #endif /* * The following functions allow you to iterate through all loaded images. * This is not a thread safe operation. Another thread can add or remove * an image during the iteration. * * Many uses of these routines can be replace by a call to dladdr() which * will return the mach_header and name of an image, given an address in * the image. dladdr() is thread safe. */ extern uint32_t _dyld_image_count(void) __OSX_AVAILABLE_STARTING(__MAC_10_1, __IPHONE_2_0); extern const struct mach_header* _dyld_get_image_header(uint32_t image_index) __OSX_AVAILABLE_STARTING(__MAC_10_1, __IPHONE_2_0); extern intptr_t _dyld_get_image_vmaddr_slide(uint32_t image_index) __OSX_AVAILABLE_STARTING(__MAC_10_1, __IPHONE_2_0); extern const char* _dyld_get_image_name(uint32_t image_index) __OSX_AVAILABLE_STARTING(__MAC_10_1, __IPHONE_2_0); /* * The following functions allow you to install callbacks which will be called * by dyld whenever an image is loaded or unloaded. During a call to _dyld_register_func_for_add_image() * the callback func is called for every existing image. Later, it is called as each new image * is loaded and bound (but initializers not yet run). The callback registered with * _dyld_register_func_for_remove_image() is called after any terminators in an image are run * and before the image is un-memory-mapped. */ extern void _dyld_register_func_for_add_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)) __OSX_AVAILABLE_STARTING(__MAC_10_1, __IPHONE_2_0); extern void _dyld_register_func_for_remove_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)) __OSX_AVAILABLE_STARTING(__MAC_10_1, __IPHONE_2_0); /* * NSVersionOfRunTimeLibrary() returns the current_version number of the currently dylib * specifed by the libraryName. The libraryName parameter would be \"bar\" for /path/libbar.3.dylib and * \"Foo\" for /path/Foo.framework/Versions/A/Foo. It returns -1 if no such library is loaded. */ extern int32_t NSVersionOfRunTimeLibrary(const char* libraryName) __OSX_AVAILABLE_STARTING(__MAC_10_1, __IPHONE_2_0); /* * NSVersionOfLinkTimeLibrary() returns the current_version number that the main executable was linked * against at build time. The libraryName parameter would be \"bar\" for /path/libbar.3.dylib and * \"Foo\" for /path/Foo.framework/Versions/A/Foo. It returns -1 if the main executable did not link * against the specified library. */ extern int32_t NSVersionOfLinkTimeLibrary(const char* libraryName) __OSX_AVAILABLE_STARTING(__MAC_10_1, __IPHONE_2_0); /* * _NSGetExecutablePath() copies the path of the main executable into the buffer. The bufsize parameter * should initially be the size of the buffer. The function returns 0 if the path was successfully copied, * and *bufsize is left unchanged. It returns -1 if the buffer is not large enough, and *bufsize is set * to the size required. * * Note that _NSGetExecutablePath will return \"a path\" to the executable not a \"real path\" to the executable. * That is the path may be a symbolic link and not the real file. With deep directories the total bufsize * needed could be more than MAXPATHLEN. */ extern int _NSGetExecutablePath(char* buf, uint32_t* bufsize) __OSX_AVAILABLE_STARTING(__MAC_10_2, __IPHONE_2_0); /* * Registers a function to be called when the current thread terminates. * Called by c++ compiler to implement destructors on thread_local object variables. */ extern void _tlv_atexit(void (*termFunc)(void* objAddr), void* objAddr) __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_8_0); /* * Never called. On-disk thread local variables contain a pointer to this. Once * the thread local is prepared, the pointer changes to a real handler such as tlv_get_addr. */ extern void _tlv_bootstrap(void) __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_8_0) DYLD_DRIVERKIT_UNAVAILABLE ; /* * Dylibs that are incorporated into the dyld cache are removed from disk. That means code * cannot stat() the file to see if it \"exists\". This function is like a stat() call that checks if a * path is to a dylib that was removed from disk and is incorporated into the active dyld cache. */ extern bool _dyld_shared_cache_contains_path(const char* path) __API_AVAILABLE(macos(11.0), ios(14.0), watchos(7.0), tvos(14.0), bridgeos(5.0)) DYLD_DRIVERKIT_UNAVAILABLE; /* * The following dyld API's are deprecated as of Mac OS X 10.5. They are either * no longer necessary or are superceeded by dlopen and friends in . * dlopen/dlsym/dlclose have been available since Mac OS X 10.3 and work with * dylibs and bundles. * * NSAddImage -> dlopen * NSLookupSymbolInImage -> dlsym * NSCreateObjectFileImageFromFile -> dlopen * NSDestroyObjectFileImage -> dlclose * NSLinkModule -> not needed when dlopen used * NSUnLinkModule -> not needed when dlclose used * NSLookupSymbolInModule -> dlsym * _dyld_image_containing_address -> dladdr * NSLinkEditError -> dlerror * */ #ifndef ENUM_DYLD_BOOL #define ENUM_DYLD_BOOL #undef FALSE #undef TRUE enum DYLD_BOOL { FALSE, TRUE }; #endif /* ENUM_DYLD_BOOL */ /* Object file image API */ typedef enum { NSObjectFileImageFailure, /* for this a message is printed on stderr */ NSObjectFileImageSuccess, NSObjectFileImageInappropriateFile, NSObjectFileImageArch, NSObjectFileImageFormat, /* for this a message is printed on stderr */ NSObjectFileImageAccess } NSObjectFileImageReturnCode; typedef struct __NSObjectFileImage* NSObjectFileImage; /* NSObjectFileImage can only be used with MH_BUNDLE files */ extern NSObjectFileImageReturnCode NSCreateObjectFileImageFromFile(const char* pathName, NSObjectFileImage *objectFileImage) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"dlopen()\"); extern NSObjectFileImageReturnCode NSCreateObjectFileImageFromMemory(const void *address, size_t size, NSObjectFileImage *objectFileImage) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"\"); extern bool NSDestroyObjectFileImage(NSObjectFileImage objectFileImage) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"dlclose()\"); extern uint32_t NSSymbolDefinitionCountInObjectFileImage(NSObjectFileImage objectFileImage) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"\"); extern const char* NSSymbolDefinitionNameInObjectFileImage(NSObjectFileImage objectFileImage, uint32_t ordinal) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"\"); extern uint32_t NSSymbolReferenceCountInObjectFileImage(NSObjectFileImage objectFileImage) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"\"); extern const char* NSSymbolReferenceNameInObjectFileImage(NSObjectFileImage objectFileImage, uint32_t ordinal, bool *tentative_definition) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"\"); extern bool NSIsSymbolDefinedInObjectFileImage(NSObjectFileImage objectFileImage, const char* symbolName) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.4, \"dlsym()\"); extern void* NSGetSectionDataInObjectFileImage(NSObjectFileImage objectFileImage, const char* segmentName, const char* sectionName, size_t *size) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"getsectiondata()\"); typedef struct __NSModule* NSModule; extern const char* NSNameOfModule(NSModule m) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"\"); extern const char* NSLibraryNameForModule(NSModule m) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"\"); extern NSModule NSLinkModule(NSObjectFileImage objectFileImage, const char* moduleName, uint32_t options) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"dlopen()\"); #define NSLINKMODULE_OPTION_NONE 0x0 #define NSLINKMODULE_OPTION_BINDNOW 0x1 #define NSLINKMODULE_OPTION_PRIVATE 0x2 #define NSLINKMODULE_OPTION_RETURN_ON_ERROR 0x4 #define NSLINKMODULE_OPTION_DONT_CALL_MOD_INIT_ROUTINES 0x8 #define NSLINKMODULE_OPTION_TRAILING_PHYS_NAME 0x10 extern bool NSUnLinkModule(NSModule module, uint32_t options) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"\"); #define NSUNLINKMODULE_OPTION_NONE 0x0 #define NSUNLINKMODULE_OPTION_KEEP_MEMORY_MAPPED 0x1 #define NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES 0x2 /* symbol API */ typedef struct __NSSymbol* NSSymbol; extern bool NSIsSymbolNameDefined(const char* symbolName) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.4, \"dlsym()\"); extern bool NSIsSymbolNameDefinedWithHint(const char* symbolName, const char* libraryNameHint) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.4, \"dlsym()\"); extern bool NSIsSymbolNameDefinedInImage(const struct mach_header* image, const char* symbolName) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.4, \"dlsym()\"); extern NSSymbol NSLookupAndBindSymbol(const char* symbolName) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.4, \"dlsym()\"); extern NSSymbol NSLookupAndBindSymbolWithHint(const char* symbolName, const char* libraryNameHint) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.4, \"dlsym()\"); extern NSSymbol NSLookupSymbolInModule(NSModule module, const char* symbolName) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"dlsym()\"); extern NSSymbol NSLookupSymbolInImage(const struct mach_header* image, const char* symbolName, uint32_t options) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"dlsym()\"); #define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND 0x0 #define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW 0x1 #define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_FULLY 0x2 #define NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR 0x4 extern const char* NSNameOfSymbol(NSSymbol symbol) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"\"); extern void * NSAddressOfSymbol(NSSymbol symbol) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"dlsym()\"); extern NSModule NSModuleForSymbol(NSSymbol symbol) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"dladdr()\"); /* error handling API */ typedef enum { NSLinkEditFileAccessError, NSLinkEditFileFormatError, NSLinkEditMachResourceError, NSLinkEditUnixResourceError, NSLinkEditOtherError, NSLinkEditWarningError, NSLinkEditMultiplyDefinedError, NSLinkEditUndefinedError } NSLinkEditErrors; /* * For the NSLinkEditErrors value NSLinkEditOtherError these are the values * passed to the link edit error handler as the errorNumber (what would be an * errno value for NSLinkEditUnixResourceError or a kern_return_t value for * NSLinkEditMachResourceError). */ typedef enum { NSOtherErrorRelocation, NSOtherErrorLazyBind, NSOtherErrorIndrLoop, NSOtherErrorLazyInit, NSOtherErrorInvalidArgs } NSOtherErrorNumbers; extern void NSLinkEditError(NSLinkEditErrors *c, int *errorNumber, const char** fileName, const char** errorString) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"dlerror()\"); typedef struct { void (*undefined)(const char* symbolName); NSModule (*multiple)(NSSymbol s, NSModule oldModule, NSModule newModule); void (*linkEdit)(NSLinkEditErrors errorClass, int errorNumber, const char* fileName, const char* errorString); } NSLinkEditErrorHandlers; extern void NSInstallLinkEditErrorHandlers(const NSLinkEditErrorHandlers *handlers) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"\"); extern bool NSAddLibrary(const char* pathName) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.4, \"dlopen()\"); extern bool NSAddLibraryWithSearching(const char* pathName) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.4, \"dlopen()\"); extern const struct mach_header* NSAddImage(const char* image_name, uint32_t options) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"dlopen()\"); #define NSADDIMAGE_OPTION_NONE 0x0 #define NSADDIMAGE_OPTION_RETURN_ON_ERROR 0x1 #define NSADDIMAGE_OPTION_WITH_SEARCHING 0x2 #define NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED 0x4 #define NSADDIMAGE_OPTION_MATCH_FILENAME_BY_INSTALLNAME 0x8 extern bool _dyld_present(void) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"always true\"); extern bool _dyld_launched_prebound(void) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"moot\"); extern bool _dyld_all_twolevel_modules_prebound(void) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.3, 10.5, \"moot\"); extern bool _dyld_bind_fully_image_containing_address(const void* address) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"dlopen(RTLD_NOW)\"); extern bool _dyld_image_containing_address(const void* address) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.3, 10.5, \"dladdr()\"); extern void _dyld_lookup_and_bind(const char* symbol_name, void **address, NSModule* module) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.4, \"dlsym()\"); extern void _dyld_lookup_and_bind_with_hint(const char* symbol_name, const char* library_name_hint, void** address, NSModule* module) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.4, \"dlsym()\"); extern void _dyld_lookup_and_bind_fully(const char* symbol_name, void** address, NSModule* module) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.1, 10.5, \"dlsym()\"); extern const struct mach_header* _dyld_get_image_header_containing_address(const void* address) __API_UNAVAILABLE(ios, tvos, watchos) __API_UNAVAILABLE(bridgeos) DYLD_DRIVERKIT_UNAVAILABLE __OSX_DEPRECATED(10.3, 10.5, \"dladdr()\"); #if __cplusplus } #endif #endif /* _MACH_O_DYLD_H_ */ cctools的mach-o/dyld.h cctools mach-o/dyld.h /* * Copyright (c) 1999 Apple Computer, Inc. All rights reserved. * * @APPLE_LICENSE_HEADER_START@ * * This file contains Original Code and/or Modifications of Original Code * as defined in and that are subject to the Apple Public Source License * Version 2.0 (the 'License'). You may not use this file except in * compliance with the License. Please obtain a copy of the License at * http://www.opensource.apple.com/apsl/ and read it before using this * file. * * The Original Code and all software distributed under the License are * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES, * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. * Please see the License for the specific language governing rights and * limitations under the License. * * @APPLE_LICENSE_HEADER_END@ */ #ifndef _MACH_O_DYLD_H_ #define _MACH_O_DYLD_H_ #ifdef __cplusplus extern \"C\" { #endif /* __cplusplus */ #if defined(__MWERKS__) && !defined(__private_extern__) #define __private_extern__ __declspec(private_extern) #endif #include #include #ifndef AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER #define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER #endif #ifndef ENUM_DYLD_BOOL #define ENUM_DYLD_BOOL #undef FALSE #undef TRUE enum DYLD_BOOL { FALSE, TRUE }; #endif /* ENUM_DYLD_BOOL */ /* * The high level NS... API. */ /* Object file image API */ typedef enum { NSObjectFileImageFailure, /* for this a message is printed on stderr */ NSObjectFileImageSuccess, NSObjectFileImageInappropriateFile, NSObjectFileImageArch, NSObjectFileImageFormat, /* for this a message is printed on stderr */ NSObjectFileImageAccess } NSObjectFileImageReturnCode; typedef void * NSObjectFileImage; /* limited implementation, only MH_BUNDLE files can be used */ extern NSObjectFileImageReturnCode NSCreateObjectFileImageFromFile( const char *pathName, NSObjectFileImage *objectFileImage); extern NSObjectFileImageReturnCode NSCreateCoreFileImageFromFile( const char *pathName, NSObjectFileImage *objectFileImage); /* not yet implemented */ extern NSObjectFileImageReturnCode NSCreateObjectFileImageFromMemory( void *address, unsigned long size, NSObjectFileImage *objectFileImage); extern enum DYLD_BOOL NSDestroyObjectFileImage( NSObjectFileImage objectFileImage); /* * API on NSObjectFileImage's for: * \"for Each Symbol Definition In Object File Image\" (for Dynamic Bundles) * and the same thing for references */ extern unsigned long NSSymbolDefinitionCountInObjectFileImage( NSObjectFileImage objectFileImage); extern const char * NSSymbolDefinitionNameInObjectFileImage( NSObjectFileImage objectFileImage, unsigned long ordinal); extern unsigned long NSSymbolReferenceCountInObjectFileImage( NSObjectFileImage objectFileImage); extern const char * NSSymbolReferenceNameInObjectFileImage( NSObjectFileImage objectFileImage, unsigned long ordinal, enum DYLD_BOOL *tentative_definition); /* can be NULL */ /* * API on NSObjectFileImage: * \"does Object File Image define symbol name X\" (using sorted symbol table) * and a way to get the named objective-C section */ extern enum DYLD_BOOL NSIsSymbolDefinedInObjectFileImage( NSObjectFileImage objectFileImage, const char *symbolName); extern void * NSGetSectionDataInObjectFileImage( NSObjectFileImage objectFileImage, const char *segmentName, const char *sectionName, unsigned long *size); /* can be NULL */ /* SPI first appeared in Mac OS X 10.3 */ extern enum DYLD_BOOL NSHasModInitObjectFileImage( NSObjectFileImage objectFileImage) AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER; /* module API */ typedef void * NSModule; extern const char * NSNameOfModule( NSModule m); extern const char * NSLibraryNameForModule( NSModule m); /* limited implementation, only MH_BUNDLE files can be linked */ extern NSModule NSLinkModule( NSObjectFileImage objectFileImage, const char *moduleName, unsigned long options); #define NSLINKMODULE_OPTION_NONE 0x0 #define NSLINKMODULE_OPTION_BINDNOW 0x1 #define NSLINKMODULE_OPTION_PRIVATE 0x2 #define NSLINKMODULE_OPTION_RETURN_ON_ERROR 0x4 #define NSLINKMODULE_OPTION_DONT_CALL_MOD_INIT_ROUTINES 0x8 #define NSLINKMODULE_OPTION_TRAILING_PHYS_NAME 0x10 /* limited implementation, only modules loaded with NSLinkModule() can be unlinked */ extern enum DYLD_BOOL NSUnLinkModule( NSModule module, unsigned long options); #define NSUNLINKMODULE_OPTION_NONE 0x0 #define NSUNLINKMODULE_OPTION_KEEP_MEMORY_MAPPED 0x1 #define NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES 0x2 /* not yet implemented */ extern NSModule NSReplaceModule( NSModule moduleToReplace, NSObjectFileImage newObjectFileImage, unsigned long options); /* symbol API */ typedef void * NSSymbol; extern enum DYLD_BOOL NSIsSymbolNameDefined( const char *symbolName); extern enum DYLD_BOOL NSIsSymbolNameDefinedWithHint( const char *symbolName, const char *libraryNameHint); extern enum DYLD_BOOL NSIsSymbolNameDefinedInImage( const struct mach_header *image, const char *symbolName); extern NSSymbol NSLookupAndBindSymbol( const char *symbolName); extern NSSymbol NSLookupAndBindSymbolWithHint( const char *symbolName, const char *libraryNameHint); extern NSSymbol NSLookupSymbolInModule( NSModule module, const char *symbolName); extern NSSymbol NSLookupSymbolInImage( const struct mach_header *image, const char *symbolName, unsigned long options); #define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND 0x0 #define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW 0x1 #define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_FULLY 0x2 #define NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR 0x4 extern const char * NSNameOfSymbol( NSSymbol symbol); extern void * NSAddressOfSymbol( NSSymbol symbol); extern NSModule NSModuleForSymbol( NSSymbol symbol); /* error handling API */ typedef enum { NSLinkEditFileAccessError, NSLinkEditFileFormatError, NSLinkEditMachResourceError, NSLinkEditUnixResourceError, NSLinkEditOtherError, NSLinkEditWarningError, NSLinkEditMultiplyDefinedError, NSLinkEditUndefinedError } NSLinkEditErrors; /* * For the NSLinkEditErrors value NSLinkEditOtherError these are the values * passed to the link edit error handler as the errorNumber (what would be an * errno value for NSLinkEditUnixResourceError or a kern_return_t value for * NSLinkEditMachResourceError). */ typedef enum { NSOtherErrorRelocation, NSOtherErrorLazyBind, NSOtherErrorIndrLoop, NSOtherErrorLazyInit, NSOtherErrorInvalidArgs } NSOtherErrorNumbers; extern void NSLinkEditError( NSLinkEditErrors *c, int *errorNumber, const char **fileName, const char **errorString); typedef struct { void (*undefined)(const char *symbolName); NSModule (*multiple)(NSSymbol s, NSModule oldModule, NSModule newModule); void (*linkEdit)(NSLinkEditErrors errorClass, int errorNumber, const char *fileName, const char *errorString); } NSLinkEditErrorHandlers; extern void NSInstallLinkEditErrorHandlers( NSLinkEditErrorHandlers *handlers); /* other API */ extern enum DYLD_BOOL NSAddLibrary( const char *pathName); extern enum DYLD_BOOL NSAddLibraryWithSearching( const char *pathName); extern const struct mach_header * NSAddImage( const char *image_name, unsigned long options); #define NSADDIMAGE_OPTION_NONE 0x0 #define NSADDIMAGE_OPTION_RETURN_ON_ERROR 0x1 #define NSADDIMAGE_OPTION_WITH_SEARCHING 0x2 #define NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED 0x4 #define NSADDIMAGE_OPTION_MATCH_FILENAME_BY_INSTALLNAME 0x8 extern long NSVersionOfRunTimeLibrary( const char *libraryName); extern long NSVersionOfLinkTimeLibrary( const char *libraryName); extern int _NSGetExecutablePath( /* SPI first appeared in Mac OS X 10.2 */ char *buf, uint32_t *bufsize); /* * The low level _dyld_... API. * (used by the objective-C runtime primarily) */ extern unsigned long _dyld_present( void); extern unsigned long _dyld_image_count( void); #ifdef __LP64__ extern struct mach_header_64 * _dyld_get_image_header( uint32_t image_index); #else /* !defined(__LP64__) */ extern struct mach_header * _dyld_get_image_header( unsigned long image_index); #endif /* !defined(__LP64__) */ extern unsigned long _dyld_get_image_vmaddr_slide( unsigned long image_index); extern char * _dyld_get_image_name( unsigned long image_index); extern void _dyld_register_func_for_add_image( void (*func)(struct mach_header *mh, unsigned long vmaddr_slide)); extern void _dyld_register_func_for_remove_image( void (*func)(struct mach_header *mh, unsigned long vmaddr_slide)); extern void _dyld_register_func_for_link_module( void (*func)(NSModule module)); /* not yet implemented */ extern void _dyld_register_func_for_unlink_module( void (*func)(NSModule module)); /* not yet implemented */ extern void _dyld_register_func_for_replace_module( void (*func)(NSModule oldmodule, NSModule newmodule)); extern void _dyld_get_objc_module_sect_for_module( NSModule module, void **objc_module, unsigned long *size); extern void _dyld_bind_objc_module( void *objc_module); extern enum DYLD_BOOL _dyld_bind_fully_image_containing_address( unsigned long *address); extern enum DYLD_BOOL _dyld_image_containing_address( unsigned long address); /* SPI first appeared in Mac OS X 10.3 */ extern struct mach_header * _dyld_get_image_header_containing_address( unsigned long address) AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER; extern void _dyld_moninit( void (*monaddition)(char *lowpc, char *highpc)); extern enum DYLD_BOOL _dyld_launched_prebound( void); /* SPI first appeared in Mac OS X 10.3 */ extern enum DYLD_BOOL _dyld_all_twolevel_modules_prebound( void) AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER; extern void _dyld_lookup_and_bind( const char *symbol_name, unsigned long *address, void **module); extern void _dyld_lookup_and_bind_with_hint( const char *symbol_name, const char *library_name_hint, unsigned long *address, void **module); extern void _dyld_lookup_and_bind_objc( const char *symbol_name, unsigned long *address, void **module); extern void _dyld_lookup_and_bind_fully( const char *symbol_name, unsigned long *address, void **module); __private_extern__ int _dyld_func_lookup( const char *dyld_func_name, unsigned long *address); #ifdef __cplusplus } #endif /* __cplusplus */ #endif /* _MACH_O_DYLD_H_ */ crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-15 10:05:56 "},"dyld/func/dyld_api/dyld_h/_dyld_image_count.html":{"url":"dyld/func/dyld_api/dyld_h/_dyld_image_count.html","title":"_dyld_image_count","keywords":"","body":"_dyld_image_count 语法uint32_t _dyld_image_count(void); 反越狱检测 代码和效果详见： crifan/iOSBypassJailbreak: 越狱iOS的hook插件，实现反越狱检测 hook_dyld.xm crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-12 09:45:58 "},"dyld/func/dyld_api/dyld_h/_dyld_get_image_header.html":{"url":"dyld/func/dyld_api/dyld_h/_dyld_get_image_header.html","title":"_dyld_get_image_header","keywords":"","body":"_dyld_get_image_header 语法const struct mach_header* _dyld_get_image_header(uint32_t image_index); 反越狱检测 代码和效果详见： crifan/iOSBypassJailbreak: 越狱iOS的hook插件，实现反越狱检测 hook_dyld.xm crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-12 09:48:22 "},"dyld/func/dyld_api/dyld_h/_dyld_get_image_vmaddr_slide.html":{"url":"dyld/func/dyld_api/dyld_h/_dyld_get_image_vmaddr_slide.html","title":"_dyld_get_image_vmaddr_slide","keywords":"","body":"_dyld_get_image_vmaddr_slide 语法intptr_t _dyld_get_image_vmaddr_slide(uint32_t image_index); 反越狱检测 代码和效果详见： crifan/iOSBypassJailbreak: 越狱iOS的hook插件，实现反越狱检测 hook_dyld.xm crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-12 09:48:33 "},"dyld/func/dyld_api/dyld_h/_dyld_get_image_name.html":{"url":"dyld/func/dyld_api/dyld_h/_dyld_get_image_name.html","title":"_dyld_get_image_name","keywords":"","body":"_dyld_get_image_name 语法const char* _dyld_get_image_name(uint32_t image_index); 反汇编代码 libdyld.dylib`_dyld_get_image_name: -> 0x1ad825518 : stp x20, x19, [sp, #-0x20]! 0x1ad82551c : stp x29, x30, [sp, #0x10] 0x1ad825520 : add x29, sp, #0x10 ; =0x10 0x1ad825524 : mov x19, x0 0x1ad825528 : adrp x8, 303304 0x1ad82552c : add x8, x8, #0x698 ; =0x698 0x1ad825530 : ldrb w8, [x8] 0x1ad825534 : cbz w8, 0x1ad825548 ; 0x1ad825538 : mov x0, x19 0x1ad82553c : ldp x29, x30, [sp, #0x10] 0x1ad825540 : ldp x20, x19, [sp], #0x20 0x1ad825544 : b 0x1ad830924 ; dyld3::_dyld_get_image_name(unsigned int) 0x1ad825548 : adrp x8, 315596 0x1ad82554c : ldr x1, [x8, #0x748] 0x1ad825550 : cbnz x1, 0x1ad825570 ; 0x1ad825554 : adrp x0, 39 0x1ad825558 : add x0, x0, #0xe0b ; =0xe0b 0x1ad82555c : adrp x20, 315596 0x1ad825560 : add x20, x20, #0x748 ; =0x748 0x1ad825564 : mov x1, x20 0x1ad825568 : bl 0x1ad824d38 ; _dyld_func_lookup 0x1ad82556c : ldr x1, [x20] 0x1ad825570 : mov x0, x19 0x1ad825574 : ldp x29, x30, [sp, #0x10] 0x1ad825578 : ldp x20, x19, [sp], #0x20 0x1ad82557c : br x1 越狱检测 上层测试的=正向测试越狱的=iOS的app的 #import #import - (void) dbgPrintLibInfo: (int)curImgIdx{ // debug slide intptr_t curSlide = _dyld_get_image_vmaddr_slide(curImgIdx); NSLog(@\"[%d] curSlide=0x%lx\", curImgIdx, curSlide); // debug header info const struct mach_header* libHeader = _dyld_get_image_header(curImgIdx); if (NULL != libHeader){ int magic = libHeader->magic; int cputype = libHeader->cputype; int cpusubtype = libHeader->cpusubtype; int filetype = libHeader->filetype; int ncmds = libHeader->ncmds; int sizeofcmds = libHeader->sizeofcmds; int flags = libHeader->flags; NSLog(@\"[%d] magic=%d,cputype=0x%x,cpusubtype=0x%x,filetype=%d,ncmds=%d,sizeofcmds=%d,flags=0x%x\", curImgIdx, magic, cputype, cpusubtype, filetype, ncmds, sizeofcmds, flags); } else { NSLog(@\"[%d] mach_header is NULL\", curImgIdx); } } - (IBAction)dyldImgCntNameBtnClicked:(UIButton *)sender { NSLog(@\"_dyld_image_count and _dyld_get_image_name check\"); //for debug int testImgIdx = 282; // hooked:279 ~ real: 284 [self dbgPrintLibInfo: testImgIdx]; uint32_t imageCount = _dyld_image_count(); NSLog(@\"dyld: imageCount=%d\", imageCount); NSMutableArray *loadedDylibList = [NSMutableArray array]; NSMutableArray *jbDylibList = [NSMutableArray array]; for (uint32_t i = 0 ; i 0){ dyldLibResultStr = [NSString stringWithFormat: @\"检测出越狱动态库 -> 越狱手机; 越狱动态库列表:\\n%@\", jbLibListStr]; } else{ dyldLibResultStr = @\"未检测出越狱动态库 -> 非越狱手机\"; } NSLog(@\"dyld: dyldLibResultStr=%@\", dyldLibResultStr); _dyldResultTv.text = dyldLibResultStr; } 最新代码详见： crifan/iOSJailbreakDetection: iOS的ObjC的app，实现iOS越狱检测 JbDetectOtherViewController.m - (IBAction)dyldImgCntNameBtnClicked:(UIButton *)sender 反越狱检测 最新代码和效果 代码 crifan/iOSBypassJailbreak: 越狱iOS的hook插件，实现反越狱检测 hook_dyld.xm 效果 crifan/iOSBypassJailbreak: 越狱iOS的hook插件，实现反越狱检测 未开启反越狱： 能检测出5个越狱的库： 开启了反越狱： _dyld_image_count _dyld_get_image_name _dyld_get_image_header _dyld_get_image_vmaddr_slide 检测不出任何的越狱的库了： Frida的hook const dyldGetImgName = Module.findExportByName(null, '_dyld_get_image_name'); Interceptor.attach(dyldGetImgName, { onEnter: function (args) { // console.log('_dyld_get_image_name: arg1=' + args[1]); const arg0 = args[0]; const arg1 = args[1]; const arg0Str = Memory.readUtf8String(arg0); // const arg0Str = arg0.readPointer().readCString() // console.log('_dyld_get_image_name: arg1=%i, arg1Str=%s', arg1, arg1Str); console.log('_dyld_get_image_name: arg0=', arg0, 'arg0Str=', arg0Str, 'arg1=', arg1); } }); crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-14 11:32:25 "},"dyld/func/dyld_api/dyld_h/_dyld_register_func_for_add_image.html":{"url":"dyld/func/dyld_api/dyld_h/_dyld_register_func_for_add_image.html","title":"_dyld_register_func_for_add_image","keywords":"","body":"_dyld_register_func_for_add_image 语法void _dyld_register_func_for_add_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)); 越狱检测 相关代码： static NSString* checkImageResult = @\"未发现越狱库 -> 非越狱手机\"; NSMutableArray *checkImageFoundJbLibList = NULL; //static NSSet *sDylibSet ; // 需要检测的动态库 //static BOOL SCHECK_USER = NO; /// 检测是否越狱 + (void)load { static dispatch_once_t onceToken; dispatch_once(&onceToken, ^{ // sDylibSet = [NSSet setWithObjects: // @\"/usr/lib/CepheiUI.framework/CepheiUI\", // @\"/usr/lib/libsubstitute.dylib\", // @\"/usr/lib/substitute-inserter.dylib\", // @\"/usr/lib/substitute-loader.dylib\", // @\"/usr/lib/substrate/SubstrateLoader.dylib\", // @\"/usr/lib/substrate/SubstrateInserter.dylib\", // @\"/Library/MobileSubstrate/MobileSubstrate.dylib\", // @\"/Library/MobileSubstrate/DynamicLibraries/0Shadow.dylib\", // // nil]; checkImageFoundJbLibList = [NSMutableArray array]; _dyld_register_func_for_add_image(_check_image); }); } + (instancetype)sharedInstance { static id sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&onceToken, ^{ sharedInstance = [self new]; }); return sharedInstance; } // 监听image加载，从这里判断动态库是否加载，因为其他的检测动态库的方案会被hook static void _check_image(const struct mach_header *header, intptr_t slide) { // // hook Image load // if (SCHECK_USER) { // // 检测后就不在检测 // return; // } // 检测的lib Dl_info info; size_t dlInfoSize = sizeof(Dl_info); memset(&info, 0, dlInfoSize); // 0表示加载失败了，这里大概率是被hook导致的 int dladdrRet = dladdr(header, &info); // if (dladdrRet == 0) { // char *dlerro = dlerror(); // 获取失败了 但是返回了dli_fname, 说明被人hook了，目前看的方案都是直接返回0来绕过的 const char* curImgName = info.dli_fname; // if(dlerro == NULL && curImgName != NULL) { if(curImgName != NULL) { NSString *curImgNameNs = [NSString stringWithUTF8String: curImgName]; // 判断有没有在动态列表里面 // if ([sDylibSet containsObject:curImgNameNs]) { if (isJailbreakDylib(curImgName)) { // SCHECK_USER = YES; [checkImageFoundJbLibList addObject: curImgNameNs]; NSString *jbLibListStr = [CrifanLibiOS nsStrListToStr:checkImageFoundJbLibList isSortList:TRUE isAddIndexPrefix:TRUE]; checkImageResult = [NSString stringWithFormat: @\"发现越狱动态库 -> 越狱手机\\n%@\", jbLibListStr]; NSLog(@\"%@\", checkImageResult); // \"Found Jailbreak dylib: /usr/lib/substitute-inserter.dylib -> 越狱手机\" } } return; // } } ... resultStr = checkImageResult; 详见： JailbreakPathList.c 输出： 2022-01-21 15:57:49.550319+0800 ShowSysInfo[16209:1127247] 发现越狱动态库 -> 越狱手机 列表总个数：5 [0] /Library/MobileSubstrate/DynamicLibraries/AppSyncUnified-FrontBoard.dylib [1] /usr/lib/libsubstitute.dylib [2] /usr/lib/libsubstrate.dylib [3] /usr/lib/substitute-inserter.dylib [4] /usr/lib/substitute-loader.dylib 是可以检测出越狱库的： 然后开启反越狱后，就检测不到了： 2022-01-21 15:59:59.578918+0800 ShowSysInfo[16243:1128562] resultStr=未发现越狱库 -> 非越狱手机 最新代码详见： crifan/iOSJailbreakDetection: iOS的ObjC的app，实现iOS越狱检测 JbDetectOtherViewController.m + (void)load _check_image 反越狱检测 代码和效果详见： crifan/iOSBypassJailbreak: 越狱iOS的hook插件，实现反越狱检测 hook_dyld.xm 涉及到的地方 AwemeCore * frame #0: 0x00000001187141e0 XxxTweak.dylib`_logos_function$_ungrouped$getsectiondata(mhp=0x0000000102830000, segname=\"__DATA\", sectname=\"TimorLoad\", size=0x000000016d9ffd58) at hook_machO.xm:192:17 [opt] frame #1: 0x0000000114006324 AwemeCore`___lldb_unnamed_symbol1843642$$AwemeCore + 76 frame #2: 0x0000000114005c60 AwemeCore`___lldb_unnamed_symbol1843637$$AwemeCore + 76 frame #3: 0x00000001027581ac dyld`dyld::registerAddCallback(void (*)(mach_header const*, long)) + 260 frame #4: 0x000000018d123f64 libdyld.dylib`_dyld_register_func_for_add_image + 112 ... crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-12 15:45:58 "},"dyld/func/dyld_api/dyld_h/_dyld_register_func_for_remove_image.html":{"url":"dyld/func/dyld_api/dyld_h/_dyld_register_func_for_remove_image.html","title":"_dyld_register_func_for_remove_image","keywords":"","body":"_dyld_register_func_for_remove_image 语法void _dyld_register_func_for_remove_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)); 反越狱检测 代码和效果详见： crifan/iOSBypassJailbreak: 越狱iOS的hook插件，实现反越狱检测 hook_dyld.xm 涉及到的地方 Aweme crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-14 11:43:38 "},"dyld/func/dyld_api/dyld_h/nsversionofruntimelibrary.html":{"url":"dyld/func/dyld_api/dyld_h/nsversionofruntimelibrary.html","title":"NSVersionOfRunTimeLibrary","keywords":"","body":"NSVersionOfRunTimeLibrary 语法int32_t NSVersionOfRunTimeLibrary(const char* libraryName); 反越狱检测 之前代码： int32_t NSVersionOfRunTimeLibrary(const char* libraryName); %hookf(int32_t, NSVersionOfRunTimeLibrary, const char* libraryName){ int32_t rtLibVer = %orig; iosLogInfo(\"libraryName=%s -> rtLibVer=%d\", libraryName, rtLibVer); return rtLibVer; } 最新代码详见： crifan/iOSBypassJailbreak: 越狱iOS的hook插件，实现反越狱检测 hook_dyld.xm crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-14 10:50:59 "},"dyld/func/dyld_api/dyld_h/nsversionoflinktimelibrary.html":{"url":"dyld/func/dyld_api/dyld_h/nsversionoflinktimelibrary.html","title":"NSVersionOfLinkTimeLibrary","keywords":"","body":"NSVersionOfLinkTimeLibrary 语法int32_t NSVersionOfLinkTimeLibrary(const char* libraryName); 反越狱检测 之前代码： %hookf(int32_t, NSVersionOfLinkTimeLibrary, const char* libraryName){ int32_t rtLtLibVer = %orig; iosLogInfo(\"libraryName=%s -> rtLtLibVer=%d\", libraryName, rtLtLibVer); return rtLtLibVer; } 输出举例： 默认 15:34:41.972821+0800 Aweme hook_dyld.xm NSVersionOfLinkTimeLibrary: libraryName=UIKit -> rtLtLibVer=-1 默认 15:34:43.737029+0800 Aweme hook_dyld.xm NSVersionOfLinkTimeLibrary: libraryName=System -> rtLtLibVer=85917696 默认 15:34:46.257838+0800 Aweme hook_dyld.xm NSVersionOfLinkTimeLibrary: libraryName=AudioToolbox -> rtLtLibVer=-1 默认 15:34:49.359575+0800 Aweme hook_dyld.xm NSVersionOfLinkTimeLibrary: libraryName=System -> rtLtLibVer=85917696 默认 15:34:49.359627+0800 Aweme hook_dyld.xm NSVersionOfLinkTimeLibrary: libraryName=CoreFoundation -> rtLtLibVer=-1 最新代码详见： crifan/iOSBypassJailbreak: 越狱iOS的hook插件，实现反越狱检测 hook_dyld.xm crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-14 10:52:48 "},"dyld/func/dyld_api/dyld_h/_nsgetexecutablepath.html":{"url":"dyld/func/dyld_api/dyld_h/_nsgetexecutablepath.html","title":"_NSGetExecutablePath","keywords":"","body":"_NSGetExecutablePath 语法int _NSGetExecutablePath(char* buf, uint32_t* bufsize); 反越狱检测 之前代码： int _NSGetExecutablePath(char* buf, uint32_t* bufsize); %hookf(int, _NSGetExecutablePath, char* buf, uint32_t* bufsize){ int extPathCpSize = %orig; // iosLogInfo(\"buf=%s,*bufsize=%d -> extPathCpSize=%d\", libraryName, *bufsize, extPathCpSize); iosLogInfo(\"buf=%{public}s,*bufsize=%d -> extPathCpSize=%d\", buf, *bufsize, extPathCpSize); return extPathCpSize; } 输出举例： 默认 15:38:39.329370+0800 Aweme hook_dyld.xm _NSGetExecutablePath: buf=/private/var/containers/Bundle/Application/49BD25E2-7CC2-4B8D-8953-5E0DD5427B4C/Aweme.app/Aweme,*bufsize=1023 -> extPathCpSize=0 默认 15:38:39.348166+0800 Aweme hook_dyld.xm _NSGetExecutablePath: buf=(null),*bufsize=96 -> extPathCpSize=-1 默认 15:38:39.348270+0800 Aweme hook_dyld.xm _NSGetExecutablePath: buf=/private/var/containers/Bundle/Application/49BD25E2-7CC2-4B8D-8953-5E0DD5427B4C/Aweme.app/Aweme,*bufsize=96 -> extPathCpSize=0 默认 15:38:42.712959+0800 Aweme hook_dyld.xm _NSGetExecutablePath: buf=/private/var/containers/Bundle/Application/49BD25E2-7CC2-4B8D-8953-5E0DD5427B4C/Aweme.app/Aweme,*bufsize=1024 -> extPathCpSize=0 默认 15:38:43.279102+0800 Aweme hook_dyld.xm _NSGetExecutablePath: buf=/private/var/containers/Bundle/Application/49BD25E2-7CC2-4B8D-8953-5E0DD5427B4C/Aweme.app/Aweme,*bufsize=1023 -> extPathCpSize=0 默认 15:38:43.304791+0800 Aweme hook_dyld.xm _NSGetExecutablePath: buf=(null),*bufsize=96 -> extPathCpSize=-1 默认 15:38:43.304954+0800 Aweme hook_dyld.xm _NSGetExecutablePath: buf=/private/var/containers/Bundle/Application/49BD25E2-7CC2-4B8D-8953-5E0DD5427B4C/Aweme.app/Aweme,*bufsize=96 -> extPathCpSize=0 最新代码详见： crifan/iOSBypassJailbreak: 越狱iOS的hook插件，实现反越狱检测 hook_dyld.xm crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-14 10:52:24 "},"dyld/func/dyld_api/dyld_priv_h/":{"url":"dyld/func/dyld_api/dyld_priv_h/","title":"dyld_priv.h","keywords":"","body":"dyld_priv.h 关于 dyld_image_header_containing_address dyld_program_sdk_at_least dyld_shared_cache_file_path _dyld_get_all_image_infos 等函数，是： 实现在： dyld3/APIs.cpp dyldAPIs.cpp 注：只实现了部分函数 定义在 dyld3/APIs.h 别处引用在 dyld dyld_priv.h mach-o/dyld_priv.h dyld/include/mach-o/dyld_priv.h at master · opensource-apple/dyld 相关 dyld-852.2的mach-o/dyld_priv.h的内容 dyld-852.2 mach-o/dyld_priv.h /* -*- mode: C++; c-basic-offset: 4; tab-width: 4 -*- * * Copyright (c) 2003-2010 Apple Inc. All rights reserved. * * @APPLE_LICENSE_HEADER_START@ * * This file contains Original Code and/or Modifications of Original Code * as defined in and that are subject to the Apple Public Source License * Version 2.0 (the 'License'). You may not use this file except in * compliance with the License. Please obtain a copy of the License at * http://www.opensource.apple.com/apsl/ and read it before using this * file. * * The Original Code and all software distributed under the License are * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES, * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. * Please see the License for the specific language governing rights and * limitations under the License. * * @APPLE_LICENSE_HEADER_END@ */ #ifndef _MACH_O_DYLD_PRIV_H_ #define _MACH_O_DYLD_PRIV_H_ #include #include #include #include #include #include #include #if __cplusplus extern \"C\" { #endif /* __cplusplus */ // // private interface between libSystem.dylib and dyld // extern void _dyld_atfork_prepare(void); extern void _dyld_atfork_parent(void); extern void _dyld_fork_child(void); typedef void (*_dyld_objc_notify_mapped)(unsigned count, const char* const paths[], const struct mach_header* const mh[]); typedef void (*_dyld_objc_notify_init)(const char* path, const struct mach_header* mh); typedef void (*_dyld_objc_notify_unmapped)(const char* path, const struct mach_header* mh); // // Note: only for use by objc runtime // Register handlers to be called when objc images are mapped, unmapped, and initialized. // Dyld will call back the \"mapped\" function with an array of images that contain an objc-image-info section. // Those images that are dylibs will have the ref-counts automatically bumped, so objc will no longer need to // call dlopen() on them to keep them from being unloaded. During the call to _dyld_objc_notify_register(), // dyld will call the \"mapped\" function with already loaded objc images. During any later dlopen() call, // dyld will also call the \"mapped\" function. Dyld will call the \"init\" function when dyld would be called // initializers in that image. This is when objc calls any +load methods in that image. // void _dyld_objc_notify_register(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped); // // get slide for a given loaded mach_header // Mac OS X 10.6 and later // extern intptr_t _dyld_get_image_slide(const struct mach_header* mh); struct dyld_unwind_sections { const struct mach_header* mh; const void* dwarf_section; uintptr_t dwarf_section_length; const void* compact_unwind_section; uintptr_t compact_unwind_section_length; }; // // Returns true iff some loaded mach-o image contains \"addr\". // info->mh mach header of image containing addr // info->dwarf_section pointer to start of __TEXT/__eh_frame section // info->dwarf_section_length length of __TEXT/__eh_frame section // info->compact_unwind_section pointer to start of __TEXT/__unwind_info section // info->compact_unwind_section_length length of __TEXT/__unwind_info section // // Exists in Mac OS X 10.6 and later #if !__USING_SJLJ_EXCEPTIONS__ extern bool _dyld_find_unwind_sections(void* addr, struct dyld_unwind_sections* info); #endif // // This is an optimized form of dladdr() that only returns the dli_fname field. // // Exists in Mac OS X 10.6 and later extern const char* dyld_image_path_containing_address(const void* addr); // // This is an optimized form of dladdr() that only returns the dli_fbase field. // Return NULL, if address is not in any image tracked by dyld. // // Exists in Mac OS X 10.11 and later extern const struct mach_header* dyld_image_header_containing_address(const void* addr); // // Return the mach header of the process // // Exists in Mac OS X 10.16 and later extern const struct mach_header* _dyld_get_prog_image_header(void); typedef uint32_t dyld_platform_t; typedef struct { dyld_platform_t platform; uint32_t version; } dyld_build_version_t; // Returns the active platform of the process extern dyld_platform_t dyld_get_active_platform(void) __API_AVAILABLE(macos(10.14), ios(12.0), watchos(5.0), tvos(12.0), bridgeos(3.0)); // Base platforms are platforms that have version numbers (macOS, iOS, watchos, tvOS, bridgeOS) // All other platforms are mapped to a base platform for version checks // It is intended that most code in the OS will use the version set constants, which will correctly deal with secret and future // platforms. For example: // if (dyld_program_sdk_at_least(dyld_fall_2018_os_versions)) { // New behaviour for programs built against the iOS 12, tvOS 12, watchOS 5, macOS 10.14, or bridgeOS 3 (or newer) SDKs // } else { // Old behaviour // } // In cases where more precise control is required (such as APIs that were added to varions platforms in different years) // the os specific values may be used instead. Unlike the version set constants, the platform specific ones will only ever // return true if the running binary is the platform being testsed, allowing conditions to be built for specific platforms // and releases that came out at different times. For example: // if (dyld_program_sdk_at_least(dyld_platform_version_iOS_12_0) // || dyld_program_sdk_at_least(dyld_platform_version_watchOS_6_0)) { // New behaviour for programs built against the iOS 12 (fall 2018), watchOS 6 (fall 2019) (or newer) SDKs // } else { // Old behaviour all other platforms, as well as older iOSes and watchOSes // } extern dyld_platform_t dyld_get_base_platform(dyld_platform_t platform) __API_AVAILABLE(macos(10.14), ios(12.0), watchos(5.0), tvos(12.0), bridgeos(3.0)); // SPI to ask if a platform is a simulation platform extern bool dyld_is_simulator_platform(dyld_platform_t platform) __API_AVAILABLE(macos(10.14), ios(12.0), watchos(5.0), tvos(12.0), bridgeos(3.0)); // Takes a version and returns if the image was built againt that SDK or newer // In the case of multi_plaform mach-o's it tests against the active platform extern bool dyld_sdk_at_least(const struct mach_header* mh, dyld_build_version_t version) __API_AVAILABLE(macos(10.14), ios(12.0), watchos(5.0), tvos(12.0), bridgeos(3.0)); // Takes a version and returns if the image was built with that minos version or newer // In the case of multi_plaform mach-o's it tests against the active platform extern bool dyld_minos_at_least(const struct mach_header* mh, dyld_build_version_t version) __API_AVAILABLE(macos(10.14), ios(12.0), watchos(5.0), tvos(12.0), bridgeos(3.0)); // Convenience versions of the previous two functions that run against the the main executable extern bool dyld_program_sdk_at_least(dyld_build_version_t version) __API_AVAILABLE(macos(10.14), ios(12.0), watchos(5.0), tvos(12.0), bridgeos(3.0)); extern bool dyld_program_minos_at_least(dyld_build_version_t version) __API_AVAILABLE(macos(10.14), ios(12.0), watchos(5.0), tvos(12.0), bridgeos(3.0)); // Function that walks through the load commands and calls the internal block for every version found // Intended as a fallback for very complex (and rare) version checks, or for tools that need to // print our everything for diagnostic reasons extern void dyld_get_image_versions(const struct mach_header* mh, void (^callback)(dyld_platform_t platform, uint32_t sdk_version, uint32_t min_version)) __API_AVAILABLE(macos(10.14), ios(12.0), watchos(5.0), tvos(12.0), bridgeos(3.0)); // Convienence constants for dyld version SPIs. // Because we now have so many different OSes with different versions these version set values are intended to // to provide a more convenient way to version check. They may be used instead of platform specific version in // dyld_sdk_at_least(), dyld_minos_at_least(), dyld_program_sdk_at_least(), and dyld_program_minos_at_least(). // Since they are references into a lookup table they MUST NOT be used by any code that does not ship as part of // the OS, as the values may change and the tables in older OSes may not have the necessary values for back // deployed binaries. These values are future proof against new platforms being added, and any checks against // platforms that did not exist at the epoch of a version set will return true since all versions of that platform // are inherently newer. //@VERSION_DEFS@ // // This finds the SDK version a binary was built against. // Returns zero on error, or if SDK version could not be determined. // // Exists in Mac OS X 10.8 and later // Exists in iOS 6.0 and later extern uint32_t dyld_get_sdk_version(const struct mach_header* mh); // // This finds the SDK version that the main executable was built against. // Returns zero on error, or if SDK version could not be determined. // // Note on watchOS, this returns the equivalent iOS SDK version number // (i.e an app built against watchOS 2.0 SDK returne 9.0). To see the // platform specific sdk version use dyld_get_program_sdk_watch_os_version(). // // Exists in Mac OS X 10.8 and later // Exists in iOS 6.0 and later extern uint32_t dyld_get_program_sdk_version(void); #if TARGET_OS_WATCH // watchOS only. // This finds the Watch OS SDK version that the main executable was built against. // Exists in Watch OS 2.0 and later extern uint32_t dyld_get_program_sdk_watch_os_version(void) __API_AVAILABLE(watchos(2.0)); // watchOS only. // This finds the Watch min OS version that the main executable was built to run on. // Note: dyld_get_program_min_os_version() returns the iOS equivalent (e.g. 9.0) // whereas this returns the raw watchOS version (e.g. 2.0). // Exists in Watch OS 3.0 and later extern uint32_t dyld_get_program_min_watch_os_version(void) __API_AVAILABLE(watchos(3.0)); #endif #if TARGET_OS_BRIDGE // bridgeOS only. // This finds the bridgeOS SDK version that the main executable was built against. // Exists in bridgeOSOS 2.0 and later extern uint32_t dyld_get_program_sdk_bridge_os_version(void) __API_AVAILABLE(bridgeos(2.0)); // bridgeOS only. // This finds the Watch min OS version that the main executable was built to run on. // Note: dyld_get_program_min_os_version() returns the iOS equivalent (e.g. 9.0) // whereas this returns the raw bridgeOS version (e.g. 2.0). // Exists in bridgeOS 2.0 and later extern uint32_t dyld_get_program_min_bridge_os_version(void) __API_AVAILABLE(bridgeos(2.0)); #endif // // This finds the min OS version a binary was built to run on. // Returns zero on error, or if no min OS recorded in binary. // // Exists in Mac OS X 10.8 and later // Exists in iOS 6.0 and later extern uint32_t dyld_get_min_os_version(const struct mach_header* mh); // // This finds the min OS version the main executable was built to run on. // Returns zero on error, or if no min OS recorded in binary. // // Exists in Mac OS X 10.8 and later // Exists in iOS 6.0 and later extern uint32_t dyld_get_program_min_os_version(void); // // Returns if any OS dylib has overridden its copy in the shared cache // // Exists in iPhoneOS 3.1 and later // Exists in Mac OS X 10.10 and later extern bool dyld_shared_cache_some_image_overridden(void); // // Returns if the process is setuid or is code signed with entitlements. // NOTE: It is safe to call this prior to malloc being initialized. This function // is guaranteed to not call malloc, or depend on its state. // // Exists in Mac OS X 10.9 and later extern bool dyld_process_is_restricted(void); // // Returns path used by dyld for standard dyld shared cache file for the current arch. // // Exists in Mac OS X 10.11 and later extern const char* dyld_shared_cache_file_path(void); // // Returns if there are any inserted (via DYLD_INSERT_LIBRARIES) or interposing libraries. // // Exists in Mac OS X 10.15 and later extern bool dyld_has_inserted_or_interposing_libraries(void); // // Return true if dyld contains a fix for a specific identifier. Intended for staging breaking SPI // changes // // Exists in macOS 10.16, iOS 14, tvOS14, watchOS 7 and later extern bool _dyld_has_fix_for_radar(const char *rdar); // // for OpenGL to tell dyld it is ok to deallocate a memory based image when done. // // Exists in Mac OS X 10.9 and later #define NSLINKMODULE_OPTION_CAN_UNLOAD 0x20 // // Update all bindings on specified image. // Looks for uses of 'replacement' and changes it to 'replacee'. // NOTE: this is less safe than using static interposing via DYLD_INSERT_LIBRARIES // because the running program may have already copy the pointer values to other // locations that dyld does not know about. // struct dyld_interpose_tuple { const void* replacement; const void* replacee; }; extern void dyld_dynamic_interpose(const struct mach_header* mh, const struct dyld_interpose_tuple array[], size_t count); struct dyld_shared_cache_dylib_text_info { uint64_t version; // current version 2 // following fields all exist in version 1 uint64_t loadAddressUnslid; uint64_t textSegmentSize; uuid_t dylibUuid; const char* path; // pointer invalid at end of iterations // following fields all exist in version 2 uint64_t textSegmentOffset; // offset from start of cache }; typedef struct dyld_shared_cache_dylib_text_info dyld_shared_cache_dylib_text_info; #ifdef __BLOCKS__ // // Given the UUID of a dyld shared cache file, this function will attempt to locate the cache // file and if found iterate all images, returning info about each one. Returns 0 on success. // // Exists in Mac OS X 10.11 and later // iOS 9.0 and later extern int dyld_shared_cache_iterate_text(const uuid_t cacheUuid, void (^callback)(const dyld_shared_cache_dylib_text_info* info)); // // Given the UUID of a dyld shared cache file, and a NULL terminated array of extra directory paths to search, // this function will scan the standard and extra directories looking for a cache file that matches the UUID // and if found iterate all images, returning info about each one. Returns 0 on success. // // Exists in Mac OS X 10.12 and later // iOS 10.0 and later extern int dyld_shared_cache_find_iterate_text(const uuid_t cacheUuid, const char* extraSearchDirs[], void (^callback)(const dyld_shared_cache_dylib_text_info* info)); #endif /* __BLOCKS */ // // Returns if the specified address range is in a dyld owned memory // that is mapped read-only and will never be unloaded. // // Exists in Mac OS X 10.12 and later // iOS 10.0 and later extern bool _dyld_is_memory_immutable(const void* addr, size_t length); // // Finds the UUID (from LC_UUID load command) of given image. // Returns false if LC_UUID is missing or mach_header is malformed. // // Exists in Mac OS X 10.12 and later // Exists in iOS 10.0 and later extern bool _dyld_get_image_uuid(const struct mach_header* mh, uuid_t uuid); // // Gets the UUID of the dyld shared cache in the current process. // Returns false if there is no dyld shared cache in use by the processes. // // Exists in Mac OS X 10.12 and later // Exists in iOS 10.0 and later extern bool _dyld_get_shared_cache_uuid(uuid_t uuid); // // Returns the start address of the dyld cache in the process and sets length to the size of the cache. // Returns NULL if the process is not using a dyld shared cache // // Exists in Mac OS X 10.13 and later // Exists in iOS 11.0 and later extern const void* _dyld_get_shared_cache_range(size_t* length); // // Returns if the currently active dyld shared cache is optimized. // Note: macOS does not use optimized caches and will always return false. // // Exists in Mac OS X 10.15 and later // Exists in iOS 13.0 and later extern bool _dyld_shared_cache_optimized(void); // // Returns if the currently active dyld shared cache was built locally. // // Exists in Mac OS X 10.15 and later // Exists in iOS 13.0 and later extern bool _dyld_shared_cache_is_locally_built(void); // // Returns if the given app needs a closure built. // // Exists in Mac OS X 10.15 and later // Exists in iOS 13.0 and later extern bool dyld_need_closure(const char* execPath, const char* dataContainerRootDir); struct dyld_image_uuid_offset { uuid_t uuid; uint64_t offsetInImage; const struct mach_header* image; }; // // Given an array of addresses, returns info about each address. // Common usage is the array or addresses was produced by a stack backtrace. // For each address, returns the where that image was loaded, the offset // of the address in the image, and the image's uuid. If a specified // address is unknown to dyld, all fields will be returned a zeros. // // Exists in macOS 10.14 and later // Exists in iOS 12.0 and later extern void _dyld_images_for_addresses(unsigned count, const void* addresses[], struct dyld_image_uuid_offset infos[]); // // Lets you register a callback which is called each time an image is loaded and provides the mach_header*, path, and // whether the image may be unloaded later. During the call to _dyld_register_for_image_loads(), the callback is called // once for each image currently loaded. // // Exists in macOS 10.14 and later // Exists in iOS 12.0 and later extern void _dyld_register_for_image_loads(void (*func)(const struct mach_header* mh, const char* path, bool unloadable)); // // Lets you register a callback which is called for bulk notifications of images loaded. During the call to // _dyld_register_for_bulk_image_loads(), the callback is called once with all images currently loaded. // Then later during dlopen() the callback is called once with all newly images. // // Exists in macOS 10.15 and later // Exists in iOS 13.0 and later extern void _dyld_register_for_bulk_image_loads(void (*func)(unsigned imageCount, const struct mach_header* mhs[], const char* paths[])); // // DriverKit main executables do not have an LC_MAIN. Instead DriverKit.framework's initializer calls // _dyld_register_driverkit_main() with a function pointer that dyld should call into instead // of using LC_MAIN. // extern void _dyld_register_driverkit_main(void (*mainFunc)(void)); // // This is similar to _dyld_shared_cache_contains_path(), except that it returns the canonical // shared cache path for the given path. // // Exists in macOS 10.16 and later // Exists in iOS 14.0 and later extern const char* _dyld_shared_cache_real_path(const char* path); // // Dyld has a number of modes. This function returns the mode for the current process. // dyld2 is the classic \"interpreter\" way to run. // dyld3 runs by compiling down and caching what dyld needs to do into a \"closure\". // // Exists in macOS 10.16 and later // Exists in iOS 14.0 and later // #define DYLD_LAUNCH_MODE_USING_CLOSURE 0x00000001 // if 0, then running in classic dyld2 mode #define DYLD_LAUNCH_MODE_BUILT_CLOSURE_AT_LAUNCH 0x00000002 // launch was slow, to build closure #define DYLD_LAUNCH_MODE_CLOSURE_SAVED_TO_FILE 0x00000004 // next launch will be faster #define DYLD_LAUNCH_MODE_CLOSURE_FROM_OS 0x00000008 // closure built into dyld cache #define DYLD_LAUNCH_MODE_MINIMAL_CLOSURE 0x00000010 // closure does not contain fix ups extern uint32_t _dyld_launch_mode(void); // // When dyld must terminate a process because of a required dependent dylib // could not be loaded or a symbol is missing, dyld calls abort_with_reason() // using one of the following error codes. // #define DYLD_EXIT_REASON_DYLIB_MISSING 1 #define DYLD_EXIT_REASON_DYLIB_WRONG_ARCH 2 #define DYLD_EXIT_REASON_DYLIB_WRONG_VERSION 3 #define DYLD_EXIT_REASON_SYMBOL_MISSING 4 #define DYLD_EXIT_REASON_CODE_SIGNATURE 5 #define DYLD_EXIT_REASON_FILE_SYSTEM_SANDBOX 6 #define DYLD_EXIT_REASON_MALFORMED_MACHO 7 #define DYLD_EXIT_REASON_OTHER 9 // // When it has more information about the termination, dyld will use abort_with_payload(). // The payload is a dyld_abort_payload structure. The fixed fields are offsets into the // payload for the corresponding string. If the offset is zero, that string is not available. // struct dyld_abort_payload { uint32_t version; // first version is 1 uint32_t flags; // 0x00000001 means dyld terminated at launch, backtrace not useful uint32_t targetDylibPathOffset; // offset in payload of path string to dylib that could not be loaded uint32_t clientPathOffset; // offset in payload of path string to image requesting dylib uint32_t symbolOffset; // offset in payload of symbol string that could not be found // string data }; typedef struct dyld_abort_payload dyld_abort_payload; // These global variables are implemented in libdyld.dylib // Old programs that used crt1.o also defined these globals. // The ones in dyld are not used when an old program is run. extern int NXArgc; extern const char** NXArgv; extern char** environ; // POSIX says this not const, because it pre-dates const extern const char* __progname; // called by libSystem_initializer only extern void _dyld_initializer(void); // never called from source code. Used by static linker to implement lazy binding extern void dyld_stub_binder(void) __asm__(\"dyld_stub_binder\"); // never call from source code. Used by closure builder to bind missing lazy symbols to extern void _dyld_missing_symbol_abort(void); // Called only by objc to see if dyld has uniqued this selector. // Returns the value if dyld has uniqued it, or nullptr if it has not. // Note, this function must be called after _dyld_objc_notify_register. // // Exists in Mac OS X 10.15 and later // Exists in iOS 13.0 and later extern const char* _dyld_get_objc_selector(const char* selName); // Called only by objc to see if dyld has pre-optimized classes with this name. // The callback will be called once for each class with the given name where // isLoaded is true if that class is in a binary which has been previously passed // to the objc load notifier. // Note you can set stop to true to stop iterating. // Also note, this function must be called after _dyld_objc_notify_register. // // Exists in Mac OS X 10.15 and later // Exists in iOS 13.0 and later extern void _dyld_for_each_objc_class(const char* className, void (^callback)(void* classPtr, bool isLoaded, bool* stop)); // Called only by objc to see if dyld has pre-optimized protocols with this name. // The callback will be called once for each protocol with the given name where // isLoaded is true if that protocol is in a binary which has been previously passed // to the objc load notifier. // Note you can set stop to true to stop iterating. // Also note, this function must be called after _dyld_objc_notify_register. // // Exists in Mac OS X 10.15 and later // Exists in iOS 13.0 and later extern void _dyld_for_each_objc_protocol(const char* protocolName, void (^callback)(void* protocolPtr, bool isLoaded, bool* stop)); // called by exit() before it calls cxa_finalize() so that thread_local // objects are destroyed before global objects. extern void _tlv_exit(void); typedef enum { dyld_objc_string_kind } DyldObjCConstantKind; // CF constants such as CFString's can be moved in to a contiguous range of // shared cache memory. This returns true if the given pointer is to an object of // the given kind. // // Exists in Mac OS X 10.16 and later // Exists in iOS 14.0 and later extern bool _dyld_is_objc_constant(DyldObjCConstantKind kind, const void* addr); // temp exports to keep tapi happy, until ASan stops using dyldVersionNumber extern double dyldVersionNumber; extern const char* dyldVersionString; #if __cplusplus } #endif /* __cplusplus */ #endif /* _MACH_O_DYLD_PRIV_H_ */ opensource-apple/dyld的mach-o/dyld_priv.h的内容 dyld/include/mach-o/dyld_priv.h at master · opensource-apple/dyld /* -*- mode: C++; c-basic-offset: 4; tab-width: 4 -*- * * Copyright (c) 2003-2010 Apple Inc. All rights reserved. * * @APPLE_LICENSE_HEADER_START@ * * This file contains Original Code and/or Modifications of Original Code * as defined in and that are subject to the Apple Public Source License * Version 2.0 (the 'License'). You may not use this file except in * compliance with the License. Please obtain a copy of the License at * http://www.opensource.apple.com/apsl/ and read it before using this * file. * * The Original Code and all software distributed under the License are * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES, * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. * Please see the License for the specific language governing rights and * limitations under the License. * * @APPLE_LICENSE_HEADER_END@ */ #ifndef _MACH_O_DYLD_PRIV_H_ #define _MACH_O_DYLD_PRIV_H_ #include #include #include #include #if __cplusplus extern \"C\" { #endif /* __cplusplus */ // // private interface between libSystem.dylib and dyld // extern int _dyld_func_lookup(const char* dyld_func_name, void **address); // // private interface between libSystem.dylib and dyld // extern void _dyld_fork_child(); // // Possible state changes for which you can register to be notified // enum dyld_image_states { dyld_image_state_mapped = 10, // No batch notification for this dyld_image_state_dependents_mapped = 20, // Only batch notification for this dyld_image_state_rebased = 30, dyld_image_state_bound = 40, dyld_image_state_dependents_initialized = 45, // Only single notification for this dyld_image_state_initialized = 50, dyld_image_state_terminated = 60 // Only single notification for this }; // // Callback that provides a bottom-up array of images // For dyld_image_state_[dependents_]mapped state only, returning non-NULL will cause dyld to abort loading all those images // and append the returned string to its load failure error message. dyld does not free the string, so // it should be a literal string or a static buffer // typedef const char* (*dyld_image_state_change_handler)(enum dyld_image_states state, uint32_t infoCount, const struct dyld_image_info info[]); // // Register a handler to be called when any image changes to the requested state. // If 'batch' is true, the callback is called with an array of all images that are in the requested state sorted by dependency. // If 'batch' is false, the callback is called with one image at a time as each image transitions to the the requested state. // During the call to this function, the handler may be called back with existing images and the handler should // not return a string, since there is no load to abort. In batch mode, existing images at or past the request // state supplied in the callback. In non-batch mode, the callback is called for each image exactly in the // requested state. // extern void dyld_register_image_state_change_handler(enum dyld_image_states state, bool batch, dyld_image_state_change_handler handler); // // Possible thread-local variable state changes for which you can register to be notified // enum dyld_tlv_states { dyld_tlv_state_allocated = 10, // TLV range newly allocated dyld_tlv_state_deallocated = 20 // TLV range about to be deallocated }; // // Info about thread-local variable storage. // typedef struct { size_t info_size; // sizeof(dyld_tlv_info) void * tlv_addr; // Base address of TLV storage size_t tlv_size; // Byte size of TLV storage } dyld_tlv_info; #if __BLOCKS__ // // Callback that notes changes to thread-local variable storage. // typedef void (^dyld_tlv_state_change_handler)(enum dyld_tlv_states state, const dyld_tlv_info *info); // // Register a handler to be called when a thread adds or removes storage for thread-local variables. // The registered handler will only be called from and on behalf of the thread that owns the storage. // The registered handler will NOT be called for any storage that was // already allocated before dyld_register_tlv_state_change_handler() was // called. Use dyld_enumerate_tlv_storage() to get that information. // Exists in Mac OS X 10.7 and later // extern void dyld_register_tlv_state_change_handler(enum dyld_tlv_states state, dyld_tlv_state_change_handler handler); // // Enumerate the current thread-local variable storage allocated for the current thread. // Exists in Mac OS X 10.7 and later // extern void dyld_enumerate_tlv_storage(dyld_tlv_state_change_handler handler); #endif // // get slide for a given loaded mach_header // Mac OS X 10.6 and later // extern intptr_t _dyld_get_image_slide(const struct mach_header* mh); // // get pointer to this process's dyld_all_image_infos // Exists in Mac OS X 10.4 and later through _dyld_func_lookup() // Exists in Mac OS X 10.6 and later through libSystem.dylib // const struct dyld_all_image_infos* _dyld_get_all_image_infos(); struct dyld_unwind_sections { const struct mach_header* mh; const void* dwarf_section; uintptr_t dwarf_section_length; const void* compact_unwind_section; uintptr_t compact_unwind_section_length; }; // // Returns true iff some loaded mach-o image contains \"addr\". // info->mh mach header of image containing addr // info->dwarf_section pointer to start of __TEXT/__eh_frame section // info->dwarf_section_length length of __TEXT/__eh_frame section // info->compact_unwind_section pointer to start of __TEXT/__unwind_info section // info->compact_unwind_section_length length of __TEXT/__unwind_info section // // Exists in Mac OS X 10.6 and later extern bool _dyld_find_unwind_sections(void* addr, struct dyld_unwind_sections* info); // // This is an optimized form of dladdr() that only returns the dli_fname field. // // Exists in Mac OS X 10.6 and later extern const char* dyld_image_path_containing_address(const void* addr); // // This is an optimized form of dladdr() that only returns the dli_fbase field. // Return NULL, if address is not in any image tracked by dyld. // // Exists in Mac OS X 10.11 and later extern const struct mach_header* dyld_image_header_containing_address(const void* addr); // Convienence constants for return values from dyld_get_sdk_version() and friends. #define DYLD_MACOSX_VERSION_10_4 0x000A0400 #define DYLD_MACOSX_VERSION_10_5 0x000A0500 #define DYLD_MACOSX_VERSION_10_6 0x000A0600 #define DYLD_MACOSX_VERSION_10_7 0x000A0700 #define DYLD_MACOSX_VERSION_10_8 0x000A0800 #define DYLD_MACOSX_VERSION_10_9 0x000A0900 #define DYLD_MACOSX_VERSION_10_10 0x000A0A00 #define DYLD_MACOSX_VERSION_10_11 0x000A0B00 #define DYLD_IOS_VERSION_2_0 0x00020000 #define DYLD_IOS_VERSION_2_1 0x00020100 #define DYLD_IOS_VERSION_2_2 0x00020200 #define DYLD_IOS_VERSION_3_0 0x00030000 #define DYLD_IOS_VERSION_3_1 0x00030100 #define DYLD_IOS_VERSION_3_2 0x00030200 #define DYLD_IOS_VERSION_4_0 0x00040000 #define DYLD_IOS_VERSION_4_1 0x00040100 #define DYLD_IOS_VERSION_4_2 0x00040200 #define DYLD_IOS_VERSION_4_3 0x00040300 #define DYLD_IOS_VERSION_5_0 0x00050000 #define DYLD_IOS_VERSION_5_1 0x00050100 #define DYLD_IOS_VERSION_6_0 0x00060000 #define DYLD_IOS_VERSION_6_1 0x00060100 #define DYLD_IOS_VERSION_7_0 0x00070000 #define DYLD_IOS_VERSION_7_1 0x00070100 #define DYLD_IOS_VERSION_8_0 0x00080000 #define DYLD_IOS_VERSION_8_1 0x00080100 #define DYLD_IOS_VERSION_8_2 0x00080200 #define DYLD_IOS_VERSION_9_0 0x00090000 // // This finds the SDK version a binary was built against. // Returns zero on error, or if SDK version could not be determined. // // Exists in Mac OS X 10.8 and later // Exists in iOS 6.0 and later extern uint32_t dyld_get_sdk_version(const struct mach_header* mh); // // This finds the SDK version that the main executable was built against. // Returns zero on error, or if SDK version could not be determined. // // Note on WatchOS, this returns the equivalent iOS SDK version number // (i.e an app built against WatchOS 2.0 SDK returne 9.0). To see the // platform specific sdk version use dyld_get_program_sdk_watch_os_version(). // // Exists in Mac OS X 10.8 and later // Exists in iOS 6.0 and later extern uint32_t dyld_get_program_sdk_version(); // Watch OS only. // This finds the Watch OS SDK version that the main executable was built against. // Exists in Watch OS 2.0 and later extern uint32_t dyld_get_program_sdk_watch_os_version(); // __WATCHOS_AVAILABLE(2.0); // // This finds the min OS version a binary was built to run on. // Returns zero on error, or if no min OS recorded in binary. // // Exists in Mac OS X 10.8 and later // Exists in iOS 6.0 and later extern uint32_t dyld_get_min_os_version(const struct mach_header* mh); // // This finds the min OS version the main executable was built to run on. // Returns zero on error, or if no min OS recorded in binary. // // Exists in Mac OS X 10.8 and later // Exists in iOS 6.0 and later extern uint32_t dyld_get_program_min_os_version(); // // Returns if any OS dylib has overridden its copy in the shared cache // // Exists in iPhoneOS 3.1 and later // Exists in Mac OS X 10.10 and later extern bool dyld_shared_cache_some_image_overridden(); // // Returns if the process is setuid or is code signed with entitlements. // // Exists in Mac OS X 10.9 and later extern bool dyld_process_is_restricted(); // // Returns path used by dyld for standard dyld shared cache file for the current arch. // // Exists in Mac OS X 10.11 and later extern const char* dyld_shared_cache_file_path(); // // for OpenGL to tell dyld it is ok to deallocate a memory based image when done. // // Exists in Mac OS X 10.9 and later #define NSLINKMODULE_OPTION_CAN_UNLOAD 0x20 // // Update all bindings on specified image. // Looks for uses of 'replacement' and changes it to 'replacee'. // NOTE: this is less safe than using static interposing via DYLD_INSERT_LIBRARIES // because the running program may have already copy the pointer values to other // locations that dyld does not know about. // struct dyld_interpose_tuple { const void* replacement; const void* replacee; }; extern void dyld_dynamic_interpose(const struct mach_header* mh, const struct dyld_interpose_tuple array[], size_t count); #if __cplusplus } #endif /* __cplusplus */ #endif /* _MACH_O_DYLD_PRIV_H_ */ crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-12 15:27:40 "},"dyld/func/dyld_api/dyld_priv_h/dyld_image_header_containing_address.html":{"url":"dyld/func/dyld_api/dyld_priv_h/dyld_image_header_containing_address.html","title":"dyld_image_header_containing_address","keywords":"","body":"dyld_image_header_containing_address 定义 dyld3/APIs.h const mach_header* dyld_image_header_containing_address(const void* addr) TEMP_HIDDEN; 引用 mach-o/dyld_priv.h// This is an optimized form of dladdr() that only returns the dli_fbase field. // Return NULL, if address is not in any image tracked by dyld. // // Exists in Mac OS X 10.11 and later extern const struct mach_header* dyld_image_header_containing_address(const void* addr); 实现 dyldAPIs.cppconst struct mach_header * dyld_image_header_containing_address(const void* address) { if ( dyld::gLogAPIs ) dyld::log(\"%s(%p)\\n\", __func__, address); address = stripPointer(address); #if SUPPORT_ACCELERATE_TABLES const mach_header* mh; const char* path; if ( dyld::addressInCache(address, &mh, &path) ) return mh; #endif ImageLoader* image = dyld::findImageContainingAddress(address); if ( image != NULL ) return image->machHeader(); return NULL; } APIs.cpp const mach_header* dyld_image_header_containing_address(const void* addr) { log_apis(\"dyld_image_header_containing_address(%p)\\n\", addr); addr = stripPointer(addr); const MachOLoaded* ml; if ( gAllImages.infoForImageMappedAt(addr, &ml, nullptr, nullptr) ) return ml; return nullptr; } dyldAPIsInLibSystem.cpp const struct mach_header* dyld_image_header_containing_address(const void* addr) { if ( gUseDyld3 ) return dyld3::dyld_image_header_containing_address(addr); DYLD_NO_LOCK_THIS_BLOCK; static const mach_header* (*p)(const void*) = NULL; if(p == NULL) _dyld_func_lookup(\"__dyld_get_image_header_containing_address\", (void**)&p); return p(addr); } 涉及到的地方 _os_log_impl 0x19c1d0b90 : bl 0x1996d0a00 ; symbol stub for: dyld_image_header_containing_address 0x19c1d0b94 : cbz x0, 0x19c1d0be0 ; 0x19c1d0b98 : add x2, sp, #0xe10 ; =0xe10 0x19c1d0b9c : adrp x1, 21 0x19c1d0ba0 : add x1, x1, #0x52d ; =0x52d 0x19c1d0ba4 : bl 0x19a0db874 ; symbol stub for: getsegmentdata 杂项 *_XXKitImage = dyld_image_header_containing_address(objc_getClass(\"UIView\")); *_CoreFoundationImage = dyld_image_header_containing_address(_CFArrayGetCount); crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-14 10:57:10 "},"dyld/func/dyld_api/dyld_priv_h/dyld_program_sdk_at_least.html":{"url":"dyld/func/dyld_api/dyld_priv_h/dyld_program_sdk_at_least.html","title":"dyld_program_sdk_at_least","keywords":"","body":"dyld_program_sdk_at_least 定义bool dyld_program_sdk_at_least(dyld_build_version_t version) 实现 APIs.cppbool dyld_program_sdk_at_least(dyld_build_version_t version) { return VersionSPIDispatcher::dyld_program_sdk_at_least(version); } 涉及到的地方 dyld_program_sdk_at_least CFNetwork`___lldb_unnamed_symbol941$$CFNetwork: -> 0x1820d22a8 : pacibsp ... 0x1820d242c : bl 0x1815c36c4 ; dyld_program_sdk_at_least ... crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-15 09:54:24 "},"dyld/func/dyld_api/dyld_priv_h/dyld_shared_cache_file_path.html":{"url":"dyld/func/dyld_api/dyld_priv_h/dyld_shared_cache_file_path.html","title":"dyld_shared_cache_file_path","keywords":"","body":"dyld_shared_cache_file_path 定义 const char* dyld_shared_cache_file_path() 实现 APIs.cpp const char* dyld_shared_cache_file_path() { log_apis(\"dyld_shared_cache_file_path()\\n\"); return gAllImages.dyldCachePath(); } crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-12 11:30:48 "},"dyld/func/dyld_api/dyld_priv_h/_dyld_get_all_image_infos.html":{"url":"dyld/func/dyld_api/dyld_priv_h/_dyld_get_all_image_infos.html","title":"_dyld_get_all_image_infos","keywords":"","body":"_dyld_get_all_image_infos 定义 dyld3/APIs.h const struct dyld_all_image_infos* _dyld_get_all_image_infos() TEMP_HIDDEN; mach-o/dyld_priv.h// get pointer to this process's dyld_all_image_infos // Exists in Mac OS X 10.4 and later through _dyld_func_lookup() // Exists in Mac OS X 10.6 and later through libSystem.dylib // const struct dyld_all_image_infos* _dyld_get_all_image_infos() __attribute__((deprecated)); 实现 dyldAPIs.cppconst struct dyld_all_image_infos* _dyld_get_all_image_infos() { return dyld::gProcessInfo; } APIs.cppconst struct dyld_all_image_infos* _dyld_get_all_image_infos() { return gAllImages.oldAllImageInfo(); } 相关 dyld_debug.c // SPI into dyld to get address of _dyld_get_all_image_infos data structure static const struct dyld_all_image_infos* dyld_get_all_image_infos() { static const struct dyld_all_image_infos* (*p)() = NULL; if ( p == NULL ) _dyld_func_lookup(\"__dyld_get_all_image_infos\", (void**)&p); if ( p != NULL ) return p(); else return NULL; } 用法举例 /* Example using struct dyld_all_image_infos */ #include #include #include #include #include int main(void) { int i; const struct dyld_all_image_infos *dyld_all_image_infos; dyld_all_image_infos = _dyld_get_all_image_infos(); for(i=0;iinfoArrayCount;i++) { printf(\"image: %s %d\\n\", dyld_all_image_infos->infoArray[i].imageFilePath, (int)dyld_all_image_infos->infoArray[i].imageFileModDate ); } return 0; } 涉及到地方 nm $ nm /usr/lib/system/libdyld.dylib | grep __dyld_get_all_image_infos 0000000000003479 t __dyld_get_all_image_infos libsubstrate.dylib libsubstrate.dylib`___lldb_unnamed_symbol14$$libsubstrate.dylib: 0x104449178 : stp x29, x30, [sp, #-0x10]! ... 0x1044491bc : b 0x104449270 ; 0x1044491c0 : bl 0x104458ab0 ; symbol stub for: _dyld_get_all_image_infos crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-12 11:39:32 "},"dyld/func/dyld_api/dyld_interposing_h/":{"url":"dyld/func/dyld_api/dyld_interposing_h/","title":"dyld-interposing.h","keywords":"","body":"dyld-interposing.h dyld-interposing.h头文件内容 举例： dyld-852.2 dyld-interposing.h /* * Copyright (c) 2005-2008 Apple Computer, Inc. All rights reserved. * * @APPLE_LICENSE_HEADER_START@ * * This file contains Original Code and/or Modifications of Original Code * as defined in and that are subject to the Apple Public Source License * Version 2.0 (the 'License'). You may not use this file except in * compliance with the License. Please obtain a copy of the License at * http://www.opensource.apple.com/apsl/ and read it before using this * file. * * The Original Code and all software distributed under the License are * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES, * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. * Please see the License for the specific language governing rights and * limitations under the License. * * @APPLE_LICENSE_HEADER_END@ */ #if !defined(_DYLD_INTERPOSING_H_) #define _DYLD_INTERPOSING_H_ /* * Example: * * static * int * my_open(const char* path, int flags, mode_t mode) * { * int value; * // do stuff before open (including changing the arguments) * value = open(path, flags, mode); * // do stuff after open (including changing the return value(s)) * return value; * } * DYLD_INTERPOSE(my_open, open) */ #define DYLD_INTERPOSE(_replacement,_replacee) \\ __attribute__((used)) static struct{ const void* replacement; const void* replacee; } _interpose_##_replacee \\ __attribute__ ((section (\"__DATA,__interpose\"))) = { (const void*)(unsigned long)&_replacement, (const void*)(unsigned long)&_replacee }; #endif crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-12 10:13:32 "},"dyld/func/dyld_api/dyld_interposing_h/dyld_interpose.html":{"url":"dyld/func/dyld_api/dyld_interposing_h/dyld_interpose.html","title":"DYLD_INTERPOSE","keywords":"","body":"DYLD_INTERPOSE DYLD_INTERPOSE 是什么：宏定义的函数 所属头文件：dyld-interposing.h 定义#define DYLD_INTERPOSE(_replacement,_replacee) \\ __attribute__((used)) static struct{ const void* replacement; const void* replacee; } _interpose_##_replacee \\ __attribute__ ((section (\"__DATA,__interpose\"))) = { (const void*)(unsigned long)&_replacement, (const void*)(unsigned long)&_replacee }; 用法举例 static int my_open(const char* path, int flags, mode_t mode){ int value; // do stuff before open (including changing the arguments) value = open(path, flags, mode); // do stuff after open (including changing the return value(s)) return value; } DYLD_INTERPOSE(my_open, open) 涉及到的内容 FDInterposing.cpp FDInterposing.cpp DYLD_INTERPOSE(__open_extended$__interposed__, __open_extended); fishhook facebook/fishhook fishhook is a very simple library that enables dynamically rebinding symbols in Mach-O binaries running on iOS in the simulator and on device. This provides functionality that is similar to using DYLD_INTERPOSE on OS X. At Facebook, we've found it useful as a way to hook calls in libSystem for debugging/tracing purposes (for example, auditing for double-close issues with file descriptors). crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-12 10:16:06 "},"dyld/func/other/":{"url":"dyld/func/other/","title":"其他函数","keywords":"","body":"其他函数 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-15 09:30:16 "},"dyld/func/other/start.html":{"url":"dyld/func/other/start.html","title":"start","keywords":"","body":"start dyld`start == dyld的函数start 典型流程 dyld的start开始 -> _objc_init函数加载（注册了load_images） -> 触发load_images函数 -> 触发+load方法 -> 在最后才调用main函数 -> 最终输出Hello World 涉及到的地方 最早的函数调用都是： dyld的start objc_msgSend (lldb) bt * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 79.1 * frame #0: 0x000000019c6dd000 libobjc.A.dylib`objc_msgSend frame #1: 0x00000001855ff3cc CoreFoundation`__CFRunLoopDoObservers + 160 frame #2: 0x00000001855fad10 CoreFoundation`__CFRunLoopRun + 1528 frame #3: 0x000000018560dd8c CoreFoundation`CFRunLoopRunSpecific + 572 frame #4: 0x000000019f71a9a0 GraphicsServices`GSEventRunModal + 160 frame #5: 0x0000000187e43018 UIKitCore`-[UIApplication _run] + 1080 frame #6: 0x0000000187bd729c UIKitCore`UIApplicationMain + 2060 frame #7: 0x0000000104990dd4 Preferences`___lldb_unnamed_symbol275 + 56 frame #8: 0x0000000104ce8190 dyld`start + 444 (lldb) bt * thread #1, queue = 'com.apple.main-thread' * frame #0: 0x000000019b901094 libobjc.A.dylib`objc_msgSend + 148 frame #1: 0x00000001870c2ef8 UIKitCore`+[UIFocusRingManager removeRingFromFocusItem:forClient:] + 124 ... frame #58: 0x0000000187067018 UIKitCore`-[UIApplication _run] + 1080 frame #59: 0x0000000186dfb29c UIKitCore`UIApplicationMain + 2060 frame #60: 0x0000000100da0dd4 Preferences`___lldb_unnamed_symbol275 + 56 frame #61: 0x0000000100f68190 dyld`start + 444 Preferences (lldb) bt * thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP * frame #0: 0x00000001bddf0b70 libsystem_kernel.dylib`mach_msg_trap + 8 frame #1: 0x00000001bddf1194 libsystem_kernel.dylib`mach_msg + 72 ... frame #6: 0x0000000187067018 UIKitCore`-[UIApplication _run] + 1080 frame #7: 0x0000000186dfb29c UIKitCore`UIApplicationMain + 2060 frame #8: 0x0000000100da0dd4 Preferences`___lldb_unnamed_symbol275 + 56 frame #9: 0x0000000100f68190 dyld`start + 444 Foundation (lldb) bt * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 74.1 * frame #0: 0x00000001822ea324 Foundation`_NSXPCDistantObjectSimpleMessageSend2 frame #1: 0x0000000192500700 AuthKit`-[AKAppleIDAuthenticationController authenticateWithContext:completion:] + 1032 frame #2: 0x00000001b17504cc AppleAccountUI`-[AAUISignInViewController _attemptAuthenticationWithContext:] + 360 ... frame #26: 0x000000018336b018 UIKitCore`-[UIApplication _run] + 1080 frame #27: 0x00000001830ff29c UIKitCore`UIApplicationMain + 2060 frame #28: 0x0000000104cdcdd4 Preferences`___lldb_unnamed_symbol275 + 56 frame #29: 0x00000001050c8190 dyld`start + 444 AKAppleIDAuthenticationController (lldb) bt * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 93.1 * frame #0: 0x0000000194509b14 AuthKit`-[AKAppleIDAuthenticationController authenticateWithContext:completion:] frame #1: 0x00000001af6315e4 AppleAccountUI`-[AAUISignInViewController _attemptAuthenticationWithContext:] + 408 ... frame #23: 0x00000001819d73b8 CoreFoundation`CFRunLoopRunSpecific + 600 frame #24: 0x000000019d36738c GraphicsServices`GSEventRunModal + 164 frame #25: 0x00000001843776a8 UIKitCore`-[UIApplication _run] + 1100 frame #26: 0x00000001840f67f4 UIKitCore`UIApplicationMain + 2092 frame #27: 0x0000000100cd8c0c Preferences`___lldb_unnamed_symbol132$$Preferences + 60 frame #28: 0x0000000100f89a24 dyld`start + 520 NSXPCConnection (lldb) bt * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 69.1 * frame #0: 0x0000000100b3f5b0 jailAppleAccount.dylib`_logos_method$_ungrouped$NSXPCConnection$remoteObjectProxyWithErrorHandler$(self=0x000000028317a440, _cmd=\"remoteObjectProxyWithErrorHandler:\", handler=0x0000000192500ab4) block_pointer) at jailAppleAccount.xm:34:16 frame #1: 0x0000000192500618 AuthKit`-[AKAppleIDAuthenticationController authenticateWithContext:completion:] + 800 frame #2: 0x00000001b17504cc AppleAccountUI`-[AAUISignInViewController _attemptAuthenticationWithContext:] + 360 ... frame #27: 0x00000001830ff29c UIKitCore`UIApplicationMain + 2060 frame #28: 0x0000000100900dd4 Preferences`___lldb_unnamed_symbol275 + 56 frame #29: 0x0000000100b98190 dyld`start + 444 (lldb) bt * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 59.1 * frame #0: 0x0000000183258094 Foundation`-[NSXPCConnection _sendSelector:withProxy:arg1:arg2:] frame #1: 0x000000018326cce8 Foundation`_NSXPCDistantObjectSimpleMessageSend2 + 76 frame #2: 0x0000000194509f7c AuthKit`-[AKAppleIDAuthenticationController authenticateWithContext:completion:] + 1128 ... frame #28: 0x00000001840f67f4 UIKitCore`UIApplicationMain + 2092 frame #29: 0x0000000104b98c0c Preferences`___lldb_unnamed_symbol132$$Preferences + 60 frame #30: 0x0000000104cb9a24 dyld`start + 520 (lldb) bt * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 70.1 * frame #0: 0x000000010320b3fc jailAppleAccount.dylib`_logos_method$_ungrouped$NSXPCConnection$_sendInvocation$orArguments$count$methodSignature$selector$withProxy$(self=0x0000000282798f00, _cmd=\"_sendInvocation:orArguments:count:methodSignature:selector:withProxy:\", incovaction=0x000000016d459b60, orArgs=0x0000000000000000, curCount=0, methodSig=0x9cc5d6b183e92d3f, sel=\"focusApplicationWithProcessIdentifier:sceneIdentity:stealingKeyboard:onCompletion:\", prxy=0x0000000283594690) at jailAppleAccount.xm:41:5 frame #1: 0x0000000180b43bc8 CoreFoundation`___forwarding___ + 652 ... frame #13: 0x000000018336b018 UIKitCore`-[UIApplication _run] + 1080 frame #14: 0x00000001830ff29c UIKitCore`UIApplicationMain + 2060 frame #15: 0x00000001029b0dd4 Preferences`___lldb_unnamed_symbol275 + 56 frame #16: 0x0000000102bd4190 dyld`start + 444 ACAccountCredential (lldb) bt * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 63.1 * frame #0: 0x0000000182226d54 Accounts`-[ACAccountCredential initWithPassword:] frame #1: 0x0000000102f4d2b0 jailAppleAccount.dylib`_logos_method$_ungrouped$ACAccountCredential$initWithPassword$(self=0x0000000281a74120, _cmd=\"initWithPassword:\", pwd=\"GdXoImGkepw1nVVrbSLp/ZbxkHXiDr6h8xBdF9BIc/5yDT+4UUvcAxdmVFKDNkXqM8H+AEgMTvV5QoHyn9nRN9tmEV25Bs0fOnLpPZkWuhrgPZNbMeZ2ZdTsjCMa1mAhUHQQt6Oo6CvPXUqvvv8dKfvs8OPkLgm8TnwtxIUCnLSUtWJCc7yqkRYf2Wc8k9uDllZNhmLZgXSO1Yxrq7JvdLNV3RXu8Pnq1ZyAjUmLX4Yu/lvA8ltT82FY9Rrta6IpBKks8YVBYtuPX6ymP8iAUw8g1NfaraWhrCCwIicOluZaxFXvW16dkb4bejEwazF340E6DzhEYPSbPk2TZrZfnOsn+rcN0cpjd1wfv6R/r1mA5WGmCkdMaJpXDonqzgbCBwLSftxeIJiePbiOD+TFdoifUGVYLo5mmooqCgDp+M+8G+gBCtfBOn0mwEtxcXQilCJLvKc=PET\") at jailAppleAccount.xm:91:24 frame #2: 0x0000000182226f6c Accounts`+[ACAccountCredential credentialWithPassword:] + 56 ... frame #22: 0x000000018336b018 UIKitCore`-[UIApplication _run] + 1080 frame #23: 0x00000001830ff29c UIKitCore`UIApplicationMain + 2060 frame #24: 0x0000000102c10dd4 Preferences`___lldb_unnamed_symbol275 + 56 frame #25: 0x0000000103000190 dyld`start + 444 (lldb) bt * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 61.1 * frame #0: 0x00000001821f0038 Accounts`-[ACAccountCredential credentialItemForKey:] frame #1: 0x0000000102f4d3e0 jailAppleAccount.dylib`_logos_method$_ungrouped$ACAccountCredential$credentialItemForKey$(self=0x0000000281a74120, _cmd=\"credentialItemForKey:\", curKey=\"rpassword\") at jailAppleAccount.xm:109:25 frame #2: 0x0000000192624da8 AppleAccount`-[ACAccount(AppleAccount_Internal) _aa_rawPassword] + 60 ... frame #22: 0x000000018336b018 UIKitCore`-[UIApplication _run] + 1080 frame #23: 0x00000001830ff29c UIKitCore`UIApplicationMain + 2060 frame #24: 0x0000000102c10dd4 Preferences`___lldb_unnamed_symbol275 + 56 frame #25: 0x0000000103000190 dyld`start + 444 AAPersonaUtility (lldb) bt * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 302.1 * frame #0: 0x000000019462b8d0 AppleAccount`+[AAPersonaUtility verifyAndFixPersonaIfNeeded:desiredContext:] frame #1: 0x00000001af631534 AppleAccountUI`-[AAUISignInViewController _attemptAuthenticationWithContext:] + 232 ... frame #26: 0x00000001840f67f4 UIKitCore`UIApplicationMain + 2092 frame #27: 0x0000000100ba4c0c Preferences`___lldb_unnamed_symbol132$$Preferences + 60 frame #28: 0x0000000100e99a24 dyld`start + 520 AAUISignInViewController (lldb) bt * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 121.1 * frame #0: 0x00000001af7149e0 AppleAccountUI`-[AAUISignInViewController _nextButtonSelected:] frame #1: 0x000000018440abf0 UIKitCore`-[UIApplication sendAction:to:from:forEvent:] + 100 ... frame #23: 0x00000001841da7f4 UIKitCore`UIApplicationMain + 2092 frame #24: 0x0000000104ed0c0c Preferences`___lldb_unnamed_symbol132$$Preferences + 60 frame #25: 0x0000000105271a24 dyld`start + 520 akd (lldb) bt * thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP * frame #0: 0x00000001bd808b70 libsystem_kernel.dylib`mach_msg_trap + 8 frame #1: 0x00000001bd809194 libsystem_kernel.dylib`mach_msg + 72 frame #2: 0x0000000184232ad0 CoreFoundation`__CFRunLoopServiceMachPort + 368 frame #3: 0x0000000184236bb8 CoreFoundation`__CFRunLoopRun + 1184 frame #4: 0x0000000184249d8c CoreFoundation`CFRunLoopRunSpecific + 572 frame #5: 0x0000000185988b6c Foundation`-[NSRunLoop(NSRunLoop) runMode:beforeDate:] + 232 frame #6: 0x00000001859892e0 Foundation`-[NSRunLoop(NSRunLoop) run] + 88 frame #7: 0x0000000102e255b8 akd`___lldb_unnamed_symbol900$$akd + 204 frame #8: 0x0000000103148190 dyld`start + 444 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-15 09:30:53 "},"dyld/func/other/_dyld_start.html":{"url":"dyld/func/other/_dyld_start.html","title":"_dyld_start","keywords":"","body":"_dyld_start dyld`_dyld_start == _dyld_start 反汇编代码 dyld`_dyld_start: 0x1045fd000 : mov x28, sp 0x1045fd004 : and sp, x28, #0xfffffffffffffff0 0x1045fd008 : mov x0, #0x0 0x1045fd00c : mov x1, #0x0 0x1045fd010 : stp x1, x0, [sp, #-0x10]! 0x1045fd014 : mov x29, sp 0x1045fd018 : sub sp, sp, #0x10 ; =0x10 0x1045fd01c : ldr x0, [x28] 0x1045fd020 : ldr x1, [x28, #0x8] 0x1045fd024 : add x2, x28, #0x10 ; =0x10 0x1045fd028 : adrp x3, -1 0x1045fd02c : add x3, x3, #0x0 ; =0x0 0x1045fd030 : mov x4, sp 0x1045fd034 : bl 0x1045fd07c ; dyldbootstrap::start(dyld3::MachOLoaded const*, int, char const**, dyld3::MachOLoaded const*, unsigned long*) -> 0x1045fd038 : mov x16, x0 0x1045fd03c : ldr x1, [sp] 0x1045fd040 : cmp x1, #0x0 ; =0x0 0x1045fd044 : b.ne 0x1045fd050 ; 0x1045fd048 : add sp, x28, #0x8 ; =0x8 0x1045fd04c : br x16 0x1045fd050 : mov x30, x1 0x1045fd054 : ldr x0, [x28, #0x8] 0x1045fd058 : add x1, x28, #0x10 ; =0x10 0x1045fd05c : add x2, x1, x0, lsl #3 0x1045fd060 : add x2, x2, #0x8 ; =0x8 0x1045fd064 : mov x3, x2 0x1045fd068 : ldr x4, [x3] 0x1045fd06c : add x3, x3, #0x8 ; =0x8 0x1045fd070 : cmp x4, #0x0 ; =0x0 0x1045fd074 : b.ne 0x1045fd068 ; 0x1045fd078 : br x16 Mac中： ➜ ~ lldb (lldb) process connect connect://192.168.0.58:20221 Process 10211 stopped * thread #1, stop reason = signal SIGSTOP frame #0: 0x0000000104b79000 dyld`_dyld_start dyld`_dyld_start: -> 0x104b79000 : mov x28, sp 0x104b79004 : and sp, x28, #0xfffffffffffffff0 0x104b79008 : mov x0, #0x0 0x104b7900c : mov x1, #0x0 Target 0: (Aweme) stopped. (lldb) 某次调试： dyld`_dyld_start: 0x1001b1000 : mov x28, sp 0x1001b1004 : and sp, x28, #0xfffffffffffffff0 0x1001b1008 : mov x0, #0x0 0x1001b100c : mov x1, #0x0 0x1001b1010 : stp x1, x0, [sp, #-0x10]! 0x1001b1014 : mov x29, sp 0x1001b1018 : sub sp, sp, #0x10 ; =0x10 0x1001b101c : ldr x0, [x28] 0x1001b1020 : ldr x1, [x28, #0x8] 0x1001b1024 : add x2, x28, #0x10 ; =0x10 0x1001b1028 : adrp x3, -1 0x1001b102c : add x3, x3, #0x0 ; =0x0 0x1001b1030 : mov x4, sp 0x1001b1034 : bl 0x1001b107c ; dyldbootstrap::start(dyld3::MachOLoaded const*, int, char const**, dyld3::MachOLoaded const*, unsigned long*) -> 0x1001b1038 : mov x16, x0 涉及到的地方 load方法 0 +[XXObject load] 1 call_class_loads() 2 call_load_methods 3 load_images 4 dyld::notifySingle(dyld_image_states, ImageLoader const*) 11 _dyld_start RzGame (lldb) bt * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 3.1 * frame #0: 0x000000010120b1f0 RzGame`___lldb_unnamed_symbol2674$$RzGame frame #1: 0x00000001078a61b8 dyld`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext const&) + 428 frame #2: 0x00000001078a658c dyld`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext const&) + 52 frame #3: 0x00000001078a15d0 dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&, unsigned int, char const*, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 548 frame #4: 0x00000001078a0334 dyld`ImageLoader::processInitializers(ImageLoader::LinkContext const&, unsigned int, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 184 frame #5: 0x00000001078a03fc dyld`ImageLoader::runInitializers(ImageLoader::LinkContext const&, ImageLoader::InitializerTimingList&) + 92 frame #6: 0x0000000107892420 dyld`dyld::initializeMainExecutable() + 216 frame #7: 0x0000000107896db4 dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 4616 frame #8: 0x0000000107891208 dyld`dyldbootstrap::start(dyld3::MachOLoaded const*, int, char const**, dyld3::MachOLoaded const*, unsigned long*) + 396 frame #9: 0x0000000107891038 dyld`_dyld_start + 56 AwemeCore (lldb) bt * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 17.1 * frame #0: 0x0000000118786f7c XxxTweak.dylib`_logos_meta_method$_ungrouped$TTMacroManager$isDebug(self=, _cmd=) at hook_aweme.xm:414:5 [opt] frame #1: 0x000000010956d818 AwemeCore`___lldb_unnamed_symbol142021$$AwemeCore + 28 ... frame #14: 0x000000010842c054 AwemeCore`+[AWELaunchMainPlaceholder load] + 84 frame #15: 0x00000001187872c8 MuJiaBaiHuoTweak.dylib`_logos_meta_method$_ungrouped$AWELaunchMainPlaceholder$load(self=AWELaunchMainPlaceholder, _cmd=\"load\") at hook_aweme.xm:457:5 [opt] frame #16: 0x000000018767c35c libobjc.A.dylib`load_images + 984 frame #17: 0x00000001025ba190 dyld`dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*) + 448 frame #18: 0x00000001025ca0d8 dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&, unsigned int, char const*, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 512 frame #19: 0x00000001025ca05c dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&, unsigned int, char const*, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 388 frame #20: 0x00000001025c8520 dyld`ImageLoader::processInitializers(ImageLoader::LinkContext const&, unsigned int, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 184 frame #21: 0x00000001025c85e8 dyld`ImageLoader::runInitializers(ImageLoader::LinkContext const&, ImageLoader::InitializerTimingList&) + 92 frame #22: 0x00000001025ba658 dyld`dyld::initializeMainExecutable() + 216 frame #23: 0x00000001025beeb0 dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 4400 frame #24: 0x00000001025b9208 dyld`dyldbootstrap::start(dyld3::MachOLoaded const*, int, char const**, dyld3::MachOLoaded const*, unsigned long*) + 396 frame #25: 0x00000001025b9038 dyld`_dyld_start + 56 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-15 09:30:48 "},"dyld/var/":{"url":"dyld/var/","title":"相关变量","keywords":"","body":"相关变量 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-03-20 10:11:52 "},"dyld/var/gprocessinfo.html":{"url":"dyld/var/gprocessinfo.html","title":"gProcessInfo","keywords":"","body":"gProcessInfo gProcessInfo 变量来源 dyld/dyld-dyld-1042.1/dyld/DebuggerSupport.cpp struct dyld_all_image_infos* gProcessInfo = &dyld_all_image_infos; 注： struct dyld_all_image_infos的定义详见 dyld_all_image_infos gProcessInfo的源码中的来源 至此，暂时没有彻底搞清楚： 此处的 iOS 15.1，iPhone11中的：/usr/lib/dyld 导出后，用IDA分析，确认版本是： dyld-932.4 然后对于其中的gProcessInfo： 参考dyld源码： dyld-852.2 函数定义=写法 dyld::gProcessInfo 编译为： __ZN4dyld12gProcessInfoE dyld-940 == dyld-1042.1 函数定义=写法 gProcessInfo 编译为： _gProcessInfo -》介于dyld-852.2和dyld-940之间的： dyld-932.4 要么是，旧的： dyld::gProcessInfo __ZN4dyld12gProcessInfoE 要么是，新的 gProcessInfo _gProcessInfo -》但是实际上（rabin2、jtool2）查看发现symbol中的gProcessInfo却是： __ZN5dyld412gProcessInfoE （demangle后）对应的是：dyld4::gProcessInfo 和上述的推断，都对不上 -》暂时不清楚根本原因是什么 而对于 https://opensource.apple.com/source/dyld/dyld-732.8 https://opensource.apple.com/source/dyld/dyld-733.6 中的 src/dyld_debugger.cpp 中的定义都是一样的： namespace dyld { struct dyld_all_image_infos* gProcessInfo = &dyld_all_image_infos; } 都是一样的 -》推断出：介于dyld-732.8和733.6的dyld-733.3.1，也是一样的 -》所以应该是： dyld-733.3.1 变量定义：dyld::gProcessInfo 编译生成：__ZN4dyld12gProcessInfoE ->是和前面的调试分析对的上的。 说明自己的理解也是对的，是没问题的。 涉及到的例子 register read (lldb) register read -f d General Purpose Registers: x0 = 1 x1 = 7208627091 \"ibclang_rt.tsan\" x2 = 16 x3 = -43 x4 = 65 x5 = 108 x6 = 0 x7 = 480 x8 = 4337565856 dyld`initialPoolContent + 96 x9 = 47 x10 = 4337565856 dyld`initialPoolContent + 96 x11 = 0 x12 = 83 x13 = 4294967277 x14 = 7208626807 \"NSDeallocateZombies\" x15 = 78 x16 = 7204937648 libsystem_platform.dylib`_platform_strncmp x17 = 4 x18 = 0 x19 = 7208627090 \"libclang_rt.tsan\" x20 = 596 x21 = 1 x22 = 4337565760 dyld`initialPoolContent x23 = 8498683904 CoreFoundation`_CFMachPortQueue.__CFMachPortQueue x24 = 8498679808 __CFRuntimeClassTable + 14384 x25 = 6135330952 x26 = 0 x27 = 6135299808 x28 = 4337551168 dyld::gProcessInfo fp = 6135297568 lr = 7208042740 CoreFoundation`_CFGetHandleForLoadedLibrary + 44 sp = 6135297536 pc = 7205967128 libdyld.dylib`_dyld_get_image_name cpsr = -2147483648 frida-core frida/frida-core/src/fruity/injector.vala private async void ensure_libsystem_initialized_for_dyld_v4_and_above (uint64 libdyld_initialize, Cancellable? cancellable) throws GLib.Error { uint64? process_info_ptr = dyld_symbols[\"_gProcessInfo\"]; if (process_info_ptr == null) throw new Error.UNSUPPORTED (\"Missing gProcessInfo\"); ... frida/frida-core/src/fruity/helpers/symbol-fetcher.c frida_fetch_dyld_symbols (char * output_buffer, const void * dyld_load_address) ... frida_str_equals (name, \"_gProcessInfo\") || mangled name iPhone11_151/dyld_rabin2_s_symbols.txt 2185 0x00064008 0x00064008 LOCAL FUNC 0 dyld4::gProcessInfo 其中的： dyld4::gProcessInfo 对应的转换之前的，编译后的，mangled name是： __ZN5dyld412gProcessInfoE crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-14 11:40:19 "},"dyld/definition/":{"url":"dyld/definition/","title":"相关定义","keywords":"","body":"相关定义 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-15 09:33:42 "},"dyld/definition/dyld_images_h/":{"url":"dyld/definition/dyld_images_h/","title":"dyld_images.h","keywords":"","body":"dyld_images.h dyld_images.h头文件内容 举例： dyld-852.2 dyld_images.h /* * Copyright (c) 2006-2010 Apple Inc. All rights reserved. * * @APPLE_LICENSE_HEADER_START@ * * This file contains Original Code and/or Modifications of Original Code * as defined in and that are subject to the Apple Public Source License * Version 2.0 (the 'License'). You may not use this file except in * compliance with the License. Please obtain a copy of the License at * http://www.opensource.apple.com/apsl/ and read it before using this * file. * * The Original Code and all software distributed under the License are * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES, * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. * Please see the License for the specific language governing rights and * limitations under the License. * * @APPLE_LICENSE_HEADER_END@ */ #ifndef _DYLD_IMAGES_ #define _DYLD_IMAGES_ #include #include #include #include #if defined(__cplusplus) && (BUILDING_LIBDYLD || BUILDING_DYLD) #include #endif #ifdef __cplusplus extern \"C\" { #endif /* * Beginning in Mac OS X 10.4, this is how gdb discovers which mach-o images are loaded in a process. * * gdb looks for the symbol \"_dyld_all_image_infos\" in dyld. It contains the fields below. * * For a snashot of what images are currently loaded, the infoArray fields contain a pointer * to an array of all images. If infoArray is NULL, it means it is being modified, come back later. * * To be notified of changes, gdb sets a break point on the address pointed to by the notificationn * field. The function it points to is called by dyld with an array of information about what images * have been added (dyld_image_adding) or are about to be removed (dyld_image_removing). * * The notification is called after infoArray is updated. This means that if gdb attaches to a process * and infoArray is NULL, gdb can set a break point on notification and let the proccess continue to * run until the break point. Then gdb can inspect the full infoArray. * * The dyldVersion field always points to a C string that contains the dyld version. For instance, * in dyld-127.3, dyldVersion would contain a pointer to \"127.3\". * * The errorMessage and terminationFlags fields are normally zero. If dyld terminates a process * (for instance because a required dylib or symbol is missing), then the errorMessage field will * be set to point to a C string message buffer containing the reason dyld terminate the process. * The low bit of the terminationFlags will be set if dyld terminated the process before any user * code ran, in which case there is no need for the crash log to contain the backtrace. * * When dyld terminates a process because some required dylib or symbol cannot be bound, in * addition to the errorMessage field, it now sets the errorKind field and the corresponding * fields: errorClientOfDylibPath, errorTargetDylibPath, errorSymbol. * */ enum dyld_image_mode { dyld_image_adding=0, dyld_image_removing=1, dyld_image_info_change=2 }; struct dyld_image_info { const struct mach_header* imageLoadAddress; /* base address image is mapped into */ const char* imageFilePath; /* path dyld used to load the image */ uintptr_t imageFileModDate; /* time_t of image file */ /* if stat().st_mtime of imageFilePath does not match imageFileModDate, */ /* then file has been modified since dyld loaded it */ }; struct dyld_uuid_info { const struct mach_header* imageLoadAddress; /* base address image is mapped into */ uuid_t imageUUID; /* UUID of image */ }; #define DYLD_AOT_IMAGE_KEY_SIZE 32 struct dyld_aot_image_info { const struct mach_header* x86LoadAddress; const struct mach_header* aotLoadAddress; const uint64_t aotImageSize; const uint8_t aotImageKey[DYLD_AOT_IMAGE_KEY_SIZE]; // uniquely identifying SHA-256 key for this aot }; struct dyld_aot_shared_cache_info { const uintptr_t cacheBaseAddress; uuid_t cacheUUID; }; typedef void (*dyld_image_notifier)(enum dyld_image_mode mode, uint32_t infoCount, const struct dyld_image_info info[]); /* for use in dyld_all_image_infos.errorKind field */ enum { dyld_error_kind_none=0, dyld_error_kind_dylib_missing=1, dyld_error_kind_dylib_wrong_arch=2, dyld_error_kind_dylib_version=3, dyld_error_kind_symbol_missing=4 }; /* internal limit */ #define DYLD_MAX_PROCESS_INFO_NOTIFY_COUNT 8 struct dyld_all_image_infos { uint32_t version; /* 1 in Mac OS X 10.4 and 10.5 */ uint32_t infoArrayCount; #if defined(__cplusplus) && (BUILDING_LIBDYLD || BUILDING_DYLD) std::atomic infoArray; #else const struct dyld_image_info* infoArray; #endif dyld_image_notifier notification; bool processDetachedFromSharedRegion; /* the following fields are only in version 2 (Mac OS X 10.6, iPhoneOS 2.0) and later */ bool libSystemInitialized; const struct mach_header* dyldImageLoadAddress; /* the following field is only in version 3 (Mac OS X 10.6, iPhoneOS 3.0) and later */ void* jitInfo; /* the following fields are only in version 5 (Mac OS X 10.6, iPhoneOS 3.0) and later */ const char* dyldVersion; const char* errorMessage; uintptr_t terminationFlags; /* the following field is only in version 6 (Mac OS X 10.6, iPhoneOS 3.1) and later */ void* coreSymbolicationShmPage; /* the following field is only in version 7 (Mac OS X 10.6, iPhoneOS 3.1) and later */ uintptr_t systemOrderFlag; /* the following field is only in version 8 (Mac OS X 10.7, iPhoneOS 3.1) and later */ uintptr_t uuidArrayCount; const struct dyld_uuid_info* uuidArray; /* only images not in dyld shared cache */ /* the following field is only in version 9 (Mac OS X 10.7, iOS 4.0) and later */ struct dyld_all_image_infos* dyldAllImageInfosAddress; /* the following field is only in version 10 (Mac OS X 10.7, iOS 4.2) and later */ uintptr_t initialImageCount; /* the following field is only in version 11 (Mac OS X 10.7, iOS 4.2) and later */ uintptr_t errorKind; const char* errorClientOfDylibPath; const char* errorTargetDylibPath; const char* errorSymbol; /* the following field is only in version 12 (Mac OS X 10.7, iOS 4.3) and later */ uintptr_t sharedCacheSlide; /* the following field is only in version 13 (Mac OS X 10.9, iOS 7.0) and later */ uint8_t sharedCacheUUID[16]; /* the following field is only in version 15 (macOS 10.12, iOS 10.0) and later */ uintptr_t sharedCacheBaseAddress; #if defined(__cplusplus) && (BUILDING_LIBDYLD || BUILDING_DYLD) // We want this to be atomic in libdyld so that we can see updates when we map it shared std::atomic infoArrayChangeTimestamp; #else uint64_t infoArrayChangeTimestamp; #endif const char* dyldPath; mach_port_t notifyPorts[DYLD_MAX_PROCESS_INFO_NOTIFY_COUNT]; #if __LP64__ uintptr_t reserved[13-(DYLD_MAX_PROCESS_INFO_NOTIFY_COUNT/2)]; #else uintptr_t reserved[13-DYLD_MAX_PROCESS_INFO_NOTIFY_COUNT]; #endif /* the following field is only in version 16 (macOS 10.13, iOS 11.0) and later */ uintptr_t compact_dyld_image_info_addr; size_t compact_dyld_image_info_size; uint32_t platform; // FIXME: really a dyld_platform_t, but those aren't exposed here. /* the following field is only in version 17 (macOS 10.16) and later */ uint32_t aotInfoCount; const struct dyld_aot_image_info* aotInfoArray; uint64_t aotInfoArrayChangeTimestamp; uintptr_t aotSharedCacheBaseAddress; uint8_t aotSharedCacheUUID[16]; }; /* * Beginning in Mac OS X 10.5, this is how gdb discovers where the shared cache is in a process. * Images that are in the shared cache have their segments rearranged, so when using imageFilePath * to load the file from disk, you have to know to adjust addresses based on how their segment * was rearranged. * * gdb looks for the symbol \"_dyld_shared_region_ranges\" in dyld. * * It contains information the count of shared regions used by the process. The count is * the number of start/length pairs. */ struct dyld_shared_cache_ranges { uintptr_t sharedRegionsCount; /* how many ranges follow */ struct { uintptr_t start; uintptr_t length; } ranges[4]; /* max regions */ }; extern struct dyld_shared_cache_ranges dyld_shared_cache_ranges __attribute__((visibility(\"hidden\"))); #ifdef __cplusplus } #endif #endif /* _DYLD_IMAGES_ */ crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-12 10:32:29 "},"dyld/definition/dyld_images_h/dyld_all_image_infos.html":{"url":"dyld/definition/dyld_images_h/dyld_all_image_infos.html","title":"dyld_all_image_infos","keywords":"","body":"dyld_all_image_infos dyld_all_image_infos = struct dyld_all_image_infos struct dyld_all_image_infos的定义 struct dyld_all_image_infos 定义 dyld/dyld-852.2/include/mach-o/dyld_images.h struct dyld_all_image_infos 旧：struct __attribute__((aligned(16))) dyld_all_image_infos libdyld/dyld_process_info_internal.h struct dyld_all_image_infos_32 struct dyld_all_image_infos_64 mach-o/dyld_images.h mach-o/dyld_images.h struct dyld_all_image_infos { uint32_t version; /* 1 in Mac OS X 10.4 and 10.5 */ uint32_t infoArrayCount; #if defined(__cplusplus) && (BUILDING_LIBDYLD || BUILDING_DYLD) std::atomic infoArray; #else const struct dyld_image_info* infoArray; #endif dyld_image_notifier notification; bool processDetachedFromSharedRegion; /* the following fields are only in version 2 (Mac OS X 10.6, iPhoneOS 2.0) and later */ bool libSystemInitialized; const struct mach_header* dyldImageLoadAddress; /* the following field is only in version 3 (Mac OS X 10.6, iPhoneOS 3.0) and later */ void* jitInfo; /* the following fields are only in version 5 (Mac OS X 10.6, iPhoneOS 3.0) and later */ const char* dyldVersion; const char* errorMessage; uintptr_t terminationFlags; /* the following field is only in version 6 (Mac OS X 10.6, iPhoneOS 3.1) and later */ void* coreSymbolicationShmPage; /* the following field is only in version 7 (Mac OS X 10.6, iPhoneOS 3.1) and later */ uintptr_t systemOrderFlag; /* the following field is only in version 8 (Mac OS X 10.7, iPhoneOS 3.1) and later */ uintptr_t uuidArrayCount; const struct dyld_uuid_info* uuidArray; /* only images not in dyld shared cache */ /* the following field is only in version 9 (Mac OS X 10.7, iOS 4.0) and later */ struct dyld_all_image_infos* dyldAllImageInfosAddress; /* the following field is only in version 10 (Mac OS X 10.7, iOS 4.2) and later */ uintptr_t initialImageCount; /* the following field is only in version 11 (Mac OS X 10.7, iOS 4.2) and later */ uintptr_t errorKind; const char* errorClientOfDylibPath; const char* errorTargetDylibPath; const char* errorSymbol; /* the following field is only in version 12 (Mac OS X 10.7, iOS 4.3) and later */ uintptr_t sharedCacheSlide; /* the following field is only in version 13 (Mac OS X 10.9, iOS 7.0) and later */ uint8_t sharedCacheUUID[16]; /* the following field is only in version 15 (macOS 10.12, iOS 10.0) and later */ uintptr_t sharedCacheBaseAddress; #if defined(__cplusplus) && (BUILDING_LIBDYLD || BUILDING_DYLD) // We want this to be atomic in libdyld so that we can see updates when we map it shared std::atomic infoArrayChangeTimestamp; #else uint64_t infoArrayChangeTimestamp; #endif const char* dyldPath; mach_port_t notifyPorts[DYLD_MAX_PROCESS_INFO_NOTIFY_COUNT]; #if __LP64__ uintptr_t reserved[13-(DYLD_MAX_PROCESS_INFO_NOTIFY_COUNT/2)]; #else uintptr_t reserved[13-DYLD_MAX_PROCESS_INFO_NOTIFY_COUNT]; #endif /* the following field is only in version 16 (macOS 10.13, iOS 11.0) and later */ uintptr_t compact_dyld_image_info_addr; size_t compact_dyld_image_info_size; uint32_t platform; // FIXME: really a dyld_platform_t, but those aren't exposed here. /* the following field is only in version 17 (macOS 10.16) and later */ uint32_t aotInfoCount; const struct dyld_aot_image_info* aotInfoArray; uint64_t aotInfoArrayChangeTimestamp; uintptr_t aotSharedCacheBaseAddress; uint8_t aotSharedCacheUUID[16]; }; dyld_process_info_internal.h struct dyld_all_image_infos_32 struct dyld_all_image_infos_64 -> libdyld/dyld_process_info_internal.h struct dyld_all_image_infos_32 { uint32_t version; uint32_t infoArrayCount; std::atomic infoArray; uint32_t notification; bool processDetachedFromSharedRegion; bool libSystemInitialized; uint32_t dyldImageLoadAddress; uint32_t jitInfo; uint32_t dyldVersion; uint32_t errorMessage; uint32_t terminationFlags; uint32_t coreSymbolicationShmPage; uint32_t systemOrderFlag; uint32_t uuidArrayCount; uint32_t uuidArray; uint32_t dyldAllImageInfosAddress; uint32_t initialImageCount; uint32_t errorKind; uint32_t errorClientOfDylibPath; uint32_t errorTargetDylibPath; uint32_t errorSymbol; uint32_t sharedCacheSlide; std::array sharedCacheUUID; uint32_t sharedCacheBaseAddress; std::atomic infoArrayChangeTimestamp; uint32_t dyldPath; uint32_t notifyMachPorts[8]; uint32_t reserved; uint64_t sharedCacheFSID; uint64_t sharedCacheFSObjID; uint32_t compact_dyld_image_info_addr; uint32_t compact_dyld_image_info_size; uint32_t platform; // the aot fields below will not be set in the 32 bit case uint32_t aotInfoCount; std::atomic aotInfoArray; uint64_t aotInfoArrayChangeTimestamp; uint64_t aotSharedCacheBaseAddress; std::array aotSharedCacheUUID[16]; }; struct dyld_all_image_infos_64 { uint32_t version; uint32_t infoArrayCount; std::atomic infoArray; uint64_t notification; bool processDetachedFromSharedRegion; bool libSystemInitialized; uint32_t paddingToMakeTheSizeCorrectOn32bitAndDoesntAffect64b; // NOT PART OF DYLD_ALL_IMAGE_INFOS! uint64_t dyldImageLoadAddress; uint64_t jitInfo; uint64_t dyldVersion; uint64_t errorMessage; uint64_t terminationFlags; uint64_t coreSymbolicationShmPage; uint64_t systemOrderFlag; uint64_t uuidArrayCount; uint64_t uuidArray; uint64_t dyldAllImageInfosAddress; uint64_t initialImageCount; uint64_t errorKind; uint64_t errorClientOfDylibPath; uint64_t errorTargetDylibPath; uint64_t errorSymbol; uint64_t sharedCacheSlide; std::array sharedCacheUUID; uint64_t sharedCacheBaseAddress; std::atomic infoArrayChangeTimestamp; uint64_t dyldPath; uint32_t notifyMachPorts[8]; uint64_t reserved[7]; uint64_t sharedCacheFSID; uint64_t sharedCacheFSObjID; uint64_t compact_dyld_image_info_addr; uint64_t compact_dyld_image_info_size; uint32_t platform; uint32_t aotInfoCount; std::atomic aotInfoArray; uint64_t aotInfoArrayChangeTimestamp; uint64_t aotSharedCacheBaseAddress; std::array aotSharedCacheUUID[16]; }; crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-12 10:37:52 "},"dyld/use_case/":{"url":"dyld/use_case/","title":"涉及的地方","keywords":"","body":"涉及的地方 libdyld.dylib相关 getsegmentdata (lldb) bt * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 24.1 * frame #0: 0x000000011a57de70 MuJiaBaiHuoTweak.dylib`_logos_function$_ungrouped$getsegmentdata(mhp=0x000000011a570000, segname=\"__TEXT\", size=0x000000016b097c80) at hook_machO.xm:32:27 [opt] frame #1: 0x000000019205c2e8 libsystem_trace.dylib`_os_log_impl_flatten_and_send + 1920 frame #2: 0x000000019205bb50 libsystem_trace.dylib`_os_log + 152 frame #3: 0x000000019205e184 libsystem_trace.dylib`_os_log_impl + 12 frame #4: 0x000000011a57e8c4 MuJiaBaiHuoTweak.dylib`_logosLocalCtor_f29c21d4(argc=, argv=, envp=) at hook_aweme.xm:618:9 [opt] frame #5: 0x00000001051872c4 dyld`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext const&) + 428 frame #6: 0x00000001051876b0 dyld`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext const&) + 52 frame #7: 0x00000001051820f0 dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&, unsigned int, char const*, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 536 frame #8: 0x0000000105180520 dyld`ImageLoader::processInitializers(ImageLoader::LinkContext const&, unsigned int, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 184 frame #9: 0x00000001051805e8 dyld`ImageLoader::runInitializers(ImageLoader::LinkContext const&, ImageLoader::InitializerTimingList&) + 92 frame #10: 0x0000000105175a64 dyld`dyld::runInitializers(ImageLoader*) + 88 frame #11: 0x000000010517c7b8 dyld`dlopen_internal + 832 frame #12: 0x00000001922ada08 libdyld.dylib`dlopen + 172 frame #13: 0x000000011bc4efd0 substitute-loader.dylib frame #14: 0x000000011bc4eff0 substitute-loader.dylib frame #15: 0x000000011bc4f010 substitute-loader.dylib frame #16: 0x000000011bc23168 substitute-loader.dylib frame #17: 0x000000011bb6484c substitute-loader.dylib frame #18: 0x000000011bb63b28 substitute-loader.dylib frame #19: 0x000000011bbae7b8 substitute-loader.dylib frame #20: 0x000000011bb680dc substitute-loader.dylib frame #21: 0x00000001051872c4 dyld`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext const&) + 428 frame #22: 0x00000001051876b0 dyld`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext const&) + 52 frame #23: 0x00000001051820f0 dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&, unsigned int, char const*, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 536 frame #24: 0x0000000105180520 dyld`ImageLoader::processInitializers(ImageLoader::LinkContext const&, unsigned int, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 184 frame #25: 0x00000001051805e8 dyld`ImageLoader::runInitializers(ImageLoader::LinkContext const&, ImageLoader::InitializerTimingList&) + 92 frame #26: 0x0000000105175a64 dyld`dyld::runInitializers(ImageLoader*) + 88 frame #27: 0x000000010517c7b8 dyld`dlopen_internal + 832 frame #28: 0x00000001922ada08 libdyld.dylib`dlopen + 172 frame #29: 0x000000010532d284 substitute-inserter.dylib`___lldb_unnamed_symbol385$$substitute-inserter.dylib + 1288 frame #30: 0x000000010563aac0 substitute-inserter.dylib`___lldb_unnamed_symbol1524$$substitute-inserter.dylib + 12 frame #31: 0x00000001055fb980 substitute-inserter.dylib`___lldb_unnamed_symbol1415$$substitute-inserter.dylib + 40580 frame #32: 0x00000001051872c4 dyld`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext const&) + 428 frame #33: 0x00000001051876b0 dyld`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext const&) + 52 frame #34: 0x00000001051820f0 dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&, unsigned int, char const*, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 536 frame #35: 0x0000000105180520 dyld`ImageLoader::processInitializers(ImageLoader::LinkContext const&, unsigned int, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 184 frame #36: 0x00000001051805e8 dyld`ImageLoader::runInitializers(ImageLoader::LinkContext const&, ImageLoader::InitializerTimingList&) + 92 frame #37: 0x0000000105172608 dyld`dyld::initializeMainExecutable() + 136 frame #38: 0x0000000105176eb0 dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 4400 frame #39: 0x0000000105171208 dyld`dyldbootstrap::start(dyld3::MachOLoaded const*, int, char const**, dyld3::MachOLoaded const*, unsigned long*) + 396 frame #40: 0x0000000105171038 dyld`_dyld_start + 56 dyldbootstrap::start dyldbootstrap::start(dyld3::MachOLoaded const*, int, char const**, dyld3::MachOLoaded const*, unsigned long*) _libdyld_initialize fromiPhone/dyld_rabin2_s_symbols.txt 330 0x0001596c 0x0001596c LOCAL FUNC 0 dyld4::APIs::_libdyld_initialize(dyld4::LibSystemHelpers const*) 意思是： 上面的函数 = C++代码中的函数的原始定义 dyld4::APIs::_libdyld_initialize(dyld4::LibSystemHelpers const*) 经过编译，最终会生成为： __ZN5dyld44APIs19_libdyld_initializeEPKNS_16LibSystemHelpersE __ZN5 dyld 44 APIs 19 _libdyld_initialize EPKNS_16 LibSystemHelpers E 杂项 (lldb) bt ... frame #3: 0x00000001922ac2e4 libdyld.dylib`LockHelper::LockHelper() + 28 frame #4: 0x00000001922ad780 libdyld.dylib`dladdr + 112 ... dyld相关函数 dyld`_main_thread MaskDylib ➜ DynamicLibraries rabin2 -i Mask.dylib > MaskDylib_rabin2_i_imports.txt -> MaskDylib_rabin2_i_imports.coffee 40 0x0000e49c NONE FUNC _dyld_get_image_header 41 0x0000e4a8 NONE FUNC _dyld_get_image_name 42 0x0000e4b4 NONE FUNC _dyld_image_count ... 50 0x0000e508 NONE FUNC dyld_shared_cache_file_path 调试Aweme statfs (lldb) image lookup -s statfs 1 symbols match 'statfs' in /Users/crifan/Library/Developer/Xcode/iOS DeviceSupport/13.3.1 (17D50)/Symbols/usr/lib/dyld: Address: dyld[0x000000000004c324] (dyld.__TEXT.__text + 308004) Summary: dyld`statfs64 1 symbols match 'statfs' in /Users/crifan/Library/Developer/Xcode/DerivedData/Aweme-fswcidjoxbkibsdwekuzlsfcdqls/Build/Products/Debug-iphoneos/Aweme.app/Frameworks/AwemeCore.framework/AwemeCore: ... /usr/lib/dyld 常见位置： /cores/dyld /usr/lib/dyld 常见逻辑 image list查看出的，加载的image镜像，看起来的总体逻辑都是： 先加载app自己 RzGame Aweme 然后就是dyld /cores/dyld /Users/crifan/Library/Developer/Xcode/iOS DeviceSupport/13.3.1 (17D50)/Symbols/usr/lib/dyld 涉及到的地方： iPhone8 iPhone8-150:~ root# ls -lh /usr/lib/ total 29M ... -rwxr-xr-x 1 root wheel 593K Sep 16 2021 dyld* debugserver Thread 0 name: Dispatch queue: com.apple.main-thread Thread 0 Crashed: 0 libsystem_kernel.dylib 0x1b8cca424 __execve + 8 1 libiosexec.1.dylib 0x104f75270 ie_execve + 32 2 bash.dylib 0x105302eac shell_execve + 56 ... 8 bash 0x104e0bb08 main + 180 9 dyld 0x105049a24 start + 520 Thread 0 crashed with ARM Thread State (64-bit): ... Binary Images: ... 0x105030000 - 0x105087fff dyld arm64e /usr/lib/dyld EOF Thread 0 name: Dispatch queue: com.apple.main-thread Thread 0 Crashed: 0 libsystem_kernel.dylib 0x1bba74f28 0x1bba70000 + 20264 ... 7 substitute-loader.dylib 0x10184d368 0x101618000 + 2315112 8 libiosexec.1.dylib 0x100c6d270 0x100c68000 + 21104 9 zsh 0x100ac9b4c 0x100aa4000 + 154444 ... 16 zsh 0x100add6d0 0x100aa4000 + 235216 17 dyld 0x100ee8190 0x100ed0000 + 98704 akd (lldb) image list -o -f [ 0] 0x0000000002df8000 /System/Library/PrivateFrameworks/AuthKit.framework/akd(0x0000000102df8000) [ 1] 0x0000000103130000 /cores/dyld(0x0000000103130000) ... (lldb) image list -o -f [ 0] 0x00000000045fc000 /System/Library/PrivateFrameworks/AuthKit.framework/akd(0x00000001045fc000) [ 1] 0x000000010495c000 /cores/dyld(0x000000010495c000) [ 2] 0x00000000012b4000 /Users/crifan/Library/Developer/Xcode/iOS DeviceSupport/15.0 (19A346)/Symbols/System/Library/Frameworks/Accounts.framework/Accounts ... (lldb) bt * thread #5, queue = 'PM Notifications', stop reason = EXC_BAD_ACCESS (code=50, address=0x10075b6f8) * frame #0: 0x000000010075b6f8 dyld`invocation function for block in dyld3::MachOFile::getUuid(unsigned char*) const frame #1: 0x0000000100729698 dyld`dyld3::MachOFile::forEachLoadCommand(Diagnostics&, void (load_command const*, bool&) block_pointer) const + 168 frame #2: 0x0000000100728c44 dyld`dyld3::MachOFile::getUuid(unsigned char*) const + 152 frame #3: 0x000000019c099880 libsystem_trace.dylib`_os_activity_stream_reflect + 228 ... RzGame (lldb) image list -o -f [ 0] 0x0000000000c04000 /Users/crifan/Library/Developer/Xcode/DerivedData/udg-cuzlxqfnklemxfexjbcfnupseasc/Build/Products/Debug-iphoneos/udg.app/RzGame [ 1] 0x0000000107890000 /Users/crifan/Library/Developer/Xcode/iOS DeviceSupport/13.3.1 (17D50)/Symbols/usr/lib/dyld ... Apple Store (lldb) image list -o -f [ 0] 0x0000000002900000 /Users/crifan/Library/Developer/Xcode/DerivedData/Jolly-fbcdzphrbokcgxhejxlslydrdyaa/Build/Products/Debug-iphoneos/Jolly.app/Apple Store [ 1] 0x00000001029c0000 /Users/crifan/Library/Developer/Xcode/iOS DeviceSupport/15.1 (19B74) arm64e/Symbols/usr/lib/dyld ... Preferences (lldb) image list -o -f [ 0] 0x0000000000b98000 /Applications/Preferences.app/Preferences(0x0000000100b98000) [ 1] 0x0000000100e80000 /Users/crifan/Library/Developer/Xcode/iOS DeviceSupport/15.1 (19B74) arm64e/Symbols/usr/lib/dyld ... (lldb) image list -o -f [ 0] 0x0000000000940000 /Applications/Preferences.app/Preferences(0x0000000100940000) [ 1] 0x0000000100d54000 /Users/crifan/Library/Developer/Xcode/iOS DeviceSupport/15.0 (19A346)/Symbols/usr/lib/dyld [ 2] 0x000000010149c000 /usr/lib/substitute-loader.dylib(0x000000010149c000) ... \"exception\" : {\"port\":78611,\"signal\":\"SIGKILL\",\"guardId\":0,\"codes\":\"0x0000000000013313, 0x0000000000000000\",\"violations\":[\"INVALID_NAME\"],\"message\":\" INVALID_NAME on mach port 78611 (guarded with 0x0000000000000000)\",\"subtype\":\"GUARD_TYPE_MACH_PORT\",\"type\":\"EXC_GUARD\",\"rawCodes\":[78611,0]}, \"termination\" : {\"namespace\":\"GUARD\",\"flags\":2,\"code\":2305845208237028115}, \"asi\" : {\"dyld\":[]}, \"faultingThread\" : 10, ... AppleStore (lldb) image lookup -vn initialize 1 match found in /Users/crifan/Library/Developer/Xcode/iOS DeviceSupport/15.1 (19B74) arm64e/Symbols/usr/lib/dyld: Address: dyld[0x000000000000afd0] (dyld.__TEXT.__text + 40912) Summary: dyld`dyld4::RuntimeState::initialize() Module: file = \"/Users/crifan/Library/Developer/Xcode/iOS DeviceSupport/15.1 (19B74) arm64e/Symbols/usr/lib/dyld\", arch = \"arm64e\" Symbol: id = {0x000000c7}, range = [0x00000001032b6fd0-0x00000001032b70bc), name=\"dyld4::RuntimeState::initialize()\", mangled=\"_ZN5dyld412RuntimeState10initializeEv\" Aweme iPhone7-137white:~ root# /var/containers/Bundle/Application/56FE26D5-2A62-48D1-B718-437E12731746/Aweme.app/Aweme dyld: loaded: /private/var/containers/Bundle/Application/56FE26D5-2A62-48D1-B718-437E12731746/Aweme.app/Aweme dyld: loaded: /usr/lib/substitute-inserter.dylib 。。。 dyld: loaded: /usr/lib/liblangid.dylib dyld: loaded: /usr/lib/libMobileGestalt.dylib dyld: loaded: /usr/lib/libnetwork.dylib iPhone7-137white:~ root# /var/containers/Bundle/Application/56FE26D5-2A62-48D1-B718-437E12731746/Aweme.app/Aweme dyld: loaded: /private/var/containers/Bundle/Application/56FE26D5-2A62-48D1-B718-437E12731746/Aweme.app/Aweme ... dyld: loaded: /usr/lib/system/libcommonCrypto.dylib (lldb) image list -o -f [ 0] 0x0000000004874000 /private/var/containers/Bundle/Application/9AB25481-0AD3-435C-A02E-68F9623535BB/Aweme.app/Aweme(0x0000000104874000) [ 1] 0x0000000104b78000 /Users/crifan/Library/Developer/Xcode/iOS DeviceSupport/13.4.1 (17E262)/Symbols/usr/lib/dyld ... (lldb) image list -o -f [ 0] 0x0000000004d58000 /Users/crifan/Library/Developer/Xcode/DerivedData/Aweme-ejnpzdlejfueeaffwupnpxokcaoj/Build/Products/Debug-iphoneos/Aweme.app/Aweme [ 1] 0x0000000105198000 /Users/crifan/Library/Developer/Xcode/iOS DeviceSupport/13.4.1 (17E262)/Symbols/usr/lib/dyld [ 2] 0x00000001056e4000 /Users/crifan/Library/Developer/Xcode/DerivedData/Aweme-ejnpzdlejfueeaffwupnpxokcaoj/Build/Products/Debug-iphoneos/Aweme.app/Frameworks/AwemeCore.framework/AwemeCore [ 3] 0x000000002d588000 /Users/crifan/Library/Developer/Xcode/iOS DeviceSupport/13.4.1 (17E262)/Symbols/System/Library/Frameworks/Foundation.framework/Foundation ... [ 0] 0x0000000004f28000 /Users/crifan/Library/Developer/Xcode/DerivedData/Aweme-ejnpzdlejfueeaffwupnpxokcaoj/Build/Products/Debug-iphoneos/Aweme.app/Aweme [ 1] 0x000000010529c000 /Users/crifan/Library/Developer/Xcode/iOS DeviceSupport/13.4.1 (17E262)/Symbols/usr/lib/dyld [ 2] 0x00000001057e8000 /Users/crifan/Library/Developer/Xcode/DerivedData/Aweme-ejnpzdlejfueeaffwupnpxokcaoj/Build/Products/Debug-iphoneos/Aweme.app/Frameworks/AwemeCore.framework/AwemeCore ... (lldb) image list -o -f [ 0] 0x00000000046b0000 /Users/crifan/Library/Developer/Xcode/DerivedData/Aweme-fswcidjoxbkibsdwekuzlsfcdqls/Build/Products/Debug-iphoneos/Aweme.app/Aweme [ 1] 0x0000000104a8c000 /Users/crifan/Library/Developer/Xcode/iOS DeviceSupport/13.3.1 (17D50)/Symbols/usr/lib/dyld [ 2] 0x0000000104fd8000 /Users/crifan/Library/Developer/Xcode/DerivedData/Aweme-fswcidjoxbkibsdwekuzlsfcdqls/Build/Products/Debug-iphoneos/Aweme.app/Frameworks/AwemeCore.framework/AwemeCore [ 3] 0x000000003d8c0000 /Users/crifan/Library/Developer/Xcode/iOS DeviceSupport/13.3.1 (17D50)/Symbols/System/Library/Frameworks/Foundation.framework/Foundation ... ___lldb_unnamed_symbol972 (lldb) image lookup -vs \"___lldb_unnamed_symbol972\" 1 symbols match '___lldb_unnamed_symbol972' in /cores/dyld: Address: dyld[0x000000000002d558] (dyld.__TEXT.__text + 181592) Summary: dyld`dyld3::OverflowSafeArray::push_back(dyld4::PrebuiltObjC::ObjCOptimizerImage::ObjCObject const&) Module: file = \"/cores/dyld\", arch = \"arm64\" Symbol: id = {0x000003cc}, range = [0x0000000102d71558-0x0000000102d7165c), name=\"dyld3::OverflowSafeArray::push_back(dyld4::PrebuiltObjC::ObjCOptimizerImage::ObjCObject const&)\", mangled=\"_ZN5dyld317OverflowSafeArrayIN5dyld412PrebuiltObjC18ObjCOptimizerImage10ObjCObjectELm4294967295EE9push_backERKS4_\" 其他 class-dump都有个dyld的版本的 /* * This header is generated by classdump-dyld 1.0 * on Thursday, January 25, 2018 at 11:23:05 PM Eastern European Standard Time * Operating System: Version 11.1.2 (Build 15B202) * Image Source: /System/Library/PrivateFrameworks/StoreServices.framework/StoreServices * classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos. */ ... pipenv ➜ crawler_miniprogram_duyaya git:(master) python --version dyld: Library not loaded: @executable_path/../.Python Referenced from: /Users/crifan/.local/share/virtualenvs/crawler_miniprogram_duyaya-tD_Ld6uE/bin/python Reason: image not found [1] 50513 abort python --version rsync sshpass -f /Users/crifan/dev/dev_root/ebook/honkit/honkit_template/common/config/deploy/deploy_server_password.txt /Users/crifan/dev/dev_tool/oldMac/rsync_oldMac -e \"/Users/crifan/dev/dev_tool/oldMac/ssh_oldMac -o 'ProxyCommand /Users/crifan/dev/dev_tool/oldMac/nc_oldMac -X 5 -x 127.0.0.1:58591 %h %p' -o ServerAliveInterval=30 -o ServerAliveCountMax=5\" -avzh --progress --stats --delete --force /Users/crifan/dev/dev_root/ebook/honkit/honkit_template/generated/books/cpu_emulator_unicorn/release/cpu_emulator_unicorn root@149.28.136.189:/data/wwwroot/book.crifan.org/books dyld[31214]: Library not loaded: /usr/local/opt/popt/lib/libpopt.0.dylib Referenced from: /Users/crifan/dev/dev_tool/oldMac/rsync_oldMac Reason: tried: '/usr/local/opt/popt/lib/libpopt.0.dylib' (no such file), '/System/Volumes/Preboot/Cryptexes/OS/usr/local/opt/popt/lib/libpopt.0.dylib' (no such file), '/usr/local/opt/popt/lib/libpopt.0.dylib' (no such file), '/usr/local/lib/libpopt.0.dylib' (no such file), '/usr/lib/libpopt.0.dylib' (no such file, not in dyld cache) make: *** [upload] Error 255 ccsha256 (lldb) im loo -rn \"ccsha256\" 2 matches found in /cores/dyld: Address: dyld[0x0000000000044930] (dyld.__TEXT.__text + 276784) Summary: dyld`ccsha256_vng_arm_compress Address: dyld[0x0000000000044b10] (dyld.__TEXT.__text + 277264) Summary: dyld`ccsha256_di -> dyld有很多函数： ccsha256_vng_arm_compress ccsha256_di dyld和iOS的程序的早期启动密切相关 iOS的越狱也会涉及到dyld 越狱中涉及到的dyld的内容有 palera1n patching dyld opening /usr/lib/dyld deploy /cores/dyld Cheyote dyld hook 进程csflags中也涉及到dyld ... #define CS_HARD 0x0000100 /* don't load invalid pages */ #define CS_KILL 0x0000200 /* kill process if it becomes invalid */ #define CS_RESTRICT 0x0000800 /* tell dyld to treat restricted */ #define CS_PLATFORM_BINARY 0x4000000 /* this is a platform binary */ ... flag定义 /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/Kernel.framework/Headers/kern/cs_blobs.h /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern/cs_blobs.h /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/Kernel.framework/Versions/Current/Headers/kern/cs_blobs.h /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.1.sdk/System/Library/Frameworks/Kernel.framework/Headers/kern/cs_blobs.h /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.1.sdk/System/Library/Frameworks/Kernel.framework/Versions/A/Headers/kern/cs_blobs.h /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.1.sdk/System/Library/Frameworks/Kernel.framework/Versions/Current/Headers/kern/cs_blobs.h #define CS_RESTRICT 0x00000800 /* tell dyld to treat restricted */ ... #define CS_NO_UNTRUSTED_HELPERS 0x02000000 /* kernel did not load a non-platform-binary dyld or Rosetta runtime */ #define CS_DYLD_PLATFORM CS_NO_UNTRUSTED_HELPERS /* old name */ #define CS_PLATFORM_BINARY 0x04000000 /* this is a platform binary */ ... cycript ➜ cycript_0.9.594 ./cycript --version dyld: Library not loaded: /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/libruby.2.0.0.dylib Referenced from: /Users/crifan/dev/DevTools/ios_reverse/Cycript/cycript_0.9.594/./Cycript.lib/cycript-apl Reason: image not found [1] 7655 abort ./cycript --version dyld_platform_t typedef uint32_t dyld_platform_t; typedef struct { dyld_platform_t platform; uint32_t version; } dyld_build_version_t; typedef bool (*AvailabilityVersionCheckFuncTy)(uint32_t count, dyld_build_version_t versions[]); com.apple.dyld ➜ 15555460490 pwd /Users/crifan/dev/DevTools/ios_reverse/抖音引流/越狱改机插件/佐罗/佐罗抖音账号包/20220213/15555460490 ➜ 15555460490 tree -L 8 . . └── var └── mobile └── Media └── ZORRO ├── 20220213-13-34-23 ... │ ├── com.ss.iphone.ugc.Aweme ... │ │ └── tmp │ │ ├── IMCustomStickerTemp │ │ ├── WebKit │ │ ├── bd539cd155d9c56950d5d3f1bb0a6fd2.zip_666423399139 │ │ ├── com.apple.dyld ... npm install npm install > zeromq@4.6.0 install /Users/limao/dev/crifan/mitmdump/mitmdumpUrlSaver/electron_python/electron-python-example/node_modules/zeromq ... checking dynamic linker characteristics... darwin18.7.0 dyld 杂项 四、代码注入 那么通过静态/动态的分析之后，我们虽然分析了大致的代码结构，定位了关键目标代码块。但如果我们想不仅仅是观察，更想对原代码原APP进行改动，这时就需要使用代码注入。常见的代码注入，基本都是通过hook的原理去做的。常见的hook工具有下面这几种： Logos Tweak: 使用logos语法（不要怕，语法很简单，看一眼就会），objc、C方法都可以hook。使用方法网上一大把，不过对于logos语法，最好先看一下iPhoneDevWiki上的介绍 CaptainHook: 可以用来hook objc方法 fishhook: 可以用来hook C方法 这三种工具当中，最常用的是logos。需要注意的是，这三种代码注入的方式，都是利用dyld机制实现的。所以无论是在越狱机，还是在非越狱机上都可以执行 dyld[1999]: missing symbol called The main attack vector for AMFI has historically been dyld, the dynamic loader. Indeed, the dynamic loader is in charge for mapping Mach-Os such as dylibs into a given address space. Segments in a Mach-O describe a section of said address space; memory protection flags are also described by Mach-O segments and applied by dyld. Dyld also enforces code signatures by requiring Mach-O load commands to be in a segment marked as executable (in function sniffLoadCommands) to counter against @comex's incomplete codesign; however there is a chicken-and-egg issue here; Load commands are themselves part of a segment, however segments aren't mapped until load commands are parsed. This means dyld just copies load commands on the stack (which is rw- memory and thus not codesign enforced), parses load commands and checks wether the load commands were in an executable segment or not; on failure, dyld abort()s. Once segments are mapped in, dyld page faults into each of the segments's pages (in function crashIfInvalidSignature), which finally validates both the load commands and segments. // ff 25 jmpq *symbol@DYLDMAGIC(%rip) By having a compiler emit a NO-OP instruction that can easily be checked, it eliminates the need for indirection through the DYLD stubs. 294 int shared_region_check_np(uint64_t *start_address bsd/vm/vm_unix.c Used excusively by dyld(1). load的调用： load方法的调用时机在dyld映射image时期，这也符合逻辑，加载完调用load 2. __stubs: 用于辅助做动态链接代码（dyld）. 3. __stub_helper:用于辅助做动态链接（dyld）. iOS Debugger + dyld: With the introduction of dyld-625 and the ARM64e architecture in iOS 12, Apple's dynamic linker has made some significant security-related upgrades. This, combined with the fact that (as of this writing) the dyld-625 source code hasn't been released yet, has made dyld an area of particular interest to reverse engineers. In this example we will use IDA to debug dyld itself, focusing on the logic that uses ARMv8.3-A PAC instructions to perform secure symbol bindings. Along the way we'll highlight some recent improvements to the debugger that have made this task a bit easier. hook代码 iOSDyldIntegrityBypass versx/iOSDyldIntegrityBypass: Guide and Tweak on how to bypass applications compiled with Integrity checks. Designed for Jailed Tweaks with Theos (github.com) crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-14 11:41:44 "},"dyld_libdyld/":{"url":"dyld_libdyld/","title":"libdyld.dylib","keywords":"","body":"libdyld.dylib libdyld.dylib 是什么：动态库 位置 /usr/lib/system/libdyld.dylib crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-15 09:59:08 "},"dyld_libdyld/man_page/":{"url":"dyld_libdyld/man_page/","title":"man page","keywords":"","body":"dyld的lib：man page dyld(3) BSD Library Functions Manual dyld(3) NAME _dyld_image_count, _dyld_get_image_header, _dyld_get_image_vmaddr_slide, _dyld_get_image_name, _dyld_register_func_for_add_image, _dyld_register_func_for_remove_image, NSVersionOfRunTimeLibrary, NSVersionOfLinkTimeLibrary _NSGetExecutablePath SYNOPSIS #include uint32_t _dyld_image_count(void); intptr_t _dyld_get_image_vmaddr_slide(uint32_t image_index); const char* _dyld_get_image_name(uint32_t image_index); void _dyld_register_func_for_add_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)); void _dyld_register_func_for_remove_image(void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)); int32_t NSVersionOfRunTimeLibrary(const char* libraryName); int32_t NSVersionOfLinkTimeLibrary(const char* libraryName); int _NSGetExecutablePath(char* buf, uint32_t* bufsize); DESCRIPTION These routines provide additional introspection of dyld beyond that pro-vided provided vided by dlopen() and dladdr() _dyld_image_count() returns the current number of images mapped in by dyld. Note that using this count to iterate all images is not thread safe, because another thread may be adding or removing images during the iteration. _dyld_get_image_header() returns a pointer to the mach header of the image indexed by image_index. If image_index isout of range, NULL is returned. _dyld_get_image_vmaddr_slide() returns the virtural memory address slide amount of the image indexed by image_index. If image_index is out of range zero is returned. _dyld_get_image_name() returns the name of the image indexed by image_index. The C-string continues to be owned by dyld and should not deleted. If image_index is out of range NULL is returned. _dyld_register_func_for_add_image() registers the specified function to be called when a new image is added (a bundle or a dynamic shared library) to the program. When this function is first registered it is called for once for each image that is currently part of the process. _dyld_register_func_for_remove_image() registers the specified function to be called when an image is removed (a bundle or a dynamic shared library) from the process. NSVersionOfRunTimeLibrary() returns the current_version number of the currently loaded dylib specifed by the libraryName. The libraryName parameter would be \"bar\" for /path/libbar.3.dylib and \"Foo\" for /path/Foo.framework/Versions/A/Foo. This function returns -1 if no such library is loaded. NSVersionOfLinkTimeLibrary() returns the current_version number that the main executable was linked against at build time. The libraryName param-eter parameter eter would be \"bar\" for /path/libbar.3.dylib and \"Foo\" for /path/Foo.framework/Versions/A/Foo. This function returns -1 if the main executable did not link against the specified library. _NSGetExecutablePath() copies the path of the main executable into the buffer buf. The bufsize parameter should initially be the size of the buffer. This function returns 0 if the path was successfully copied. It returns -1 if the buffer is not large enough, and * bufsize is set to the size required. Note that _NSGetExecutablePath() will return \"a path\" to the executable not a \"real path\" to the executable. That is, the path may be a symbolic link and not the real file. With deep directories the total bufsize needed could be more than MAXPATHLEN. SEE ALSO dlopen(3) dladdr(3) dyld(1) http://developer.apple.com/documenta- tion/DeveloperTools/Conceptual/MachOTopics/index.html August 16, 2006 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-15 09:54:49 "},"dyld_libdyld/func/":{"url":"dyld_libdyld/func/","title":"相关函数","keywords":"","body":"相关函数 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-15 09:54:20 "},"dyld_libdyld/func/dyld_stub_binder.html":{"url":"dyld_libdyld/func/dyld_stub_binder.html","title":"dyld_stub_binder","keywords":"","body":"dyld_stub_binder 代码实现在 dyld_stub_binder.s dyld/src/dyld_stub_binder.s at master · opensource-apple/dyld 反汇编代码 libdyld.dylib`dyld_stub_binder: -> 0x18d122dc0 : stp x29, x30, [sp, #-0x10]! 0x18d122dc4 : mov x29, sp 0x18d122dc8 : sub sp, sp, #0xf0 ; =0xf0 0x18d122dcc : stp x0, x1, [x29, #-0x10] 0x18d122dd0 : stp x2, x3, [x29, #-0x20] 0x18d122dd4 : stp x4, x5, [x29, #-0x30] 0x18d122dd8 : stp x6, x7, [x29, #-0x40] 0x18d122ddc : stp x8, x9, [x29, #-0x50] 0x18d122de0 : stp q0, q1, [x29, #-0x80] 0x18d122de4 : stp q2, q3, [x29, #-0xa0] 0x18d122de8 : stp q4, q5, [x29, #-0xc0] 0x18d122dec : stp q6, q7, [x29, #-0xe0] 0x18d122df0 : ldr x0, [x29, #0x18] 0x18d122df4 : ldr x1, [x29, #0x10] 0x18d122df8 : bl 0x18d1246e4 ; _dyld_fast_stub_entry(void*, long) 0x18d122dfc : mov x16, x0 0x18d122e00 : ldp x0, x1, [x29, #-0x10] 0x18d122e04 : ldp x2, x3, [x29, #-0x20] 0x18d122e08 : ldp x4, x5, [x29, #-0x30] 0x18d122e0c : ldp x6, x7, [x29, #-0x40] 0x18d122e10 : ldp x8, x9, [x29, #-0x50] 0x18d122e14 : ldp q0, q1, [x29, #-0x80] 0x18d122e18 : ldp q2, q3, [x29, #-0xa0] 0x18d122e1c : ldp q4, q5, [x29, #-0xc0] 0x18d122e20 : ldp q6, q7, [x29, #-0xe0] 0x18d122e24 : mov sp, x29 0x18d122e28 : ldp x29, x30, [sp], #0x10 0x18d122e2c : add sp, sp, #0x10 ; =0x10 0x18d122e30 : br x16 涉及到的例子 nm a.out $ nm a.out 0000000100002008 d __dyld_private 0000000100000000 T __mh_execute_header 0000000100000f50 T _main U _printf U dyld_stub_binder MachOView查看Undecember MachOView查看MusicallyCore nm Aweme ➜ Aweme.app nm Aweme U __dyld_register_func_for_add_image U _abort U _awemeMain U _dispatch_once_f U _dlsym U _free U _getsectiondata U _malloc U _memcmp U _memmove U _objc_getClass U _objc_lookUpClass U _objc_setHook_getClass U _posix_memalign U _pthread_mutex_init U _pthread_mutex_lock U _pthread_mutex_unlock U _realloc U _strcmp U _strlen U dyld_stub_binder 和： ➜ Aweme.app nm -um Aweme (undefined) external __dyld_register_func_for_add_image (from libSystem) (undefined) external _abort (from libSystem) (undefined) external _awemeMain (from AwemeCore) (undefined) external _dispatch_once_f (from libSystem) (undefined) external _dlsym (from libSystem) (undefined) external _free (from libSystem) (undefined) external _getsectiondata (from libSystem) (undefined) external _malloc (from libSystem) (undefined) external _memcmp (from libSystem) (undefined) external _memmove (from libSystem) (undefined) external _objc_getClass (from libobjc) (undefined) external _objc_lookUpClass (from libobjc) (undefined) weak external _objc_setHook_getClass (from libobjc) (undefined) external _posix_memalign (from libSystem) (undefined) external _pthread_mutex_init (from libSystem) (undefined) external _pthread_mutex_lock (from libSystem) (undefined) external _pthread_mutex_unlock (from libSystem) (undefined) external _realloc (from libSystem) (undefined) external _strcmp (from libSystem) (undefined) external _strlen (from libSystem) (undefined) external dyld_stub_binder (from libSystem) AwemeCore ➜ AwemeCore rabin2 -i ../../../../已脱壳/v18.9.0/Payload/Aweme.app/Frameworks/AwemeCore.framework/AwemeCore > AwemeCore_rabin2_i.txt -> 5028 0x00000000 NONE FUNC dyld_stub_binder 和nm输出结果一样： ➜ AwemeCore.framework nm AwemeCore > nm_AwemeCore.txt ... U dyld_stub_binder AppleSRP.tbd /Users/crifan/dev/dev_src/ios_reverse/AppleOpenSource/githubRepo/xybp888/iOS-SDKs/iPhoneOS14.5.sdk/System/Library/PrivateFrameworks/AppleSRP.framework/AppleSRP.tbd --- !tapi-tbd-v3 archs: [ armv7, armv7s, arm64, arm64e ] platform: ios flags: [ flat_namespace ] install-name: /System/Library/PrivateFrameworks/AppleSRP.framework/AppleSRP current-version: 1 compatibility-version: 1 exports: - archs: [ armv7, armv7s, arm64, arm64e ] symbols: [ _BigIntegerAdd, ... undefineds: - archs: [ armv7, armv7s, arm64, arm64e ] symbols: [ _CCBigNumAdd, ... _strlen, dyld_stub_binder ] Some Symbols 杂项 该地址指向的是__la_symbol_ptr节，而该节最终都指向了dyld_stub_binder。 和： 其实际内容都指向了_TEXT.stub_helper节，最终通过jumpq指令跳转到了dyld_stub_binder符号，即got节中的Non_Lazy Symbol Pointer中的条目，该符号为一个函数，定义于dyld_stub_binder.S，由 dyld 提供。 dyld_stub_binder函数其大致逻辑是：内部会寻找锁调用符号的真实地址，并写入_la_symbol_ptr条目中，然后跳转到真实地址执行； 和： __stub_helper:000000010000A394 LDR X16, =dyld_stub_binder __stub_helper:000000010000A398 BR X16 ; dyld_stub_binder 随后就会调用dyld_stub_binder函数进行符号绑定，这也是一个外部符号。当然你可能会说这样的话不就死循环了吗？其实不是，这个符号并不是lazy的即在初始化过程中就确定了地址。这里dyld_stub_binder的代码如下 libdyld.dylib`dyld_stub_binder: -> 0x181bccb64 : stp x29, x30, [sp, #-0x10]! ... 接着就是去调用dyld_stub_binder函数进行符号绑定，第一次找到该符号地址以后直接返回给调用处，并且将DATA,la_symbol_ptr中objc_msgSend的指针值更改为找到的符号地址。这样下一次就不会跳转到TEXT,stub_helper里面，而是直接跳转到正确的函数地址。__stub_helper:000000010000A384 ; Segment type: Pure code __stub_helper:000000010000A384 AREA __stub_helper, CODE, READWRITE __stub_helper:000000010000A384 ; ORG 0x10000A384 __stub_helper:000000010000A384 CODE64 __stub_helper:000000010000A384 ADR X17, off_10000C030 __stub_helper:000000010000A388 NOP __stub_helper:000000010000A38C STP X16, X17, [SP,#-0x10]! __stub_helper:000000010000A390 NOP __stub_helper:000000010000A394 LDR X16, =dyld_stub_binder __stub_helper:000000010000A398 BR X16 ; dyld_stub_binder crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-14 11:36:29 "},"related/":{"url":"related/","title":"相关内容","keywords":"","body":"相关内容 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-03-20 10:11:52 "},"related/getsect_h/":{"url":"related/getsect_h/","title":"getsect.h","keywords":"","body":"getsect.h 相关 头文件 cctools-895 getsect.h 具体实现 cctools-895 https://opensource.apple.com/source/cctools/cctools-895/libmacho/ getsecbyname.c getsegbyname.c hook代码相关 后续hook代码中，通用的调用了头文件： #import \"mach-o/getsect.h\" #import #import #import \"objc/runtime.h\" #import \"CommonConfig.h\" #import \"CrifanLibiOS.h\" #import \"CrifanLib.h\" #import \"JailbreakPathList.h\" 其中相关代码，详见： JailbreakPathList.h https://github.com/crifan/crifanLib/blob/master/c/JailbreakPathList.h CrifanLibiOS.h https://github.com/crifan/crifanLib/blob/master/iOS/CrifanLibiOS.h CrifanLib.h https://github.com/crifan/crifanLib/blob/master/c/CrifanLib.h man page GETSECTBYNAME(3) Library Functions Manual GETSECTBYNAME(3) NAME getsectbyname, getsectdata - get the section information for the named section SYNOPSIS #include const struct section *getsectbynamefromheader( const struct mach_header *mhp, const char *segname, const char *sectname) const struct section *getsectbyname( const char *segname, const char *sectname) char *getsectdatafromheader( const struct mach_header *mhp, const char *segname, const char *sectname, unsigned long *size) char *getsectdata( const char *segname, const char *sectname, unsigned long *size) char *getsectdatafromFramework( const char *FrameworkName, const char *segname, const char *sectname, unsigned long *size) DESCRIPTION Getsectbynamefromheader returns the section structure for the named section in the named segment if it exists in the specified Mach header otherwise it returns NULL. If the specified Mach header comes from a dynamic library as returned by _dyld_get_image_header(3) the addr field in the section structure will have to have _dyld_get_image_vmaddr_slide(3) added to it to make it a valid pointer. Getsectbyname is the same as getsectbynamefromheader with its first argument being the link editor defined symbol _mh_execute_header. Getsectdatafromheader returns the address to the data for the named section in the named segment if it exists in the specified Mach header. Also it returns the size of the section data indirectly through the pointer size. Otherwise it returns NULL for the pointer and zero for the size. If the specified Mach header comes from a dynamic library as returned by _dyld_get_image_header(3) the address to the data returned will have to have _dyld_get_image_vmaddr_slide(3) added to it to make it a valid pointer. Getsectdata is the same as getsectdatafromheader with its first argument being the link editor defined symbol _mh_execute_header. getsectdatafromFramework is used to get the named section data from the named Framework. For example, the framework name ``Appkit'' would be used for /System/Library/Frameworks/Appkit.framework/Versions/C/Appkit. If that Framework isn't being used by the program then it returns NULL for the pointer and zero for the size. SEE ALSO dyld(3), getsegbyname(3) Apple Computer, Inc. April 10, 1998 GETSECTBYNAME(3) getsect.h的内容 getsect.h /* * Copyright (c) 2004 Apple Computer, Inc. All rights reserved. * * @APPLE_LICENSE_HEADER_START@ * * This file contains Original Code and/or Modifications of Original Code * as defined in and that are subject to the Apple Public Source License * Version 2.0 (the 'License'). You may not use this file except in * compliance with the License. Please obtain a copy of the License at * http://www.opensource.apple.com/apsl/ and read it before using this * file. * * The Original Code and all software distributed under the License are * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES, * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. * Please see the License for the specific language governing rights and * limitations under the License. * * @APPLE_LICENSE_HEADER_END@ */ #ifndef _MACH_O_GETSECT_H_ #define _MACH_O_GETSECT_H_ #include #include #ifdef __cplusplus extern \"C\" { #endif /* __cplusplus */ /* * Runtime interfaces for Mach-O programs. For both 32-bit and 64-bit programs, * where the sizes returned will be 32-bit or 64-bit based on the size of * 'unsigned long'. */ extern char *getsectdata( const char *segname, const char *sectname, unsigned long *size); extern char *getsectdatafromFramework( const char *FrameworkName, const char *segname, const char *sectname, unsigned long *size); extern unsigned long get_end(void); extern unsigned long get_etext(void); extern unsigned long get_edata(void); #ifndef __LP64__ /* * Runtime interfaces for 32-bit Mach-O programs. */ extern const struct section *getsectbyname( const char *segname, const char *sectname); extern uint8_t *getsectiondata( const struct mach_header *mhp, const char *segname, const char *sectname, unsigned long *size); extern const struct segment_command *getsegbyname( const char *segname); extern uint8_t *getsegmentdata( const struct mach_header *mhp, const char *segname, unsigned long *size); #else /* defined(__LP64__) */ /* * Runtime interfaces for 64-bit Mach-O programs. */ extern const struct section_64 *getsectbyname( const char *segname, const char *sectname); extern uint8_t *getsectiondata( const struct mach_header_64 *mhp, const char *segname, const char *sectname, unsigned long *size); extern const struct segment_command_64 *getsegbyname( const char *segname); extern uint8_t *getsegmentdata( const struct mach_header_64 *mhp, const char *segname, unsigned long *size); #endif /* defined(__LP64__) */ /* * Interfaces for tools working with 32-bit Mach-O files. */ extern char *getsectdatafromheader( const struct mach_header *mhp, const char *segname, const char *sectname, uint32_t *size); extern const struct section *getsectbynamefromheader( const struct mach_header *mhp, const char *segname, const char *sectname); extern const struct section *getsectbynamefromheaderwithswap( struct mach_header *mhp, const char *segname, const char *sectname, int fSwap); /* * Interfaces for tools working with 64-bit Mach-O files. */ extern char *getsectdatafromheader_64( const struct mach_header_64 *mhp, const char *segname, const char *sectname, uint64_t *size); extern const struct section_64 *getsectbynamefromheader_64( const struct mach_header_64 *mhp, const char *segname, const char *sectname); extern const struct section *getsectbynamefromheaderwithswap_64( struct mach_header_64 *mhp, const char *segname, const char *sectname, int fSwap); #ifdef __cplusplus } #endif /* __cplusplus */ #endif /* _MACH_O_GETSECT_H_ */ crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-14 10:24:56 "},"related/getsect_h/getsectdata.html":{"url":"related/getsect_h/getsectdata.html","title":"getsectdata","keywords":"","body":"getsectdata 所属头文件: getsect.h 定义extern char *getsectdata( const char *segname, const char *sectname, unsigned long *size); Hook代码 #import \"mach-o/getsect.h\" #import #import #import \"objc/runtime.h\" /*============================================================================== Hook: getsectdata ==============================================================================*/ extern char* getsectdata(const char *segname, const char *sectname, unsigned long *size); %hookf(char*, getsectdata, const char *segname, const char *sectname, unsigned long *size){ char* sectDataStr = %orig; iosLogInfo(\"segname=%{public}s,sectname=%{public}s,*size=%lu -> sectDataStr=%s\", segname, sectname, *size, sectDataStr); return sectDataStr; } crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-09 22:58:56 "},"related/getsect_h/getsectdatafromframework.html":{"url":"related/getsect_h/getsectdatafromframework.html","title":"getsectdatafromFramework","keywords":"","body":"getsectdatafromFramework 所属头文件: getsect.h 定义extern char *getsectdatafromFramework( const char *FrameworkName, const char *segname, const char *sectname, unsigned long *size); Hook代码 #import \"mach-o/getsect.h\" #import #import #import \"objc/runtime.h\" /*============================================================================== Hook: getsectdatafromFramework ==============================================================================*/ char* getsectdatafromFramework(const char *FrameworkName, const char *segname, const char *sectname, unsigned long *size); %hookf(char *, getsectdatafromFramework, const char *FrameworkName, const char *segname, const char *sectname, unsigned long *size){ char* sectDataFrameworkStr = %orig; iosLogInfo(\"FrameworkName=%{public}s,segname=%{public}s,sectname=%{public}s,*size=%lu -> sectDataFrameworkStr=%s\", FrameworkName, segname, sectname, *size, sectDataFrameworkStr); return sectDataFrameworkStr; } crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-09 23:01:36 "},"related/getsect_h/getsectiondata.html":{"url":"related/getsect_h/getsectiondata.html","title":"getsectiondata","keywords":"","body":"getsectiondata 所属头文件: getsect.h 定义 32-bit Mach-O getsectiondataextern uint8_t *getsectiondata( const struct mach_header *mhp, const char *segname, const char *sectname, unsigned long *size); 64-bit Mach-O getsectiondataextern uint8_t *getsectiondata( const struct mach_header_64 *mhp, const char *segname, const char *sectname, unsigned long *size); Hook代码 #import \"mach-o/getsect.h\" #import #import #import \"objc/runtime.h\" /*============================================================================== Hook: getsectiondata ==============================================================================*/ extern uint8_t *getsectiondata( const struct mach_header_64 *mhp, const char *segname, const char *sectname, unsigned long *size); //extern uint8_t *getsectiondata( // const struct mach_header *mhp, // const char *segname, // const char *sectname, // unsigned long *size); %hookf(uint8_t*, getsectiondata, const struct mach_header_64 *mhp, const char *segname, const char *sectname, unsigned long *size){ iosLogDebug(\"mhp=%p,segname=%{public}s,sectname=%{public}s,size=%p\", mhp, segname, sectname, size); uint8_t* origRetIntP = %orig; if (cfgHookEnable_macho) { bool isJbLib = false; bool isShowLog = false; Dl_info info; size_t dlInfoSize = sizeof(Dl_info); memset(&info, 0, dlInfoSize); // dladdr(mhp, &info); void* hookedAddr = generateHookedDladdrAddress((void*)mhp); dladdr(hookedAddr, &info); const char* curImgName = info.dli_fname; if(curImgName != NULL) { isJbLib = isJailbreakDylib(curImgName); } if (isJbLib) { // isShowLog = true; if( size && (*size > 0) ) { isShowLog = true; //#ifdef XCODE_DEBUG // Note: MUST filter out following log, otherwise Aweme will crash // // getsectiondata: mhp=0x114af0000,segname=__TEXT,sectname=__swift5_replace,size=0x16fbf7df8 ===> *size=6169788088, curImgName=/Library/MobileSubstrate/DynamicLibraries/AppSyncUnified-FrontBoard.dylib, isJbLib=True if ( strstr(curImgName, \"AppSyncUnified\") && \\ (0==strcmp(segname, \"__TEXT\")) // ( (0==strcmp(sectname, \"__swift5_replace\")) || (0==strcmp(sectname, \"__swift5_types\")) ) \\ ) { isShowLog = false; } if (strstr(curImgName, \"XxxTweak\")) { isShowLog = false; } // \"/Library/MobileSubstrate/DynamicLibraries/ Choicy.dylib\" if (strstr(curImgName, \"Choicy\")) { isShowLog = false; } // /usr/lib/librocketbootstrap.dylib if (strstr(curImgName, \"librocketbootstrap\")) { isShowLog = false; } //#endif if (isShowLog) { iosLogInfo(\"mhp=%p,segname=%{public}s,sectname=%{public}s,size=%p ===> *size=%lu, curImgName=%{public}s, isJbLib=%s\", mhp, segname, sectname, size, size ? *size : 0, curImgName, boolToStr(isJbLib)); } } } if (isJbLib) { origRetIntP = NULL; if (NULL != size) { *size = 0; } } // if (NULL != size) { // if (*size > 0) { // isShowLog = true; // } // } // if (isShowLog) { // iosLogInfo(\"mhp=%p,segname=%{public}s,sectname=%{public}s,size=%p ===> *size=%lu, curImgName=%{public}s, isJbLib=%s\", mhp, segname, sectname, size, size ? *size : 0, curImgName, boolToStr(isJbLib)); // } } return origRetIntP; } 输出效果和举例： getsectiondata内部调用到了 dladdr，得到dylib库的原始信息，通过名字判断是越狱库，从而去hook掉了 默认 18:05:22.563411+0800 Aweme hook_aweme.xm _RxAnnotationInlineLoader$load: 默认 18:05:22.563558+0800 Aweme hook_dyld.xm _dyld_register_func_for_add_image: func=0x114c4ea84 默认 18:05:22.563673+0800 Aweme hook_misc.xm getsectiondata: mhp=0x1034b8000,segname=__DATA,sectname=RxAnnotation,size=0x16ce27fb0 ===> *size=4349803960, curImgName=/usr/lib/substitute-inserter.dylib, isJbLib=True 默认 18:05:22.563927+0800 Aweme hook_misc.xm NSClassFromString: aClassName=__RxApplicationServiceAnnotationSectionProcessor -> origRet=__RxApplicationServiceAnnotationSectionProcessor 默认 18:05:22.564013+0800 Aweme hook_misc.xm NSClassFromString: aClassName=__RxInjectorAnnotationSectionProcessor -> origRet=__RxInjectorAnnotationSectionProcessor 默认 18:05:22.709165+0800 Aweme hook_misc.xm getsectiondata: mhp=0x1172a0000,segname=__DATA,sectname=RxAnnotation,size=0x16ce27fb0 ===> *size=80, curImgName=/usr/lib/libsubstitute.dylib, isJbLib=True 默认 18:05:22.709268+0800 Aweme hook_misc.xm getsectiondata: mhp=0x1172a0000,segname=__DATA,sectname=RxAppService,size=0x16ce27fe8 ===> *size=49240, curImgName=/usr/lib/libsubstitute.dylib, isJbLib=True 默认 18:05:22.710563+0800 Aweme hook_dyld.xm _dyld_register_func_for_remove_image: func=0x114c4f0bc 另外，本身dladdr在别处被调用时，也会hook掉越狱的库： 默认 18:05:23.410387+0800 Aweme hook_dyld.xm _dyld_register_func_for_add_image: func=0x11187cc58 默认 18:05:23.410583+0800 Aweme hook_dylib.xm dladdr: addr=0x1034b8000 -> origRet=1 -> dli_fname=/usr/lib/substitute-inserter.dylib, dli_fbase=0x1034b8000, dli_sname=__dso_handle, dli_saddr=0x1034b8000 -> isJbDyib=True -> finalRet=0 默认 18:05:24.607409+0800 Aweme hook_dylib.xm dladdr: addr=0x1172a0000 -> origRet=1 -> dli_fname=/usr/lib/libsubstitute.dylib, dli_fbase=0x1172a0000, dli_sname=__dso_handle, dli_saddr=0x1172a0000 -> isJbDyib=True -> finalRet=0 默认 18:05:24.607573+0800 Aweme hook_dylib.xm dladdr: addr=0x118800000 -> origRet=1 -> dli_fname=/usr/lib/substitute-loader.dylib, dli_fbase=0x118800000, dli_sname=__dso_handle, dli_saddr=0x118800000 -> isJbDyib=True -> finalRet=0 默认 18:05:24.607649+0800 Aweme hook_dylib.xm dladdr: addr=0x1172cc000 -> origRet=1 -> dli_fname=/usr/lib/libsubstrate.dylib, dli_fbase=0x1172cc000, dli_sname=__dso_handle, dli_saddr=0x1172cc000 -> isJbDyib=True -> finalRet=0 默认 18:05:24.607769+0800 Aweme hook_dylib.xm dladdr: addr=0x1172e0000 -> origRet=1 -> dli_fname=/Library/MobileSubstrate/DynamicLibraries/AppSyncUnified-FrontBoard.dylib, dli_fbase=0x1172e0000, dli_sname=__dso_handle, dli_saddr=0x1172e0000 -> isJbDyib=True -> finalRet=0 默认 18:05:24.607829+0800 Aweme hook_dylib.xm dladdr: addr=0x117500000 -> origRet=1 -> dli_fname=/Library/MobileSubstrate/DynamicLibraries/MuJiaBaiHuoTweak.dylib, dli_fbase=0x117500000, dli_sname=__dso_handle, dli_saddr=0x117500000 -> isJbDyib=True -> finalRet=0 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-10 09:17:32 "},"related/getsect_h/getsectbyname.html":{"url":"related/getsect_h/getsectbyname.html","title":"getsectbyname","keywords":"","body":"getsectbyname 所属头文件: getsect.h 定义 32-bit Mach-O getsectbynameextern const struct section *getsectbyname( const char *segname, const char *sectname); 64-bit Mach-O getsectbynameextern const struct section_64 *getsectbyname( const char *segname, const char *sectname); Hook代码 #import \"mach-o/getsect.h\" #import #import #import \"objc/runtime.h\" /*============================================================================== Hook: getsectbyname ==============================================================================*/ const struct section_64* getsectbyname(const char *segname, const char *sectname); %hookf(const struct section_64*, getsectbyname, const char *segname, const char *sectname){ const struct section_64* retSection = %orig; iosLogInfo(\"segname=%{public}s,sectname=%{public}s -> retSection=%p\", segname, sectname, retSection); return retSection; } crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-09 22:57:50 "},"related/getsect_h/getsegbyname.html":{"url":"related/getsect_h/getsegbyname.html","title":"getsegbyname","keywords":"","body":"getsegbyname 所属头文件: getsect.h 定义 32-bit Mach-O getsegbynameextern const struct segment_command *getsegbyname( const char *segname); 64-bit Mach-O getsegbynameextern const struct segment_command_64 *getsegbyname( const char *segname); Hook代码 #import \"mach-o/getsect.h\" #import #import #import \"objc/runtime.h\" /*============================================================================== Hook: getsegbyname ==============================================================================*/ const struct segment_command_64* getsegbyname(const char *segname); %hookf(const struct segment_command_64*, getsegbyname, const char *segname){ const struct segment_command_64* retSegCmd = %orig; iosLogInfo(\"segname=%{public}s -> retSegCmd=%p\", segname, retSegCmd); return retSegCmd; } crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-09 22:57:57 "},"related/getsect_h/getsegmentdata.html":{"url":"related/getsect_h/getsegmentdata.html","title":"getsegmentdata","keywords":"","body":"getsegmentdata 所属头文件: getsect.h 定义 32-bit Mach-O getsegmentdataextern uint8_t *getsegmentdata( const struct mach_header *mhp, const char *segname, unsigned long *size); 64-bit Mach-O getsegmentdataextern uint8_t *getsegmentdata( const struct mach_header_64 *mhp, const char *segname, unsigned long *size); Hook代码 #import \"mach-o/getsect.h\" #import #import #import \"objc/runtime.h\" /*============================================================================== Hook: getsegmentdata ==============================================================================*/ // Note: if add log, Aweme will crash uint8_t* getsegmentdata(const struct mach_header_64 *mhp, const char *segname, unsigned long *size); %hookf(uint8_t*, getsegmentdata, const struct mach_header_64 *mhp, const char *segname, unsigned long *size){ // iosLogInfo(\"mhp=%p,segname=%{public}s,size=%p\", mhp, segname, size); uint8_t* retSegData = %orig; // iosLogInfo(\"mhp=%p,segname=%{public}s,*size=%lu -> retSegCmd=%p\", mhp, segname, *size, retSegData); return retSegData; } hook效果： 如果hook中加上log，会导致递归调用死循环，最终导致抖音崩溃 详见： 【未解决】XCode调试找原因：hook函数getsegmentdata会导致抖音崩溃 具体原因：未知 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-09 23:05:21 "},"related/getsect_h/getsectdatafromheader/":{"url":"related/getsect_h/getsectdatafromheader/","title":"getsectdatafromheader","keywords":"","body":"getsectdatafromheader 所属头文件: getsect.h 定义 32-bit Mach-O getsectdatafromheaderextern char *getsectdatafromheader( const struct mach_header *mhp, const char *segname, const char *sectname, uint32_t *size); crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-09 23:00:30 "},"related/getsect_h/getsectdatafromheader/getsectdatafromheader_64.html":{"url":"related/getsect_h/getsectdatafromheader/getsectdatafromheader_64.html","title":"getsectdatafromheader_64","keywords":"","body":"getsectdatafromheader_64 所属头文件: getsect.h 定义 64-bit Mach-O getsectdatafromheader_64extern char *getsectdatafromheader_64( const struct mach_header_64 *mhp, const char *segname, const char *sectname, uint64_t *size); Hook代码 #import \"mach-o/getsect.h\" #import #import #import \"objc/runtime.h\" /*============================================================================== Hook: getsectdatafromheader_64 ==============================================================================*/ char* getsectdatafromheader_64(const struct mach_header_64 *mhp, const char *segname, const char *sectname, uint64_t *size); %hookf(char*, getsectdatafromheader_64, const struct mach_header_64 *mhp, const char *segname, const char *sectname, uint64_t *size){ char* retSectDataStr = %orig; iosLogInfo(\"mhp=%p,segname=%{public}s,sectname=%{public}s,*size=%llu -> retSectData=%{public}s\", mhp, segname, sectname, *size, retSectDataStr); return retSectDataStr; } crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-09 23:01:04 "},"related/getsect_h/getsectbynamefromheader/":{"url":"related/getsect_h/getsectbynamefromheader/","title":"getsectbynamefromheader","keywords":"","body":"getsectbynamefromheader 所属头文件: getsect.h 定义 32-bit Mach-O getsectdatafromheaderextern const struct section *getsectbynamefromheader( const struct mach_header *mhp, const char *segname, const char *sectname); crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-09 22:54:33 "},"related/getsect_h/getsectbynamefromheader/getsectbynamefromheader_64.html":{"url":"related/getsect_h/getsectbynamefromheader/getsectbynamefromheader_64.html","title":"getsectbynamefromheader_64","keywords":"","body":"getsectbynamefromheader_64 所属头文件: getsect.h 定义 64-bit Mach-O getsectbynamefromheader_64extern const struct section_64 *getsectbynamefromheader_64( const struct mach_header_64 *mhp, const char *segname, const char *sectname); 反汇编代码 libmacho.dylib`getsectbynamefromheader_64: -> 0x1d939e44c : stp x28, x27, [sp, #-0x60]! 0x1d939e450 : stp x26, x25, [sp, #0x10] 0x1d939e454 : stp x24, x23, [sp, #0x20] 0x1d939e458 : stp x22, x21, [sp, #0x30] 0x1d939e45c : stp x20, x19, [sp, #0x40] 0x1d939e460 : stp x29, x30, [sp, #0x50] 0x1d939e464 : add x29, sp, #0x50 ; =0x50 0x1d939e468 : ldr w23, [x0, #0x10] 0x1d939e46c : cbz w23, 0x1d939e50c ; 0x1d939e470 : mov x19, x2 0x1d939e474 : mov x20, x1 0x1d939e478 : mov x21, x0 0x1d939e47c : mov w24, #0x0 0x1d939e480 : add x25, x0, #0x20 ; =0x20 0x1d939e484 : ldr w8, [x25] 0x1d939e488 : cmp w8, #0x19 ; =0x19 0x1d939e48c : b.ne 0x1d939e4f8 ; 0x1d939e490 : add x0, x25, #0x8 ; =0x8 0x1d939e494 : mov x1, x20 0x1d939e498 : orr w2, wzr, #0x10 0x1d939e49c : bl 0x1d93a19a8 ; symbol stub for: strncmp 0x1d939e4a0 : cbz w0, 0x1d939e4b0 ; 0x1d939e4a4 : ldr w8, [x21, #0xc] 0x1d939e4a8 : cmp w8, #0x1 ; =0x1 0x1d939e4ac : b.ne 0x1d939e4f8 ; 0x1d939e4b0 : ldr w26, [x25, #0x40] 0x1d939e4b4 : cbz w26, 0x1d939e4f8 ; 0x1d939e4b8 : mov w27, #0x0 0x1d939e4bc : add x22, x25, #0x48 ; =0x48 0x1d939e4c0 : mov x0, x22 0x1d939e4c4 : mov x1, x19 0x1d939e4c8 : orr w2, wzr, #0x10 0x1d939e4cc : bl 0x1d93a19a8 ; symbol stub for: strncmp 0x1d939e4d0 : cbnz w0, 0x1d939e4e8 ; 0x1d939e4d4 : add x0, x22, #0x10 ; =0x10 0x1d939e4d8 : mov x1, x20 0x1d939e4dc : orr w2, wzr, #0x10 0x1d939e4e0 : bl 0x1d93a19a8 ; symbol stub for: strncmp 0x1d939e4e4 : cbz w0, 0x1d939e510 ; 0x1d939e4e8 : add x22, x22, #0x50 ; =0x50 0x1d939e4ec : add w27, w27, #0x1 ; =0x1 0x1d939e4f0 : cmp w27, w26 0x1d939e4f4 : b.lo 0x1d939e4c0 ; 0x1d939e4f8 : ldr w8, [x25, #0x4] 0x1d939e4fc : add x25, x25, x8 0x1d939e500 : add w24, w24, #0x1 ; =0x1 0x1d939e504 : cmp w24, w23 0x1d939e508 : b.lo 0x1d939e484 ; 0x1d939e50c : mov x22, #0x0 0x1d939e510 : mov x0, x22 0x1d939e514 : ldp x29, x30, [sp, #0x50] 0x1d939e518 : ldp x20, x19, [sp, #0x40] 0x1d939e51c : ldp x22, x21, [sp, #0x30] 0x1d939e520 : ldp x24, x23, [sp, #0x20] 0x1d939e524 : ldp x26, x25, [sp, #0x10] 0x1d939e528 : ldp x28, x27, [sp], #0x60 0x1d939e52c : ret Hook代码 #import \"mach-o/getsect.h\" #import #import #import \"objc/runtime.h\" #import \"CommonConfig.h\" #import \"CrifanLibiOS.h\" #import \"CrifanLib.h\" #import \"JailbreakPathList.h\" const long DLADDR_HOOKED_ADDRESS_BASE = 0xF00000000000; //const unsigned long DLADDR_HOOKED_ADDRESS_MAX = 0xFFFF000000000000; void* generateHookedDladdrAddress(void *origAddr) { // if ((long)origAddr (long)DLADDR_HOOKED_ADDRESS_BASE) { hookedAddr = origAddr; } else { hookedAddr = (void*)((long)origAddr + DLADDR_HOOKED_ADDRESS_BASE); } return hookedAddr; } /*============================================================================== Hook: getsectbynamefromheader getsectbynamefromheader_64 ==============================================================================*/ // Not found: Aweme call getsectbynamefromheader //const struct section* getsectbynamefromheader(const struct mach_header *mhp, const char *segname, const char *sectname); // //%hookf(const struct section*, getsectbynamefromheader, const struct mach_header *mhp, const char *segname, const char *sectname){ // const struct section* retSection = %orig; // iosLogInfo(\"mhp=%p,segname=%{public}s,sectname=%{public}s -> retSection=%p\", mhp, segname, sectname, retSection); // return retSection; //} const struct section_64* getsectbynamefromheader_64(const struct mach_header_64 *mhp, const char *segname, const char *sectname); %hookf(const struct section_64 *, getsectbynamefromheader_64, const struct mach_header_64 *mhp, const char *segname, const char *sectname){ // const struct section_64* retSection64 = %orig; const struct section_64* retSection64 = %orig; bool isJbLib = false; Dl_info info; size_t dlInfoSize = sizeof(Dl_info); memset(&info, 0, dlInfoSize); // dladdr(mhp, &info); void* hookedAddr = generateHookedDladdrAddress((void*)mhp); dladdr(hookedAddr, &info); const char* curImgName = info.dli_fname; if(curImgName != NULL) { isJbLib = isJailbreakDylib(curImgName); } if (isJbLib) { iosLogInfo(\"mhp=%p,segname=%{public}s,sectname=%{public}s -> retSection64=%p -> isJbLib=%s\", mhp, segname, sectname, retSection64, boolToStr(isJbLib)); retSection64 = NULL; } else { iosLogDebug(\"mhp=%p,segname=%{public}s,sectname=%{public}s -> retSection64=%p\", mhp, segname, sectname, retSection64); } return retSection64; } hook输出举例： 有输出： 默认 17:06:43.506840+0800 Aweme hook_misc.xm getsectbynamefromheader_64: mhp=0x1b9243000,segname=__TEXT,sectname=__unwind_info -> retSection64=0x1b92432e8 默认 17:06:43.506874+0800 Aweme hook_misc.xm getsectbynamefromheader_64: mhp=0x1b9243000,segname=__TEXT,sectname=__eh_frame -> retSection64=0x0 默认 17:06:43.506901+0800 Aweme hook_misc.xm getsectbynamefromheader_64: mhp=0x1b9243000,segname=__DATA,sectname=__crash_info -> retSection64=0x0 默认 17:06:43.506983+0800 Aweme hook_misc.xm getsectbynamefromheader_64: mhp=0x1b9243000,segname=__TEXT,sectname=__unwind_info -> retSection64=0x1b92432e8 默认 17:06:43.507030+0800 Aweme hook_misc.xm getsectbynamefromheader_64: mhp=0x1b9243000,segname=__TEXT,sectname=__eh_frame -> retSection64=0x0 默认 17:06:43.510524+0800 Aweme hook_misc.xm getsectbynamefromheader_64: mhp=0x1b9243000,segname=__DATA,sectname=__crash_info -> retSection64=0x0 -》但是也只有这几个： __TEXT __unwind_info __eh_frame __DATA __crash_info crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-10 09:24:02 "},"related/getsect_h/getsectbynamefromheaderwithswap/":{"url":"related/getsect_h/getsectbynamefromheaderwithswap/","title":"getsectbynamefromheaderwithswap","keywords":"","body":"getsectbynamefromheaderwithswap 所属头文件: getsect.h 定义 32-bit Mach-O getsectbynamefromheaderwithswapextern const struct section *getsectbynamefromheaderwithswap( struct mach_header *mhp, const char *segname, const char *sectname, int fSwap); crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-09 22:54:11 "},"related/getsect_h/getsectbynamefromheaderwithswap/getsectbynamefromheaderwithswap_64.html":{"url":"related/getsect_h/getsectbynamefromheaderwithswap/getsectbynamefromheaderwithswap_64.html","title":"getsectbynamefromheaderwithswap_64","keywords":"","body":"getsectbynamefromheaderwithswap_64 所属头文件: getsect.h 定义 64-bit Mach-O getsectbynamefromheaderwithswap_64extern const struct section *getsectbynamefromheaderwithswap_64( struct mach_header_64 *mhp, const char *segname, const char *sectname, int fSwap); Hook代码 #import \"mach-o/getsect.h\" #import #import #import \"objc/runtime.h\" /*============================================================================== Hook: getsectbynamefromheaderwithswap_64 ==============================================================================*/ const struct section* getsectbynamefromheaderwithswap_64(struct mach_header_64 *mhp, const char *segname, const char *sectname, int fSwap); %hookf(const struct section*, getsectbynamefromheaderwithswap_64, struct mach_header_64 *mhp, const char *segname, const char *sectname, int fSwap){ const struct section* retSection = %orig; iosLogInfo(\"mhp=%p,segname=%{public}s,sectname=%{public}s,fSwap=%d -> retSection=%p\", mhp, segname, sectname, fSwap, retSection); return retSection; } crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-09 22:58:18 "},"related/dyld_env/":{"url":"related/dyld_env/","title":"DYLD环境变量","keywords":"","body":"相关环境变量 dyld相关环境变量 DYLD_LIBRARY_PATH DYLD_FRAMEWORK_PATH DYLD_PRINT_STATISTICS DYLD_PRINT_WARNINGS 注：文档中没标注，但实际存在 DYLD_PRINT_LIBRARIES DYLD_INSERT_LIBRARIES DYLD_IMAGE_SUFFIX DYLD_INTERPOSE 代码 尝试去基于普通的iOS的app： 旧：ShowSysInfo 新：crifan/iOSJailbreakDetection: iOS的ObjC的app，实现iOS越狱检测 相关：crifan/iOSBypassJailbreak: 越狱iOS的hook插件，实现反越狱检测 写代码去检测： const char* dyldEnvList[] = { \"DYLD_FRAMEWORK_PATH\", \"DYLD_FALLBACK_FRAMEWORK_PATH\", \"DYLD_VERSIONED_FRAMEWORK_PATH\", \"DYLD_LIBRARY_PATH\", \"DYLD_FALLBACK_LIBRARY_PATH\", \"DYLD_VERSIONED_LIBRARY_PATH\", \"DYLD_ROOT_PATH\", \"DYLD_SHARED_REGION\", \"DYLD_INSERT_LIBRARIES\", \"DYLD_FORCE_FLAT_NAMESPACE\", \"DYLD_IMAGE_SUFFIX\", \"DYLD_PRINT_OPTS\", \"DYLD_PRINT_ENV\", \"DYLD_PRINT_LIBRARIES\", \"DYLD_PRINT_LIBRARIES_POST_LAUNCH\", \"DYLD_BIND_AT_LAUNCH\", \"DYLD_NO_FIX_PREBINDING\", \"DYLD_DISABLE_DOFS\", \"DYLD_PRINT_APIS\", \"DYLD_PRINT_BINDINGS\", \"DYLD_PRINT_INITIALIZERS\", \"DYLD_PRINT_REBASINGS\", \"DYLD_PRINT_SEGMENTS\", \"DYLD_PRINT_STATISTICS\", \"DYLD_PRINT_DOFS\", \"DYLD_PRINT_RPATHS\", \"DYLD_SHARED_CACHE_DIR\", \"DYLD_SHARED_CACHE_DONT_VALIDATE\", }; const int dyldEnvListLen = sizeof(dyldEnvList)/sizeof(const char *); for(int curIdx = 0; curIdx %s\", curIdx, curDyldEnv, curEnvRet); } 输出： 2021-12-08 23:23:38.766182+0800 ShowSysInfo[2528:70589] dyld: [0] DYLD_FRAMEWORK_PATH -> (null) 2021-12-08 23:23:39.686564+0800 ShowSysInfo[2528:70589] dyld: [1] DYLD_FALLBACK_FRAMEWORK_PATH -> (null) 2021-12-08 23:23:40.358640+0800 ShowSysInfo[2528:70589] dyld: [2] DYLD_VERSIONED_FRAMEWORK_PATH -> (null) 2021-12-08 23:23:40.903442+0800 ShowSysInfo[2528:70589] dyld: [3] DYLD_LIBRARY_PATH -> /usr/lib/system/introspection 2021-12-08 23:23:44.232044+0800 ShowSysInfo[2528:70589] dyld: [4] DYLD_FALLBACK_LIBRARY_PATH -> (null) 2021-12-08 23:23:44.232767+0800 ShowSysInfo[2528:70589] dyld: [5] DYLD_VERSIONED_LIBRARY_PATH -> (null) 2021-12-08 23:23:44.233289+0800 ShowSysInfo[2528:70589] dyld: [6] DYLD_ROOT_PATH -> (null) 2021-12-08 23:23:44.233876+0800 ShowSysInfo[2528:70589] dyld: [7] DYLD_SHARED_REGION -> (null) 2021-12-08 23:23:44.236542+0800 ShowSysInfo[2528:70589] dyld: [8] DYLD_INSERT_LIBRARIES -> (null) 2021-12-08 23:23:44.237126+0800 ShowSysInfo[2528:70589] dyld: [9] DYLD_FORCE_FLAT_NAMESPACE -> (null) 2021-12-08 23:23:44.237587+0800 ShowSysInfo[2528:70589] dyld: [10] DYLD_IMAGE_SUFFIX -> (null) 2021-12-08 23:23:44.239169+0800 ShowSysInfo[2528:70589] dyld: [11] DYLD_PRINT_OPTS -> (null) 2021-12-08 23:23:44.239466+0800 ShowSysInfo[2528:70589] dyld: [12] DYLD_PRINT_ENV -> (null) 2021-12-08 23:23:44.239743+0800 ShowSysInfo[2528:70589] dyld: [13] DYLD_PRINT_LIBRARIES -> (null) 2021-12-08 23:23:44.240183+0800 ShowSysInfo[2528:70589] dyld: [14] DYLD_PRINT_LIBRARIES_POST_LAUNCH -> (null) 2021-12-08 23:23:44.240731+0800 ShowSysInfo[2528:70589] dyld: [15] DYLD_BIND_AT_LAUNCH -> (null) 2021-12-08 23:23:44.242577+0800 ShowSysInfo[2528:70589] dyld: [16] DYLD_NO_FIX_PREBINDING -> (null) 2021-12-08 23:23:44.242877+0800 ShowSysInfo[2528:70589] dyld: [17] DYLD_DISABLE_DOFS -> (null) 2021-12-08 23:23:44.243159+0800 ShowSysInfo[2528:70589] dyld: [18] DYLD_PRINT_APIS -> (null) 2021-12-08 23:23:44.244455+0800 ShowSysInfo[2528:70589] dyld: [19] DYLD_PRINT_BINDINGS -> (null) 2021-12-08 23:23:44.244745+0800 ShowSysInfo[2528:70589] dyld: [20] DYLD_PRINT_INITIALIZERS -> (null) 2021-12-08 23:23:44.245073+0800 ShowSysInfo[2528:70589] dyld: [21] DYLD_PRINT_REBASINGS -> (null) 2021-12-08 23:23:44.246477+0800 ShowSysInfo[2528:70589] dyld: [22] DYLD_PRINT_SEGMENTS -> (null) 2021-12-08 23:23:44.246814+0800 ShowSysInfo[2528:70589] dyld: [23] DYLD_PRINT_STATISTICS -> (null) 2021-12-08 23:23:44.247119+0800 ShowSysInfo[2528:70589] dyld: [24] DYLD_PRINT_DOFS -> (null) 2021-12-08 23:23:44.247715+0800 ShowSysInfo[2528:70589] dyld: [25] DYLD_PRINT_RPATHS -> (null) 2021-12-08 23:23:44.248359+0800 ShowSysInfo[2528:70589] dyld: [26] DYLD_SHARED_CACHE_DIR -> (null) 2021-12-08 23:23:44.248641+0800 ShowSysInfo[2528:70589] dyld: [27] DYLD_SHARED_CACHE_DONT_VALIDATE -> (null) 其中只有一个不是NULL的： [3] DYLD_LIBRARY_PATH -> /usr/lib/system/introspection 但是却又和越狱无关 -》无法利用来去做越狱检测 以及相关的： hook函数getenv /*============================================================================== Hook: getenv(DYLD_INSERT_LIBRARIES) ==============================================================================*/ char * getenv(const char* name); const char* DYLD_INSERT_LIBRARIES = \"DYLD_INSERT_LIBRARIES\"; %hookf(char *, getenv, const char* name){ // dyldInfo(\"name=%s\", name); // os_log(OS_LOG_DEFAULT, \"getenv: name=%s\", name); // NSLog(@\"getenv name\"); if (strStartsWith(name, \"DYLD_\")){ dyldInfo(\"getenv name=%s\", name); } // if(0 == strcmp(name, DYLD_INSERT_LIBRARIES)){ // return NULL; // } else { // return %orig; // } // char* getenvRetStr = %orig(name); char* getenvRetStr = %orig; if(0 == strcmp(name, DYLD_INSERT_LIBRARIES)){ iosLogInfo(\"name=%s -> getenvRetStr=%{public}s\", name, getenvRetStr); return NULL; } else { if (strStartsWith(name, \"DYLD_\")){ iosLogInfo(\"name=%s -> getenvRetStr=%{public}s\", name, getenvRetStr); return getenvRetStr; } else { return getenvRetStr; } } } 输出： 默认 09:12:46.358793+0800 Aweme hook_misc.xm getenv: DYLD_ name=DYLD_INSERT_LIBRARIES 默认 09:12:48.223953+0800 Aweme hook_misc.xm getenv: DYLD_ name=DYLD_IMAGE_SUFFIX 默认 09:12:48.223999+0800 Aweme hook_misc.xm getenv: name=DYLD_IMAGE_SUFFIX -> retEntValue=(null) 使用举例 Xcode中Allow DYLD Environment Variables sandbox沙箱 harden runtime强化运行时 -》 Xcode->Targets->Signing & Capabilities->Hardened Runtime Allow DYLD Environment Variables 作用 A Boolean value that indicates whether the app may be affected by dynamic linker environment variables, which you can use to inject code into your app’s process 对应的key：com.apple.security.cs.allow-dyld-environment-variables 效果 Xcode中相关参数 LD_DYLIB_INSTALL_NAME{ \"displayName\": \"Dynamic Library Install Name\", \"description\": \"Sets an internal `install path` (`LC_ID_DYLIB`) in a dynamic library. Any clients linked against the library will record that path as the way `dyld` should locate this library. If this option is not specified, then the `-o` path will be used. This setting is ignored when building any product other than a dynamic library. See [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html).\", \"name\": \"LD_DYLIB_INSTALL_NAME\" }, LD_RUNPATH_SEARCH_PATHS{ \"displayName\": \"Runpath Search Paths\", \"description\": \"This is a list of paths to be added to the `runpath` search path list for the image being created. At runtime, `dyld` uses the `runpath` when searching for dylibs whose load path begins with `@rpath/`. See [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html).\", \"name\": \"LD_RUNPATH_SEARCH_PATHS\" }, crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-11 09:56:55 "},"related/dyld_env/dyld_library_path.html":{"url":"related/dyld_env/dyld_library_path.html","title":"DYLD_LIBRARY_PATH","keywords":"","body":"DYLD_LIBRARY_PATH 下面整理涉及到DYLD_LIBRARY_PATH的相关内容： launchctl的参数 iPhone中launchctl的参数含义和典型用法 中的语法介绍： SUBCOMMANDS bootstrap domain-target [service-path service-path2 ...] | service-target ... --introspection-libraries Adds /usr/lib/system/introspection to the DYLD_LIBRARY_PATH environment variable for the service. This causes the system to prefer the introspection variants of libraries if they exist. AppleStore dyld4 config: DYLD_LIBRARY_PATH=/usr/lib/system/introspection ... 初始化Capstone $ export DYLD_LIBRARY_PATH=/usr/local/opt/capstone/lib/:$DYLD_LIBRARY_PATH -》去加到启动脚本中： ✘ crifan@licrifandeMacBook-Pro  ~  vi ~/.zshrc crifan@licrifandeMacBook-Pro  ~  cat ~/.zshrc | grep DYLD_LIBRARY_PATH export DYLD_LIBRARY_PATH=/usr/local/opt/capstone/lib/:/usr/local/opt/unicorn/lib/:$DYLD_LIBRARY_PATH crifan@licrifandeMacBook-Pro  ~  source ~/.zshrc crifan@licrifandeMacBook-Pro  ~  echo $DYLD_LIBRARY_PATH /usr/local/opt/capstone/lib/:/usr/local/opt/unicorn/lib/:/usr/local/opt/unicorn/lib/: Mac中安装unicorn crifan@licrifandeMacBook-Pro  ~  echo $DYLD_LIBRARY_PATH 此处DYLD_LIBRARY_PATH是空的。 去把 export DYLD_LIBRARY_PATH=/usr/local/opt/unicorn/lib/:$DYLD_LIBRARY_PATH 加到启动脚本，此处是.zshrc，中： ✘ crifan@licrifandeMacBook-Pro  ~  vi ~/.zshrc crifan@licrifandeMacBook-Pro  ~  source ~/.zshrc crifan@licrifandeMacBook-Pro  ~  cat ~/.zshrc | grep unicorn export DYLD_LIBRARY_PATH=/usr/local/opt/unicorn/lib/:$DYLD_LIBRARY_PATH 再去看看： crifan@licrifandeMacBook-Pro  ~  echo $DYLD_LIBRARY_PATH /usr/local/opt/unicorn/lib/: crifan@licrifandeMacBook-Pro  ~  which unicorn unicorn not found crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-09 10:34:50 "},"related/dyld_env/dyld_insert_libraries.html":{"url":"related/dyld_env/dyld_insert_libraries.html","title":"DYLD_INSERT_LIBRARIES","keywords":"","body":"DYLD_INSERT_LIBRARIES 下面整理涉及到DYLD_INSERT_LIBRARIES的相关内容： AppleStore dyld4 config: ... DYLD_INSERT_LIBRARIES=/Developer/usr/lib/libBacktraceRecording.dylib:/Developer/usr/lib/libMainThreadChecker.dylib:/Developer/Library/PrivateFrameworks/DTDDISupport.framework/libViewDebuggerSupport.dylib 砸壳Apple Store 去用刚编译好的arm64的dumpdecrypted.dylib去砸壳Apple Store，结果报错： iPhone11-151:~/dev root# DYLD_INSERT_LIBRARIES=/var/usr/lib/dumpdecrypted.dylib /var/containers/Bundle/Application/E892C046-2A14-44BC-90A6-748BE3D84E8D/Apple\\ Store.app/Apple\\ Store Killed: 9 AppleStore砸壳：dumpapp.com网站 AppleStore账号获取失败：替换Data目录 [AppleStoreCore.swift:90] AppleStoreCore - Failed creating local store dyld4 config: ... DYLD_INSERT_LIBRARIES=/Developer/usr/lib/libBacktraceRecording.dylib:/Developer/usr/lib/libMainThreadChecker.dylib:/Developer/Library/PrivateFrameworks/DTDDISupport.framework/libViewDebuggerSupport.dylib hook代码AKAnisetteProvisioningService dyld4 config: DYLD_INSERT_LIBRARIES=/var/lib/TweakInject.dylib *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '+[AKAnisetteProvisioningService fetchAnisetteDataAndProvisionIfNecessary:device:completion:]: unrecognized selector sent to class 0x104c9b100' terminating with uncaught exception of type NSException MonkeyDev调试app不崩溃却卡死禁用断点始终停在Foundation的NSString的stringByAppendingString // char* insertLibs = getenv(\"DYLD_INSERT_LIBRARIES\"); 别人提到的 iOS 11.3.1上使用bfinject注入dylib后的问题 - 技能讨论 - 睿论坛 (iosre.com) 再多问一句，我挺想知道原理的，为什么针对iOS自己的daemon（比如installed）的tweak里面可以直接使用MSHookFunction，是不是越狱工具会自动帮你提权？我大概跟踪了一下tweak的加载流程，先是通过DYLD_INSERT_LIBRARIES加载tweakloader，然后tweakloader会根据bundleid去dlopen对应的tweak dylib。似乎这个过程中没看到哪里有帮你提权的操作。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-09 10:39:05 "},"related/dyld_env/dyld_print_libraries.html":{"url":"related/dyld_env/dyld_print_libraries.html","title":"DYLD_PRINT_LIBRARIES","keywords":"","body":"DYLD_PRINT_LIBRARIES 调试时： export DYLD_PRINT_LIBRARIES=1 或： export DYLD_PRINT_LIBRARIES=YES 输出举例 举例1 dyld: loaded: /usr/lib/libiconv.2.dylib dyld: loaded: /System/Library/Frameworks/Security.framework/Versions/A/Security dyld: loaded: /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation dyld: loaded: /usr/lib/libz.1.dylib dyld: loaded: /usr/lib/libSystem.B.dylib dyld: loaded: /usr/lib/libresolv.9.dylib dyld: loaded: /usr/lib/system/libcache.dylib dyld: loaded: /usr/lib/system/libcommonCrypto.dylib dyld: loaded: /usr/lib/system/libcompiler_rt.dylib crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-09 10:41:57 "},"related/dyld_env/dyld_print_statistics.html":{"url":"related/dyld_env/dyld_print_statistics.html","title":"DYLD_PRINT_STATISTICS","keywords":"","body":"DYLD_PRINT_STATISTICS 用法举例 Xcode->Edit scheme -> Run -> Arguments -> DYLD_PRINT_STATISTICS=1 或者更详细地通过 DYLD_PRINT_STATISTICS_DETAILS=1 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-09 10:45:03 "},"related/dyld_env/dyld_image_suffix.html":{"url":"related/dyld_env/dyld_image_suffix.html","title":"DYLD_IMAGE_SUFFIX","keywords":"","body":"DYLD_IMAGE_SUFFIX DYLD_IMAGE_SUFFIX 是dyld的相关参数之一 常用值： DYLD_IMAGE_SUFFIX = _debug 作用是 想要调试一个Framework=动态库，比如叫：xxx.dylib 则：额外弄一个，带调试信息的，然后名字叫做 xxx_debug.dylib This is set to a string of a suffix to try to be used for all shared libraries used by the program. For libraries ending in \".dylib\" the suffix is applied just before the \".dylib\". For all other libraries the suffix is appended to the library name. This is useful for using conventional \"_profile\" and \"_debug\" libraries and frameworks. 涉及到的内容 下面整理涉及到DYLD_IMAGE_SUFFIX的相关内容： launchctl的参数 iPhone中launchctl的参数含义和典型用法 中的语法介绍： SUBCOMMANDS bootstrap domain-target [service-path service-path2 ...] | service-target ... --debug-libraries Sets the DYLD_IMAGE_SUFFIX for the service to \"_debug\", which prefers the debug variants of libraries if they exist. See dyld(1) for more information. crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-10 22:32:49 "},"related/dyld_env/dyld_print_apis.html":{"url":"related/dyld_env/dyld_print_apis.html","title":"DYLD_PRINT_APIS","keywords":"","body":"DYLD_PRINT_APIS 输出举例 _dyld_register_func_for_add_image(0x7fff7696ab92) _dyld_get_image_slide(0x1000f1000) _dyld_register_func_for_add_image(0x7fff7689cd98) _dyld_get_image_slide(0x1000f1000) _dyld_register_func_for_add_image(0x7fff76be67cb) dyld_image_path_containing_address(0x7fff75221000) ... crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-09 10:49:55 "},"related/dyld_env/dyld_print_warnings.html":{"url":"related/dyld_env/dyld_print_warnings.html","title":"DYLD_PRINT_WARNINGS","keywords":"","body":"DYLD_PRINT_WARNINGS 输出举例 dyld: found closure 0x7ffff48ae9ac (size=844) in dyld shared cache dyld: closure 0x7ffff48ae9ac not used because DYLD_FRAMEWORK_PATH changed crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-09 10:50:34 "},"related/tool/":{"url":"related/tool/","title":"相关工具","keywords":"","body":"相关工具 Mac中还有dyld相关工具： /usr/bin/ dyld_info dyld_usage crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-11 09:56:21 "},"related/tool/dyldinfo.html":{"url":"related/tool/dyldinfo.html","title":"dyldinfo","keywords":"","body":"dyldinfo dyldinfo 相关源码 dyldinfo.cpp ld64 https://opensource.apple.com/source/ld64/ld64-253.9/src/other/dyldinfo.cpp.auto.html dyld https://opensource.apple.com/source/dyld/dyld-852.2/dyld3/shared-cache/dyldinfo.cpp.auto.html man page dyldinfo(1) BSD General Commands Manual dyldinfo(1) NAME dyldinfo -- Displays information used by dyld in an executable SYNOPSIS dyldinfo [-arch arch-name] [-rebase] [-bind] [-weak_bind] [-lazy_bind] [-export] [-opcodes] file(s) DESCRIPTION Executables built for Mac OS X 10.6 and later have a new format for the information in the __LINKEDIT segment. The dyldinfo tool will dis- play that information. The options are as follows: -arch arch Only display the specified architecture. Other architectures in a universal image are ignored. -rebase Display the table of rebasing information. Rebasing is what dyld does when an image is not loaded at its preferred address. Typi- cally, this involves updating pointers in the __DATA segment which are point within the image. -bind Display the table of binding information. These are the symbolic fix ups that dyld must do when an image is loaded. -weak_bind Display the table of weak binding information. Typically, only C++ progams will have any weak binding. These are symbols which dyld must unique accross all images. -lazy_bind Display the table of lazy binding information. These are symbols which dyld delays binding until they are first used. Lazy binding is automatically used for all function calls to functions in some external dylib. -export Display the table symbols which this image exports. -opcodes Display the low level opcodes used to encode all rebase and binding information. SEE ALSO otool(1) nm(1) Darwin November 20, 2008 Darwin 涉及到的例子 Xcode中内部有dyldinfo ➜ ~ ll /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin 。。。 -rwxr-xr-x 1 root wheel 497K 9 3 05:16 dyldinfo nm ➜ nm --help --add-dyldinfo - Add symbols from the dyldinfo not already in the symbol table, Mach-O only --dyldinfo-only - Show only symbols from the dyldinfo, Mach-O only --no-dyldinfo - Don't add any symbols from the dyldinfo, Mach-O only crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-15 10:58:20 "},"related/mach_o/":{"url":"related/mach_o/","title":"Mach-O中Load Command","keywords":"","body":"Mach-O中Load Command Mach-O中有关dyld的内容 Header的flag MH_DYLDLINK LC_开头的dyld相关的Load Command LC_DYLD_CHAINED_FIXUPS LC_DYLD_EXPORTS_TRIE LC_LOAD_DYLINKER /usr/lib/dyld LC_DYLD_INFO LC_DYLD_INFO_ONLY LC_DYLD_ENVIRONMENT 涉及到的地方 /usr/lib/dyld akd rabin2 crifan@licrifandeMacBook-Pro  AppleStore/AuthKit_akd/AuthKit.framework  rabin2 -I akd > akd_rabin2_I_identification.txt -> akd_rabin2_I_identification.txt intrp /usr/lib/dyld Preferences rabin2 Preferences_rabin2_I_identification.coffee intrp /usr/lib/dyld Undecember RzGame_rabin2_I_identification.coffee intrp /usr/lib/dyld crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-10 10:13:41 "},"related/mach_o/define/":{"url":"related/mach_o/define/","title":"详细定义","keywords":"","body":"详细定义 Load Command定义 LC_REQ_DYLD = 0x8000_0000 After MacOS X 10.1 when a new load command is added that is required to be understood by the dynamic linker for the image to execute properly the LC_REQ_DYLD bit will be or'ed into the load command constant. If the dynamic linker sees such a load command it it does not understand will issue a \"unknown load command required for execution\" error and refuse to use the image. Other load commands without this bit that are not understood will simply be ignored. LC_SEGMENT = 0x1 segment of this file to be mapped LC_SYMTAB = 0x2 link-edit stab symbol table info LC_SYMSEG = 0x3 link-edit gdb symbol table info (obsolete) LC_THREAD = 0x4 thread LC_UNIXTHREAD = 0x5 unix thread (includes a stack) LC_LOADFVMLIB = 0x6 load a specified fixed VM shared library LC_IDFVMLIB = 0x7 object identification info (obsolete) LC_IDENT = 0x8 object identification info (obsolete) LC_FVMFILE = 0x9 fixed VM file inclusion (internal use) LC_PREPAGE = 0xa prepage command (internal use) LC_DYSYMTAB = 0xb dynamic link-edit symbol table info LC_LOAD_DYLIB = 0xc load a dynamically linked shared library LC_ID_DYLIB = 0xd dynamically linked shared lib ident LC_LOAD_DYLINKER = 0xe load a dynamic linker LC_ID_DYLINKER = 0xf dynamic linker identification LC_PREBOUND_DYLIB = 0x10 modules prebound for a dynamically linked shared library LC_ROUTINES = 0x11 image routines LC_SUB_FRAMEWORK = 0x12 sub framework LC_SUB_UMBRELLA = 0x13 sub umbrella LC_SUB_CLIENT = 0x14 sub client LC_SUB_LIBRARY = 0x15 sub library LC_TWOLEVEL_HINTS = 0x16 two-level namespace lookup hints LC_PREBIND_CKSUM = 0x17 prebind checksum LC_LOAD_WEAK_DYLIB = 0x18 | LC_REQ_DYLD = 0x80000018 load a dynamically linked shared library that is allowed to be missing (all symbols are weak imported) LC_SEGMENT_64 = 0x19 64-bit segment of this file to be mapped LC_ROUTINES_64 = 0x1a 64-bit image routines LC_UUID = 0x1b the uuid LC_RPATH = 0x1c | LC_REQ_DYLD = 0x8000001c run path additions LC_CODE_SIGNATURE = 0x1d local of code signature LC_SEGMENT_SPLIT_INFO = 0x1e local of info to split segments LC_REEXPORT_DYLIB = 0x1f | LC_REQ_DYLD = 0x8000001f load and re-export dylib LC_LAZY_LOAD_DYLIB = 0x20 delay load of dylib until first use LC_ENCRYPTION_INFO = 0x21 encrypted segment information LC_DYLD_INFO = 0x22 compressed dyld information LC_DYLD_INFO_ONLY = 0x22 | LC_REQ_DYLD = 0x80000022 compressed dyld information only LC_LOAD_UPWARD_DYLIB = 0x23 | LC_REQ_DYLD = 0x80000023 load upward dylib LC_VERSION_MIN_MACOSX = 0x24 build for MacOSX min OS version LC_VERSION_MIN_IPHONEOS = 0x25 build for iPhoneOS min OS version LC_FUNCTION_STARTS = 0x26 compressed table of function start addresses LC_DYLD_ENVIRONMENT = 0x27 string for dyld to treat like environment variable LC_MAIN = 0x28 | LC_REQ_DYLD = 0x80000028 replacement for LC_UNIXTHREAD LC_DATA_IN_CODE = 0x29 table of non-instructions in __text LC_SOURCE_VERSION = 0x2A source version used to build binary LC_DYLIB_CODE_SIGN_DRS = 0x2B Code signing DRs copied from linked dylibs LC_ENCRYPTION_INFO_64 = 0x2C 64-bit encrypted segment information LC_LINKER_OPTION = 0x2D linker options in MH_OBJECT files LC_LINKER_OPTIMIZATION_HINT = 0x2E optimization hints in MH_OBJECT files LC_VERSION_MIN_TVOS = 0x2F build for AppleTV min OS version LC_VERSION_MIN_WATCHOS = 0x30 build for Watch min OS version LC_NOTE = 0x31 arbitrary data included within a Mach-O file LC_BUILD_VERSION = 0x32 build for platform min OS version LC_DYLD_EXPORTS_TRIE = 0x33 | LC_REQ_DYLD = 0x80000033 used with LinkeditDataCommand, payload is trie LC_DYLD_CHAINED_FIXUPS = 0x34 | LC_REQ_DYLD = 0x80000034 used with LinkeditDataCommand LC_FILESET_ENTRY = 0x35 | LC_REQ_DYLD = 0x80000035 used with FilesetEntryCommand 定义的来源 最权威=官网 Apple开源代码：xnu中的mach-o（的loader.h和fixup-chains.h） 举例： xnu-7195.81.3 https://opensource.apple.com/source/xnu/xnu-7195.81.3/EXTERNAL_HEADERS/mach-o/ https://opensource.apple.com/source/xnu/xnu-7195.81.3/EXTERNAL_HEADERS/mach-o/loader.h.auto.html 其他所有的普通的Load Command https://opensource.apple.com/source/xnu/xnu-7195.81.3/EXTERNAL_HEADERS/mach-o/fixup-chains.h.auto.html 特殊的：LC_DYLD_CHAINED_FIXUPS和LC_DYLD_EXPORTS_TRIE 别处（引用自官网） macho.rs - source (docs.rs) LoadCommandTypes (ghidra.re) Package ld - The Go Programming Language (google.cn) crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-10 10:15:10 "},"related/mach_o/lc/":{"url":"related/mach_o/lc/","title":"各种Load Command","keywords":"","body":"各种Load Command crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-10 22:39:55 "},"related/mach_o/lc/lc_dyld_chained_fixups.html":{"url":"related/mach_o/lc/lc_dyld_chained_fixups.html","title":"LC_DYLD_CHAINED_FIXUPS","keywords":"","body":"LC_DYLD_CHAINED_FIXUPS dyld中的load command LC_DYLD_CHAINED_FIXUPS（和LC_DYLD_EXPORTS_TRIE） iOS 13中就新增了这个load command，但是没广泛使用 到了iOS 15，iOS的app编译期间加了参数-fixup_chains，则就会用上这套新的机制 导致 旧的class-dump失效了 变化 LC_DYLD_INFO(_ONLY) 没了，被替代为LC_DYLD_CHAINED_FIXUPS和LC_DYLD_EXPORTS_TRIE 包含内容 rebase -- addresses that need to be shifted by ASLR bind -- non-lazy bind symbols that are bound at launch time lazy bind -- lazy bind symbols that are bound at the first time of usage export -- exported symbols that are provided by this binary 布局layout 导出的Trie 举例 对应定义 值的定义#define LC_DYLD_EXPORTS_TRIE 0x80000033 // used with linkedit_data_command #define LC_DYLD_CHAINED_FIXUPS 0x80000034 // used with linkedit_data_command, payload is dyld_chained_fixups_header 来源 Apple开源源码： xnu https://github.com/apple-oss-distributions/xnu/archive/xnu-8792.61.2.tar.gz EXTERNAL_HEADERS/mach-o/fixup-chains.h EXTERNAL_HEADERS/mach-o/loader.h dyld https://github.com/apple-oss-distributions/dyld/archive/dyld-1042.1.tar.gz include/mach-o/fixup-chains.h 相关 binding绑定类型 binding绑定 有3种 non-lazy binding lazy binding weak binding 新旧load command变化 % otool -l iOS14Example.app/iOS14Example | grep LC_DYLD cmd LC_DYLD_INFO_ONLY % otool -l iOS15Example.app/iOS15Example | grep LC_DYLD cmd LC_DYLD_CHAINED_FIXUPS cmd LC_DYLD_EXPORTS_TRIE fixup-chains.h fixup-chains.h /* -*- mode: C++; c-basic-offset: 4; tab-width: 4 -*- * * Copyright (c) 2018 Apple Inc. All rights reserved. * * @APPLE_LICENSE_HEADER_START@ * * This file contains Original Code and/or Modifications of Original Code * as defined in and that are subject to the Apple Public Source License * Version 2.0 (the 'License'). You may not use this file except in * compliance with the License. Please obtain a copy of the License at * http://www.opensource.apple.com/apsl/ and read it before using this * file. * * The Original Code and all software distributed under the License are * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES, * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. * Please see the License for the specific language governing rights and * limitations under the License. * * @APPLE_LICENSE_HEADER_END@ */ #ifndef __MACH_O_FIXUP_CHAINS__ #define __MACH_O_FIXUP_CHAINS__ 6 #include //#define LC_DYLD_EXPORTS_TRIE 0x80000033 // used with linkedit_data_command //#define LC_DYLD_CHAINED_FIXUPS 0x80000034 // used with linkedit_data_command, payload is dyld_chained_fixups_header // header of the LC_DYLD_CHAINED_FIXUPS payload struct dyld_chained_fixups_header { uint32_t fixups_version; // 0 uint32_t starts_offset; // offset of dyld_chained_starts_in_image in chain_data uint32_t imports_offset; // offset of imports table in chain_data uint32_t symbols_offset; // offset of symbol strings in chain_data uint32_t imports_count; // number of imported symbol names uint32_t imports_format; // DYLD_CHAINED_IMPORT* uint32_t symbols_format; // 0 => uncompressed, 1 => zlib compressed }; // This struct is embedded in LC_DYLD_CHAINED_FIXUPS payload struct dyld_chained_starts_in_image { uint32_t seg_count; uint32_t seg_info_offset[1]; // each entry is offset into this struct for that segment // followed by pool of dyld_chain_starts_in_segment data }; // This struct is embedded in dyld_chain_starts_in_image // and passed down to the kernel for page-in linking struct dyld_chained_starts_in_segment { uint32_t size; // size of this (amount kernel needs to copy) uint16_t page_size; // 0x1000 or 0x4000 uint16_t pointer_format; // DYLD_CHAINED_PTR_* uint64_t segment_offset; // offset in memory to start of segment uint32_t max_valid_pointer; // for 32-bit OS, any value beyond this is not a pointer uint16_t page_count; // how many pages are in array uint16_t page_start[1]; // each entry is offset in each page of first element in chain // or DYLD_CHAINED_PTR_START_NONE if no fixups on page // uint16_t chain_starts[1]; // some 32-bit formats may require multiple starts per page. // for those, if high bit is set in page_starts[], then it // is index into chain_starts[] which is a list of starts // the last of which has the high bit set }; enum { DYLD_CHAINED_PTR_START_NONE = 0xFFFF, // used in page_start[] to denote a page with no fixups DYLD_CHAINED_PTR_START_MULTI = 0x8000, // used in page_start[] to denote a page which has multiple starts DYLD_CHAINED_PTR_START_LAST = 0x8000, // used in chain_starts[] to denote last start in list for page }; // This struct is embedded in __TEXT,__chain_starts section in firmware struct dyld_chained_starts_offsets { uint32_t pointer_format; // DYLD_CHAINED_PTR_32_FIRMWARE uint32_t starts_count; // number of starts in array uint32_t chain_starts[1]; // array chain start offsets }; // values for dyld_chained_starts_in_segment.pointer_format enum { DYLD_CHAINED_PTR_ARM64E = 1, // stride 8, unauth target is vmaddr DYLD_CHAINED_PTR_64 = 2, // target is vmaddr DYLD_CHAINED_PTR_32 = 3, DYLD_CHAINED_PTR_32_CACHE = 4, DYLD_CHAINED_PTR_32_FIRMWARE = 5, DYLD_CHAINED_PTR_64_OFFSET = 6, // target is vm offset DYLD_CHAINED_PTR_ARM64E_OFFSET = 7, // old name DYLD_CHAINED_PTR_ARM64E_KERNEL = 7, // stride 4, unauth target is vm offset DYLD_CHAINED_PTR_64_KERNEL_CACHE = 8, DYLD_CHAINED_PTR_ARM64E_USERLAND = 9, // stride 8, unauth target is vm offset DYLD_CHAINED_PTR_ARM64E_FIRMWARE = 10, // stride 4, unauth target is vmaddr DYLD_CHAINED_PTR_X86_64_KERNEL_CACHE = 11, // stride 1, x86_64 kernel caches DYLD_CHAINED_PTR_ARM64E_USERLAND24 = 12, // stride 8, unauth target is vm offset, 24-bit bind }; // DYLD_CHAINED_PTR_ARM64E struct dyld_chained_ptr_arm64e_rebase { uint64_t target : 43, high8 : 8, next : 11, // 4 or 8-byte stide bind : 1, // == 0 auth : 1; // == 0 }; // DYLD_CHAINED_PTR_ARM64E struct dyld_chained_ptr_arm64e_bind { uint64_t ordinal : 16, zero : 16, addend : 19, // +/-256K next : 11, // 4 or 8-byte stide bind : 1, // == 1 auth : 1; // == 0 }; // DYLD_CHAINED_PTR_ARM64E struct dyld_chained_ptr_arm64e_auth_rebase { uint64_t target : 32, // runtimeOffset diversity : 16, addrDiv : 1, key : 2, next : 11, // 4 or 8-byte stide bind : 1, // == 0 auth : 1; // == 1 }; // DYLD_CHAINED_PTR_ARM64E struct dyld_chained_ptr_arm64e_auth_bind { uint64_t ordinal : 16, zero : 16, diversity : 16, addrDiv : 1, key : 2, next : 11, // 4 or 8-byte stide bind : 1, // == 1 auth : 1; // == 1 }; // DYLD_CHAINED_PTR_64/DYLD_CHAINED_PTR_64_OFFSET struct dyld_chained_ptr_64_rebase { uint64_t target : 36, // 64GB max image size (DYLD_CHAINED_PTR_64 => vmAddr, DYLD_CHAINED_PTR_64_OFFSET => runtimeOffset) high8 : 8, // top 8 bits set to this (DYLD_CHAINED_PTR_64 => after slide added, DYLD_CHAINED_PTR_64_OFFSET => before slide added) reserved : 7, // all zeros next : 12, // 4-byte stride bind : 1; // == 0 }; // DYLD_CHAINED_PTR_ARM64E_USERLAND24 struct dyld_chained_ptr_arm64e_bind24 { uint64_t ordinal : 24, zero : 8, addend : 19, // +/-256K next : 11, // 8-byte stide bind : 1, // == 1 auth : 1; // == 0 }; // DYLD_CHAINED_PTR_ARM64E_USERLAND24 struct dyld_chained_ptr_arm64e_auth_bind24 { uint64_t ordinal : 24, zero : 8, diversity : 16, addrDiv : 1, key : 2, next : 11, // 8-byte stide bind : 1, // == 1 auth : 1; // == 1 }; // DYLD_CHAINED_PTR_64 struct dyld_chained_ptr_64_bind { uint64_t ordinal : 24, addend : 8, // 0 thru 255 reserved : 19, // all zeros next : 12, // 4-byte stride bind : 1; // == 1 }; // DYLD_CHAINED_PTR_64_KERNEL_CACHE, DYLD_CHAINED_PTR_X86_64_KERNEL_CACHE struct dyld_chained_ptr_64_kernel_cache_rebase { uint64_t target : 30, // basePointers[cacheLevel] + target cacheLevel : 2, // what level of cache to bind to (indexes a mach_header array) diversity : 16, addrDiv : 1, key : 2, next : 12, // 1 or 4-byte stide isAuth : 1; // 0 -> not authenticated. 1 -> authenticated }; // DYLD_CHAINED_PTR_32 // Note: for DYLD_CHAINED_PTR_32 some non-pointer values are co-opted into the chain // as out of range rebases. If an entry in the chain is > max_valid_pointer, then it // is not a pointer. To restore the value, subtract off the bias, which is // (64MB+max_valid_pointer)/2. struct dyld_chained_ptr_32_rebase { uint32_t target : 26, // vmaddr, 64MB max image size next : 5, // 4-byte stride bind : 1; // == 0 }; // DYLD_CHAINED_PTR_32 struct dyld_chained_ptr_32_bind { uint32_t ordinal : 20, addend : 6, // 0 thru 63 next : 5, // 4-byte stride bind : 1; // == 1 }; // DYLD_CHAINED_PTR_32_CACHE struct dyld_chained_ptr_32_cache_rebase { uint32_t target : 30, // 1GB max dyld cache TEXT and DATA next : 2; // 4-byte stride }; // DYLD_CHAINED_PTR_32_FIRMWARE struct dyld_chained_ptr_32_firmware_rebase { uint32_t target : 26, // 64MB max firmware TEXT and DATA next : 6; // 4-byte stride }; // values for dyld_chained_fixups_header.imports_format enum { DYLD_CHAINED_IMPORT = 1, DYLD_CHAINED_IMPORT_ADDEND = 2, DYLD_CHAINED_IMPORT_ADDEND64 = 3, }; // DYLD_CHAINED_IMPORT struct dyld_chained_import { uint32_t lib_ordinal : 8, weak_import : 1, name_offset : 23; }; // DYLD_CHAINED_IMPORT_ADDEND struct dyld_chained_import_addend { uint32_t lib_ordinal : 8, weak_import : 1, name_offset : 23; int32_t addend; }; // DYLD_CHAINED_IMPORT_ADDEND64 struct dyld_chained_import_addend64 { uint64_t lib_ordinal : 16, weak_import : 1, reserved : 15, name_offset : 32; uint64_t addend; }; #endif // __MACH_O_FIXUP_CHAINS__ crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-12 10:44:24 "},"related/mach_o/lc/use_case.html":{"url":"related/mach_o/lc/use_case.html","title":"涉及地方","keywords":"","body":"涉及地方 Mach64 Header MachOView - some dylib MachOView - Tiktok LC = Load Commands class-dump https://github.com/nygard/class-dump.git Source/CDLoadCommand.m - (NSString *)commandName; { switch (self.cmd) { case LC_SEGMENT: return @\"LC_SEGMENT\"; case LC_SYMTAB: return @\"LC_SYMTAB\"; case LC_SYMSEG: return @\"LC_SYMSEG\"; case LC_THREAD: return @\"LC_THREAD\"; case LC_UNIXTHREAD: return @\"LC_UNIXTHREAD\"; case LC_LOADFVMLIB: return @\"LC_LOADFVMLIB\"; case LC_IDFVMLIB: return @\"LC_IDFVMLIB\"; case LC_IDENT: return @\"LC_IDENT\"; case LC_FVMFILE: return @\"LC_FVMFILE\"; case LC_PREPAGE: return @\"LC_PREPAGE\"; case LC_DYSYMTAB: return @\"LC_DYSYMTAB\"; case LC_LOAD_DYLIB: return @\"LC_LOAD_DYLIB\"; case LC_ID_DYLIB: return @\"LC_ID_DYLIB\"; case LC_LOAD_DYLINKER: return @\"LC_LOAD_DYLINKER\"; case LC_ID_DYLINKER: return @\"LC_ID_DYLINKER\"; case LC_PREBOUND_DYLIB: return @\"LC_PREBOUND_DYLIB\"; case LC_ROUTINES: return @\"LC_ROUTINES\"; case LC_SUB_FRAMEWORK: return @\"LC_SUB_FRAMEWORK\"; case LC_SUB_UMBRELLA: return @\"LC_SUB_UMBRELLA\"; case LC_SUB_CLIENT: return @\"LC_SUB_CLIENT\"; case LC_SUB_LIBRARY: return @\"LC_SUB_LIBRARY\"; case LC_TWOLEVEL_HINTS: return @\"LC_TWOLEVEL_HINTS\"; case LC_PREBIND_CKSUM: return @\"LC_PREBIND_CKSUM\"; case LC_LOAD_WEAK_DYLIB: return @\"LC_LOAD_WEAK_DYLIB\"; case LC_SEGMENT_64: return @\"LC_SEGMENT_64\"; case LC_ROUTINES_64: return @\"LC_ROUTINES_64\"; case LC_UUID: return @\"LC_UUID\"; case LC_RPATH: return @\"LC_RPATH\"; case LC_CODE_SIGNATURE: return @\"LC_CODE_SIGNATURE\"; case LC_SEGMENT_SPLIT_INFO: return @\"LC_SEGMENT_SPLIT_INFO\"; case LC_REEXPORT_DYLIB: return @\"LC_REEXPORT_DYLIB\"; case LC_LAZY_LOAD_DYLIB: return @\"LC_LAZY_LOAD_DYLIB\"; case LC_ENCRYPTION_INFO: return @\"LC_ENCRYPTION_INFO\"; case LC_DYLD_INFO: return @\"LC_DYLD_INFO\"; case LC_DYLD_INFO_ONLY: return @\"LC_DYLD_INFO_ONLY\"; case LC_LOAD_UPWARD_DYLIB: return @\"LC_LOAD_UPWARD_DYLIB\"; case LC_VERSION_MIN_MACOSX: return @\"LC_VERSION_MIN_MACOSX\"; case LC_VERSION_MIN_IPHONEOS: return @\"LC_VERSION_MIN_IPHONEOS\"; case LC_FUNCTION_STARTS: return @\"LC_FUNCTION_STARTS\"; case LC_DYLD_ENVIRONMENT: return @\"LC_DYLD_ENVIRONMENT\"; case LC_LINKER_OPTION: return @\"LC_LINKER_OPTION\"; case LC_LINKER_OPTIMIZATION_HINT: return @\"LC_LINKER_OPTIMIZATION_HINT\"; case LC_VERSION_MIN_TVOS: return @\"LC_VERSION_MIN_TVOS\"; case LC_VERSION_MIN_WATCHOS: return @\"LC_VERSION_MIN_WATCHOS\"; case LC_NOTE: return @\"LC_NOTE\"; case LC_BUILD_VERSION: return @\"LC_BUILD_VERSION\"; default: break; } return [NSString stringWithFormat:@\"0x%08x\", [self cmd]]; } accountsd LC 04: LC_SEGMENT_64 Mem: 0x10000c000-0x100018000 __LINKEDIT LC 05: LC_DYLD_CHAINED_FIXUPS LC 06: LC_DYLD_EXPORTS_TRIE LC 07: LC_SYMTAB LC 08: LC_DYSYMTAB 1 local symbols at index 0 1 external symbols at index 1 28 undefined symbols at index 2 No TOC No modtab 29 Indirect symbols at offset 0xc570 LC 09: LC_LOAD_DYLINKER /usr/lib/dyld LC 10: LC_UUID UUID: C7359973-734A-32BC-AABC-9410717E660B akd LC 05: LC_DYLD_CHAINED_FIXUPS LC 06: LC_DYLD_EXPORTS_TRIE LC 07: LC_SYMTAB LC 08: LC_DYSYMTAB 1 local symbols at index 0 1 external symbols at index 1 584 undefined symbols at index 2 No TOC No modtab 608 Indirect symbols at offset 0x130558 LC 09: LC_LOAD_DYLINKER /usr/lib/dyld otool aweme ➜ Aweme.app otool -l Aweme Load command 6 cmd LC_DYLD_INFO_ONLY cmdsize 48 rebase_off 49152 rebase_size 16 bind_off 49168 bind_size 56 weak_bind_off 0 weak_bind_size 0 lazy_bind_off 49224 lazy_bind_size 416 export_off 0 export_size 0 Load command 9 cmd LC_LOAD_DYLINKER cmdsize 32 name /usr/lib/dyld (offset 12) crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-10 10:12:36 "},"related/structure/":{"url":"related/structure/","title":"相关结构体","keywords":"","body":"相关结构体 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-10 22:41:08 "},"related/structure/dyld_info_command.html":{"url":"related/structure/dyld_info_command.html","title":"dyld_info_command","keywords":"","body":"dyld_info_command 定义 struct dyld_info_command { uint32_t cmd; /* LC_DYLD_INFO or LC_DYLD_INFO_ONLY */ uint32_t cmdsize; /* sizeof(struct dyld_info_command) */ uint32_t rebase_off; /* file offset to rebase info */ uint32_t rebase_size; /* size of rebase info */ uint32_t bind_off; /* file offset to binding info */ uint32_t bind_size; /* size of binding info */ uint32_t weak_bind_off; /* file offset to weak binding info */ uint32_t weak_bind_size; /* size of weak binding info */ uint32_t lazy_bind_off; /* file offset to lazy binding info */ uint32_t lazy_bind_size; /* size of lazy binding infs */ uint32_t export_off; /* file offset to lazy binding info */ uint32_t export_size; /* size of lazy binding infs */ }; 涉及的地方 IDA MusicallyCore YouTube crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-14 11:49:15 "},"related/structure/linkedit_data_command.html":{"url":"related/structure/linkedit_data_command.html","title":"linkedit_data_command","keywords":"","body":"linkedit_data_command 定义 EXTERNAL_HEADERS/mach-o/loader.h #define LC_BUILD_VERSION 0x32 /* build for platform min OS version */ #define LC_DYLD_EXPORTS_TRIE (0x33 | LC_REQ_DYLD) /* used with linkedit_data_command, payload is trie */ #define LC_DYLD_CHAINED_FIXUPS (0x34 | LC_REQ_DYLD) /* used with linkedit_data_command */ #define LC_FILESET_ENTRY (0x35 | LC_REQ_DYLD) /* used with fileset_entry_command */ ... /* * The linkedit_data_command contains the offsets and sizes of a blob * of data in the __LINKEDIT segment. */ struct linkedit_data_command { uint32_t cmd; /* LC_CODE_SIGNATURE, LC_SEGMENT_SPLIT_INFO, LC_FUNCTION_STARTS, LC_DATA_IN_CODE, LC_DYLIB_CODE_SIGN_DRS, LC_LINKER_OPTIMIZATION_HINT, LC_DYLD_EXPORTS_TRIE, or LC_DYLD_CHAINED_FIXUPS. */ uint32_t cmdsize; /* sizeof(struct linkedit_data_command) */ uint32_t dataoff; /* file offset of data in __LINKEDIT segment */ uint32_t datasize; /* file size of data in __LINKEDIT segment */ }; crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-10 22:40:07 "},"appendix/":{"url":"appendix/","title":"附录","keywords":"","body":"附录 下面列出相关参考资料。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-03-20 10:08:57 "},"appendix/reference.html":{"url":"appendix/reference.html","title":"参考资料","keywords":"","body":"参考资料 【未解决】iOS反越狱检测：strcmp 【未解决】研究抖音越狱检测逻辑：___lldb_unnamed_symbol13025即sub_5BABB5C 【已解决】Xcode的lldb中动态调试objc_msgSend第二个参数函数名或属性值 【记录】分析和研究：当stringByAppendingString参数为空时的AwemeCore相关函数代码段 【已解决】研究抖音越狱检测逻辑：open_dprotected_np 【未解决】研究抖音是否实现了Method Swizzling的Hook检测 【整理】苹果的动态库链接器：dyld 【或许解决】iPhone中所用的dyld是哪个版本 【记录】dyld相关资料：启动过程 【无需解决】iOS反越狱检测：dlopen_preflight 【未解决】iOS逆向AppleStore：用纯净Xcode项目调试AppleStore的ipa 【未解决】MonkeyDev调试AppleStore报错：container_create_or_lookup_app_group_path_by_app_group_identifier 【未解决】iOS逆向AppleStore：用dumpdecrpted砸壳报错Killed 9 【无法解决】iOS逆向AppleStore砸壳：dumpapp.com网站 【无法解决】iOS逆向AppleStore账号获取失败：替换Data目录 【已解决】Mac中安装和初始化Capstone去显示反汇编代码 【已解决】iOS逆向：Mac中安装unicorn 【未解决】iOS逆向akd：hook代码AKAnisetteProvisioningService导致崩溃报错unrecognized selector sent to class 【已解决】XCode+MonkeyDev调试抖音不崩溃却卡死禁用断点始终停在Foundation的NSString的stringByAppendingString 【未解决】iOS逆向：用jailbreakd_client给debugserver去加上entitle和platformize 【未解决】如何调试iPhone中iOS的app 【记录】研究抖音app启动后输出的log日志中关于dylib动态库相关内容 【未解决】iOS中如何检测抖音app当前进程加载或注入了哪些dylib动态库 【整理】Mach-O格式和启动相关 【未解决】iOS的app的启动流程启动过程 【已解决】XCode和lldb调试常见用法和调试心得 【已解决】Mac中如何用lldb调试iPhone中的app 【无法解决】iOS越狱检测和反越狱检测：objc_getClass 【记录】lldb命令使用心得：register read 【整理】macOS和Linux命令工具：nm 【未解决】静态分析符号函数字符串：Aweme 【未解决】静态分析符号函数字符串：AwemeCore 【未解决】iOS反越狱检测：_dyld_private 【记录】研究iOS的app抖音Aweme相关文件 【已解决】静态分析Tiktok：MachOView查看MusicallyCore 【已解决】iOS逆向Undecember静态分析：MachOView查看信息 【未解决】Mac中用Frida调试iOS版抖音 【已解决】ARM汇编指令：br 【未解决】研究libdyld.dylib`_dyld_get_image_name汇编代码的伪代码的逻辑 【整理】dyld相关：dyldinfo 【记录】深究为何此处XCode编译strcpy会报错No matching function for call to 【整理】dyld相关函数定义 【无需解决】iOS反越狱检测：dyld的NSVersionOfRunTimeLibrary等3个函数 【已解决】iOS反越狱检测：dyld的dladdr 【已解决】iOS反越狱检测：dladdr的hook绕过 【整理】dyld相关：dladdr函数原型定义 【无需解决】iOS反越狱检测：Mach-O的getsect相关函数 【记录】分析研究SuperMan超人：_getsectbynamefromheader_64 【部分解决】hook拦截AwemeCore中调用的函数：getsectiondata 【规避解决】调试抖音hook函数dladdr和getsectiondata期间iosLogInfo输出log导致崩溃 【已解决】hook函数getsectiondata时不hook函数dladdr看看是否还是导致抖音崩溃 【未解决】XCode调试找原因：hook函数getsegmentdata会导致抖音崩溃 【已解决】Mach-O中LC相关Load Command的数值定义和含义 【整理】iOS中新的load command：LC_DYLD_CHAINED_FIXUPS 【已解决】Mac M2 Max中下载安装：MachOView 【已解决】静态分析Tiktok：MachOView查看Tiktok 【未解决】新Mac中dylib插件不生效：编译器clang、dylib文件等区别 【未解决】iOS反越狱检测：dyld动态库相关 【未解决】iOS逆向Apple账号：静态分析accountsd 【已解决】iOS逆向akd：导出字符串等静态资源信息 【记录】用otool查看抖音加载的dylib动态库 【未解决】iOS逆向Apple账号：静态分析设置Preferences的ipa 【已解决】iOS逆向Undecember静态分析：导出字符串等资源 【未解决】iOS反越狱检测：svc 0x80 call 【记录】dyld源码中的gProcessInfo 【基本解决】dyld-932.4源码中的gProcessInfo的定义 【记录】dyld-733.3.1源码中的gProcessInfo相关定义 【未解决】dyld-932.4中gProcessInfo编译后symbol却是__ZN5dyld412gProcessInfoE 【已解决】研究二进制/usr/lib/dyld中是否包含或导出变量_gProcessInfo 【已解决】iPhone11中的dyld的版本 【已解决】iOS 13.3的iPhone7中/usr/lib/dyld的版本和gProcessInfo相关信息 【已解决】iOS越狱测试：getenv获取其他DYLD的环境变量值 【未解决】iPhone8中的设置app白屏无法操作 【已解决】iOS逆向Apple账号：+[AADeviceInfo udid]断点没生效换调试对象Preferences 【已解决】iOS逆向Apple账号：objc_alloc_init的汇编代码断点没有触发到的原因 【已解决】iOS逆向Apple账号：Foundation的_NSXPCDistantObjectSimpleMessageSend2 【已解决】lldb调试iOS进程时image list报错：error the target has no matching modules 【未解决】iOS逆向Apple账号：研究-[NSXPCConnection remoteObjectProxyWithErrorHandler:]返回类型是__NSXPCInterfaceProxy_AKAppleIDAuthenticationDaemonProtocol 【未解决】iOS逆向Apple账号：-[ACAccountCredential initWithPassword:] 【未解决】iOS逆向Apple账号：-[ACAccountCredential credentialItemForKey:] 【已解决】iOS逆向Apple账号：+[AAPersonaUtility verifyAndFixPersonaIfNeeded:desiredContext:] 【未解决】iOS逆向Apple账号：-[NSXPCConnection _sendSelector:withProxy:arg1:arg2:] 【未解决】iOS逆向Apple账号：-[AAUISignInViewController _nextButtonSelected:] 【未解决】iOS逆向Apple：arm64的-[AKAppleIDAuthenticationController authenticateWithContext:completion:] 【未解决】iOS逆向Apple账号：-[AKAppleIDAuthenticationController authenticateWithContext:completion:] 【未解决】iOS逆向Apple账号：-[NSXPCConnection _sendInvocation:orArguments:count:methodSignature:selector:withProxy:] 【无法解决】iOS逆向Apple账号：从objc_msgSend找shouldContinueWithAuthenticationResults:error:forContextID:completion:调用的地方 【未解决】lldb中条件判断的断点出现警告：warning hit breakpoint while running function skipping commands and conditions to prevent recursion 【已解决】iOS的ObjC基础知识：load方法 【未解决】iOS逆向Undecember：启动阶段函数InitFunc_5的svc 0x80 【未解决】iOS逆向Undecember：AGFramework 【未解决】iOS逆向Undecember：AGFramework的init 【未解决】研究抖音越狱检测逻辑：NSObject的load 【整理】抖音AwemeCore恢复符号表的效果举例 【未解决】iOS逆向Apple账号：___lldb_unnamed_symbol941$$CFNetwork 【未解决】iOS逆向Apple账号：库AppleSRP相关 【记录】用rabin2查看抖音AwemeCore二进制的信息 【未解决】iOS逆向：libsubstrate.dylib中找不到_dyld_get_all_image_infos而报错 【已解决】iOS中getenv获取环境变量的含义和语法 【整理】iOS中DYLD_IMAGE_SUFFIX的含义 【记录】XCode+MonkeyDev动态调试抖音寻找越狱逻辑：getenv的DYLD相关 【未解决】研究抖音越狱检测：高级越狱检测技术 【未解决】iOS越狱检测手段：__RESTRICT 【已解决】IDA中Structures结构体定义中修改自定义类的属性的偏移量 【整理】iOS逆向心得：IDA使用心得：修改变量类型Set Ivar Type后IDA可以自动解析结构体的属性和字段 【已解决】用IDA静态分析Tiktok核心二进制：MusicallyCore 【记录】IDA Pro使用记录 【记录】恢复iOS逆向Xcode调试YouTube的开发环境 【整理】Xcode设置Settings中各个参数及含义 【已解决】iOS逆向：libcommonCrypto.dylib库文件的位置 【已解决】Xcode+MonkeyDev中让iOS的游戏app退出前能暂停运行 【未解决】iOS逆向AppleStore证书无效：去hook函数SecTrustEvaluateFastAsync 【记录】iOS逆向Preferences：lldb调试arm64e的iOS 15.1时输出的image list 【未解决】iOS逆向Preferences：lldb调试加载的iOS 15.0的arm64的库的列表image list 【记录】研究抖音app启动后输出的log日志中关于dylib动态库相关内容 【记录】lldb命令使用心得：image 【未解决】XCode中用lldb调试打印抖音崩溃时信息寻找崩溃原因 【未解决】尝试解决XCode的MonkeyDev抖音ipa调试崩溃：去掉重复的越狱动态库 【已解决】从XCode和lldb中函数地址找到IDA中所属代码段函数 【已解决】iOS逆向akd：Unicorn模拟_lldb_unnamed_symbol2575时stack_chk_guard值如何设置和写入 【未解决】XCode调试找原因：hook函数getsegmentdata会导致抖音崩溃 【未解决】Xcode中已禁用所有断点但仍会随机暂停执行在某处 【已解决】Xcode中lldb的条件watchpoint报错：error user expression indirection requires pointer operand long invalid 【未解决】研究抖音越狱逻辑：HMDMonitorDataManager的reportHeaderParams 【未解决】研究抖音越狱逻辑：lldb中image查询statfs的函数实现有几个 【记录】静态分析Mask的动态库：Mask.dylib 【未解决】研究抖音关注逻辑：从_dyld_register_func_for_add_image的hook找可能的越狱检测逻辑 【未解决】研究抖音越狱检测逻辑：___lldb_unnamed_symbol1843637$$AwemeCore 【已解决】ARM汇编指令：TBZ和TBNZ 【已解决】Xcode调试YouTube的hook代码报错：NSInvalidArgumentException __NSDictionaryM unrecognized selector Original Exception Backtrace 【已解决】iOS逆向：Xcode中给lldb无名函数加断点指定属于哪个库文件 【未解决】iOS逆向AppleStore获取账户失败：User.swift initialize Cannot retrieve valid iTunes account info 【未解决】iOS逆向akd：进程崩溃退出EXC_BAD_ACCESS code 50 【已解决】iOS逆向debugserver报错Killed 9：研究崩溃日志ips文件找崩溃原因 【未解决】研究frida崩溃Process terminated：通过Preferences的崩溃日志找原因 【已解决】ldld加了entitlement权限后debugserver运行崩溃：Bad Mach-O EXC_CRASH SIGKILL CODESIGNING 【未解决】iOS逆向AppleStore：ACAccountStore iTunes accounts 【已解决】iOS反越狱检测：dyld的getenv获取环境变量DYLD_INSERT_LIBRARIES 【记录】Mac中把Xcode自带工具链二进制工具合并到环境变量 【未解决】iOS逆向MSFindSymbol报错：dyld missing symbol called 【未解决】反越狱检测工具：fishhook 【未解决】iOS越狱检测open系列函数：open_extended 【已解决】iOS越狱检测：辅助用_dyld_get_image_vmaddr_slide输出ALSR偏移地址 【已解决】iOS和C函数定义：dlopen和dlsym 【记录】静态分析Mask的动态库：Mask.dylib 【未解决】IDA中如何解析objc_msgSend函数调用 【已解决】Mac中pipenv报错：dyld Library not loaded executable_path Python 【已解决】新Mac中rsync报错：rsync connection unexpectedly closed 0 bytes received so far sender 【记录】用Cutter查看分析抖音AwemeCore二进制文件信息 【未解决】IDA伪代码中无法解析出objc_msgSend等函数调用只有MEMORY 【整理】iOS的iPhone越狱和改机相关知识 【未解决】Xcode的lldb调试iOS的ObjC期间：从类的实例的地址获取到类名 【记录】XCode+MonkeyDev调试抖音ipa：调试早期函数dlopen 【已解决】iOS逆向：寻找libMobileGestalt.dylib库文件 【未解决】MaskPro.dylib引用的库：/usr/lib/libMobileGestalt.dylib 【未解决】iOS逆向Apple账号：调试函数ccsha256_vng_arm_di 【记录】palera1n的v2.0 beta 5的rootful普通越狱的过程的第一步 【未解决】iOS 15越狱工具：Cheyote 【未解决】iOS逆向：允许进程被调试的csflags中的CS_GET_TASK_ALLOW 【基本解决】iOS逆向Xcode中codesign：搞懂DerivedSources/Entitlements.plist的内容的来源 【已解决】iOS中进程的flag定义 【整理】去研究Mach-O格式 【未解决】iOS逆向获取进程中csflags中CS_GET_TASK_ALLOW：权限proc_info-allow 【已解决】iOS逆向时_os_log_impl的详细的参数和含义 【未解决】Frida调试Apple Store报错：Failed to attach missing gProcessInfo 【未解决】自己修改编译frida-core源码以尝试解决Frida的Missing gProcessInfo问题 【未解决】自己编译出的arm64的frida-server能否在iPhone11正常运行 【未解决】研究Frida中Missing gProcessInfo出错的逻辑和原因 【已解决】frida-core代码对应着frida中是哪个文件 【已解决】iOS正向越狱检测：_dyld_register_func_for_add_image及相关 【已解决】iOS反越狱检测：dyld的_dyld_image_count和_dyld_get_image_name 【已解决】iOS反越狱检测：dyld的dlopen和dlsym 【部分解决】iOS越狱检测：用dladdr解析函数所属动态库 【未解决】iOS逆向MSFindSymbol报错：dyld missing symbol called 【已解决】Mac中运行Cycript报错：dyld Library not loaded libruby.2.0.0.dylib 【整理】iOS逆向心得：iOS函数objc_autoreleaseReturnValue 【已解决】iOS逆向Xcode调试：_objc_autoreleaseReturnValue继续运行导致后续release相关代码运行不到 【未解决】IDA调试iPhone中的iOS的app 【整理】iOS中的带函数原型和说明的系统调用system call 【未解决】研究抖音越狱逻辑：dlsym传入的_availability_version_check、kCFAllocatorNull等参数 【已解决】iOS逆向相关：AMFI 【记录】佐罗导入抖音账号 【已解决】脱壳抖音ipa用爱思助手安装后启动失败闪退 【已解决】iOS反越狱检测：实现_dyld_get_image_header和_dyld_get_image_vmaddr_slide的完美hook 【已解决】mac中npm install报错：make Release/obj.target/zmq/binding.o Error 1 【无需解决】iOS反越狱检测：dyld的NSVersionOfRunTimeLibrary等3个函数 【基本解决】iOS越狱检测：_dyld_register_func_for_add_image和_dyld_register_func_for_remove_image 【已解决】iOS反越狱检测：_dyld_register_func_for_add_image和_dyld_register_func_for_remove_image 【记录】分析研究SuperMan超人：_getsectbynamefromheader_64 【未解决】Xcode调试抖音会随机停在某处：dladdr的SIGTRAP 【已解决】iOS反越狱检测：LSApplicationWorkspace和LSApplicationProxy 【未解决】IDA中查找函数被调用的地方：_dyld_image_count 【未解决】frida调试抖音app去hook函数：_dyld_get_image_name 【未解决】frida去hook函数_dyld_get_image_name时打印参数为字符串 【记录】用MachOView查看分析黑豹动态库zzzzHeiBaoLib.dylib 【未解决】Mach-O中_DATA的__la_symbol_ptr含义 【记录】研究分析SuperMan超人的文件：SuperMan 【已解决】XCode中调试AwemeCore的___lldb_unnamed_symbol148函数的地址 【已解决】C++代码中函数变量编译生成符号symbol的规则 【未解决】rabin2输出C++的未解析的原始的编译后的函数名mangle name 【整理】C++代码中的name mangling名称改写 深入理解iOS动态链接 | 4ch12dy 探究Mach-O文件 - 掘金 (juejin.cn) 基于桥的全量方法Hook方案 - 探究苹果主线程检查实现 | SatanWoo linkMap深度解析_zhuge1127的博客-CSDN博客_linkmap Objective-C基本分析法 反编译_mr_liu_easy_ios的博客-CSDN博客 iOS逆向学习（一）基础 | BenArvin's blog (benarvintec.com) os_version_check.c source code [compiler-rt/lib/builtins/os_version_check.c] - Woboq Code Browser OC方法交换swizzle详细介绍——不再有盲点 - 时间已静止 - 博客园 (cnblogs.com) *OS Internals: (newosxbook.com) ios - Why the implementation of ARC's objc_autoreleaseReturnValue differs for x86_64 and ARM? - Stack Overflow [iOS] __autorelease的碎碎念&疑惑 - 简书 (jianshu.com) 《iOS应用逆向与安全》(刘培庆)_计算机与互联网 - 略准书籍推荐搜索 (lvezhun.com) Mac OS X Manual Page For dlopen_preflight(3) (apple.com) getsectdata(3) [osx man page] (unix.com) Mac OS X Manual Page For dlclose(3) dyld/include/mach-o/dyld_priv.h at master · opensource-apple/dyld dyld_priv.h dyld_priv.h iOS/Bypassing-AMFI.md at master · writeups/iOS · GitHub electra/main.m at master · coolstar/electra · GitHub Cheyote Jailbreak - iOS 15 to 15.1.1 & Up to iOS 15.5 (silzee.com) iOSAppReverseEngineering.pdf iosre/iOSAppReverseEngineering: The world’s 1st book of very detailed iOS App reverse engineering skills :) (github.com) iOS dyld 源码 - 简书 (jianshu.com) objc-runtime-new.mm (apple.com) Reverse Engineering Tools - iPhone Development Wiki IDA: IDA 7.2 - The Mac Rundown (hex-rays.com) IDA Help: DYLD Shared Cache Utils (hex-rays.com) DYLD Shared Cache Utils | Hex-Rays Docs 通过两个IDAPython插件支持A12 PAC指令和iOS12 kernelcache 重定位 - 先知社区 (aliyun.com) iOS12 Kernelcache Laundering (synacktiv.com) kernelcache-laundering/aarch64_pac.py at master · Synacktiv-contrib/kernelcache-laundering (github.com) Synacktiv-contrib/kernelcache-laundering: load iOS12 kernelcaches and PAC code in IDA (github.com) How to Reverse Engineer an Undocumented macOS API to Use It in a Swift Project | Apriorit /System/Library/Frameworks - The iPhone Wiki dsc_extractor.cpp (apple.com) dlinfo(3) - Linux manual page Mac OS X Manual Page For dlsym(3) dlsym(3) - Linux manual page (man7.org) dlopen(3) - Linux manual page (man7.org) FDInterposing.cpp facebook/fishhook: A library that enables dynamically rebinding symbols in Mach-O binaries running on iOS. (github.com) iOS 11.1.2 Runtime Headers - StoreServices - SSAccountStore.h (limneos.net) Phillip Tennen 在 Twitter: \"There's a new symbol imported into every Mach-O built with iOS 13: objc_opt_class(). What's it for? https://t.co/X5ldbDfXvd\" / Twitter iOS逆向(11)-砸壳原理剖析，主动加载所有framework - 掘金 (juejin.cn) Complete list of Xcode new build system settings and their documentation in JSON format. (github.com) XcodeNewBuildSystemSettings.json Hardened Runtime | Apple Developer Documentation _dyld_get_all_image_infos() is private in macOS 10.13, causes test failures [42310087] - Chromium dyld_debug.c Example using struct dyld_all_image_infos load 方法全程跟踪 - 知乎 (zhihu.com) dyldinfo(1) [osx man page] IOS APP startup optimization (VII) : Detailed analysis of dyLD loading process - Moment For Technology (mo4tech.com) iOS逆向攻防实战 - 掘金 (juejin.cn) iOS 底层 - 从头梳理 dyld 加载流程 - 掘金 (juejin.cn) iOS dyld 源码 - 简书 (jianshu.com) App启动之Dyld在做什么 - 掘金 (juejin.cn) dyld详解-iOS-优雅人生 (dllhook.com) How iOS 15 makes your app launch faster | by Noah Martin | Geek Culture | Medium Mac OS X Manual Page For dyld(3) man page dyld section 1 Debugging Dyld - Low Level Bits 🇺🇦 iOS 底层 - 从头梳理 dyld 加载流程 - 掘金 (juejin.cn) 朝暮的闲暇时刻 (leylfl.github.io) dyld启动流程 | 朝暮的闲暇时刻 (leylfl.github.io) dyld：启动流程解析 - 简书 (jianshu.com) Mac OS X Manual Page For dlopen(3) Mac OS X Manual Page For dlopen_preflight(3) 检测非法键盘hook_反越狱检测解读_weixin_39825941的博客-CSDN博客 iOS抖音越狱检测分析 - 逆向交流 - iOS 安全论坛 - 专注于研究 iOS 安全 - iOS Hacker iOS 11.3.1上使用bfinject注入dylib后的问题 - 技能讨论 - 睿论坛 (iosre.com) [iOS 逆向 12] 加密与动态保护_Eric's Blog-CSDN博客 DYLD_INSERT_LIBRARIES DYLIB injection in macOS / OSX · theevilbit blog macos - How to find which shared library is loaded by a process on OSX? - Stack Overflow Edgar's Blog (tbfungeek.github.io) 谈谈iOS里面的动态注入 - 简书 (jianshu.com) Using LLDB for reverse engineering (rderik.com) dyld_stub_binder.s dyldinfo.cpp IOS_检测iOS设备是否越狱的方法，在应用开发过程中，我们希望 (xp.cn) 常见反越狱检测插件实现原理 - lichao890427 - 博客园 (cnblogs.com) How to cheat jb detector and detect cheating (slideshare.net) Hokila/jbdetector: jbdetector (github.com) dishibolei/JailbreakCheck (github.com) iOS安全 -- 越狱检测 · DearMiku iOS防护----关键函数地址校验 - 代码先锋网 (codeleading.com) iOS防护----关键函数地址校验_✎﹏ℳ๓₯㎕❦-CSDN博客 dladdr(3) - Linux manual page Mac OS X Manual Page For dladdr(3) getsect.h opensource.apple.com/source/cctools/cctools-698/libmacho/getsecbyname.c qyang-nj/llios: Random stuff about lower level iOS (github.com) llios/LC_DYLD_INFO.md at main · qyang-nj/llios (github.com) llios/chained_fixups.md at main · qyang-nj/llios (github.com) lechium/classdumpios: classdump-c: Custom macOS / iOS / tvOS port updated to work on iOS 13-16+ supporting chained fixups, can also dump entitlements now as well (github.com) How iOS 15 makes your app launch faster | by Noah Martin | Geek Culture | Medium iOS15系统启动时间加速 - 简书 (jianshu.com) llios/BindingInfo.md at main · qyang-nj/llios (github.com) Mach-O 与动态链接 | 张不坏的博客 (zhangbuhuai.com) Hello World背后的逻辑 - 掘金 (juejin.cn) crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-10-14 12:11:09 "}}