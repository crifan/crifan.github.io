{"./":{"url":"./","title":"前言","keywords":"","body":"逆向调试利器：Frida 最新版本：v4.4.0 更新时间：20250522 简介 介绍支持Android、iOS等多个平台的通用逆向工具：Frida。先是Frida概览，包括Frida的代码和架构，以及相关文档和案例和资料。再介绍如何在PC端和移动端即iOS和安卓端的安装和升级Frida。然后是如何使用Frida，先介绍Frida的典型使用逻辑，然后再去介绍frida命令行工具，其中包括通用的逻辑，比如调试目标的方式，以及写js脚本；然后是典型的使用方式，以及此处iOS逆向涉及到的ObjC的内容，包括ObjC的参数和变量类型；接着是数据类型，包括NativePointer。接着是高级的Stalker。接着介绍frida-trace，以及frida-tools工具集合，包括frida-ps、frida-ls、frida-ls-devices等；接着介绍其他相关的内容，包括frida-server等。接着整理一些Frida开发期间的经验和心得，包括hook函数方面的，包括frida和frida-trace，frida中的Interceptor、Stalker、常用iOS函数等。其他还有工具类的函数、js以及其中的console.log，和自己编译frida-server，和其他常见问题和报错。接着整理基于Frida的工具。以及Frida的一些常见用途，包括反调试、辅助反混淆、绕过参数加密、逆向各种app等。最后贴出参考资料。 源码+浏览+下载 本书的各种源码、在线浏览地址、多种格式文件下载如下： HonKit源码 crifan/reverse_debug_frida: 逆向调试利器：Frida 如何使用此HonKit源码去生成发布为电子书 详见：crifan/honkit_template: demo how to use crifan honkit template and demo 在线浏览 逆向调试利器：Frida book.crifan.org 逆向调试利器：Frida crifan.github.io 离线下载阅读 逆向调试利器：Frida PDF 逆向调试利器：Frida ePub 逆向调试利器：Frida Mobi 版权和用途说明 此电子书教程的全部内容，如无特别说明，均为本人原创。其中部分内容参考自网络，均已备注了出处。如发现有侵权，请通过邮箱联系我 admin 艾特 crifan.com，我会尽快删除。谢谢合作。 各种技术类教程，仅作为学习和研究使用。请勿用于任何非法用途。如有非法用途，均与本人无关。 鸣谢 感谢我的老婆陈雪的包容理解和悉心照料，才使得我crifan有更多精力去专注技术专研和整理归纳出这些电子书和技术教程，特此鸣谢。 其他 作者的其他电子书 本人crifan还写了其他150+本电子书教程，感兴趣可移步至： crifan/crifan_ebook_readme: Crifan的电子书的使用说明 关于作者 关于作者更多介绍，详见： 关于CrifanLi李茂 – 在路上 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-05-22 22:54:03 "},"frida_overview/":{"url":"frida_overview/","title":"Frida概览","keywords":"","body":"Frida概览 Frida 概述 一款基于python + javascript的hook框架 Android、iOS的app逆向等领域中，最常用的工具之一 A world-class Dynamic instrumentation toolkit for developers, reverse-engineers, and security researchers Inject JavaScript to observe and reprogram running programs on Windows, macOS, GNU/Linux, iOS, watchOS, tvOS, Android, FreeBSD, and QNX 主要用法：iOS逆向期间，用frida+js脚本和frida-trace、Frida的Stalker等工具，去动态调试代码逻辑 核心原理 主要使用动态二进制插桩(DBI)技术 将外部代码注入到现有的正在运行的二进制文件中，从而让它执行额外操作 支持哪些额外操作 访问进程内存 在应用程序运行时覆盖函数 从导入的类调用函数 在堆上查找对象实例并使用 Hook、跟踪和拦截函数等 注：调试器也能完成相应工作，不过非常麻烦，比如各种反调试 功能和特点 Scriptable Inject your own scripts into black box processes. Hook any function, spy on crypto APIs or trace private application code, no source code needed. Edit, hit save, and instantly see the results. All without compilation steps or program restarts. Portable 支持多种运行平台/系统：Android/iOS/Linux/Win/macOS等 Works on Windows, macOS, GNU/Linux, iOS, Android, and QNX. Install the Node.js bindings from npm, grab a Python package from PyPI, or use Frida through its Swift bindings, .NET bindings, Qt/Qml bindings, or C API. Free Frida is and will always be free software (free as in freedom). We want to empower the next generation of developer tools, and help other free software developers achieve interoperability through reverse engineering. Battle-tested We are proud that NowSecure is using Frida to do fast, deep analysis of mobile apps at scale. Frida has a comprehensive test-suite and has gone through years of rigorous testing across a broad range of use-cases. 主页 官网 https://frida.re/ 文档 https://frida.re/docs/home/ Github https://github.com/frida/frida 作者：oleavr=Ole André Vadla Ravnås Github https://github.com/oleavr 所属公司 NowSecure https://www.nowsecure.com/ crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-07-13 14:53:50 "},"frida_overview/code_arch.html":{"url":"frida_overview/code_arch.html","title":"代码和架构","keywords":"","body":"代码和架构 Frida的架构 总体架构 client=客户端 frida的各种工具 frida：frida主体工具本身，用的最多。 frida-tools：（Win/Mac等）PC端常用到的，除了frida之外的，frida-trace、frida-ps、frida-ls等命令行工具 frida-trace：按顺序和带缩进的打印所有函数调用堆栈，极大地方便调试内部逻辑 server=服务端 frida-server 原理图=架构图 其中可见很多关键的点=frida中的子项 frida-code frida-node frida-agent frida-gum GumJS 对应着源码中的各个子项目：详见下面内容。 Frida源码 Frida源码 总入口: https://github.com/frida/frida core: frida-core Frida core library intended for static linking into bindings gum: frida-gum Cross-platform instrumentation and introspection library written in C This library is consumed by frida-core through its JavaScript bindings, GumJS. tools: frida-tools Frida CLI tools bindings python -> frida-python Node.js -> frida-node Swift -> frida-swift .NET -> frida-clr GO -> frida-go Rust -> frida-rust QT/qml -> frida-qml 其他 Frida支持多个移动端的互操作，所以有分别的内部的互操作相关的内容 iOS端的：frida-objc-bridge Objective-C runtime interop from Frida Android端的：frida-java-bridge Java runtime interop from Frida Capstone 记得是：Frida内部用到了Capstone，但是有些额外的内容要微调，所以单独fork了Capstone源码，自己同步更新了 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-23 23:07:22 "},"frida_overview/doc_refer/":{"url":"frida_overview/doc_refer/","title":"文档和资料","keywords":"","body":"文档和资料 官网文档入口: Frida Docs 入门指南=Getting Started 快速入手: Quick-start guide 安装: Installation 操作模式: Modes of Operation Gadget: Gadget 内部原理: Hacking Stalker: Stalker 演讲文档资料：Presentations 教程=Tutorials 通用 函数: Functions 消息: Messages 移动端 iOS Android 案例=Examples PC端 Windows macOS Linux 移动端 iOS Android 其他 JavaScript 工具=Tools frida命令行工具: Frida CLI frida-ps frida-trace frida-discover frida-ls-devices frida-kill gum-graft API文档=API Reference JavaScript API C API Swift API Go API 其他细节=Miscellaneous 最佳实践: Best Practices 排错: Troubleshooting 自己编译Frida=参与Frida开发: Building 占用系统空间: Footprint 起源和发展=Meta GSoC Ideas 2015 GSoD Ideas 2023 History 其他 教程 Frida basics - Frida HandBook (learnfrida.info) Frida HandBook crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-27 22:55:46 "},"install_upgrade/":{"url":"install_upgrade/","title":"安装和升级","keywords":"","body":"安装和升级 此处介绍Frida的安装和升级，即Frida的调试环境初始化。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-07-22 15:24:57 "},"install_upgrade/install_frida/":{"url":"install_upgrade/install_frida/","title":"安装Frida","keywords":"","body":"安装Frida 在能使用Frida之前，先要去安装Frida=初始化Frida调试环境： 概述 电脑端安装frida（和frida-tools），移动端安装frida（的server） Mac中逆向iOS Mac： 安装frida和安装frida-toolspip3 install frida pip3 install frida-tools 如果要：（1）强制安装到全局版本Python （2）加上代理，则是：pip3 --proxy http://127.0.0.1:58591 install frida --break-system-packages pip3 --proxy http://127.0.0.1:58591 install frida-tools --break-system-packages iOS（iPhone）：包管理器（Sileo/Cydia）中（通过软件源：https://build.frida.re）安装frida的插件 Mac中逆向Android Mac：同上 Android：Magisk中安装MagiskFrida插件 注：Frida官网的Android版frida-server有问题，所以换装第三方可用版本 后续详细解释。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-12-13 17:38:39 "},"install_upgrade/install_frida/pc/":{"url":"install_upgrade/install_frida/pc/","title":"电脑端","keywords":"","body":"电脑端 此处介绍，电脑端安装Frida的相关内容。 核心思路 给电脑端安装frida和相关的工具 frida的命令行工具：frida frida的相关工具：frida-tools 举例 Mac 安装frida pip3 install frida 安装frida-tools pip3 install frida-tools crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-07-22 15:28:10 "},"install_upgrade/install_frida/pc/mac.html":{"url":"install_upgrade/install_frida/pc/mac.html","title":"Mac","keywords":"","body":"Mac 此处介绍，电脑端Mac中，安装Frida的过程： 安装 必选 安装frida 安装frida => 使得有frida命令行工具可用pip3 install frida 安装后查看版本pip show frida 安装frida-tools 安装frida-tools => 使得有frida-trace、frida-ps、frida-ls等命令行工具可用pip3 install frida-tools 安装后查看版本pip show frida-tools 额外说明 如果前面没有先单独安装frida，则安装frida-tools时会自动安装所依赖的frida 可选 安装Frida的gadget 安装Frida的gadget => 使得后续使用frida-ios-dump时而不报错need Gadget to attach on jailed iOS 下载gadget库文件 从Frida的Github的release页面中，下载对应版本的frida-gadget的dylib 举例 https://github.com/frida/frida/releases/download/16.0.8/frida-gadget-16.0.8-ios-universal.dylib.gz 解压得到：frida-gadget-16.0.8-ios-universal.dylib 拷贝到对应位置：~/.cache/frida/gadget-ios.dylib 举例cp frida-gadget-16.0.8-ios-universal.dylib /Users/crifan/.cache/frida/gadget-ios.dylib 安装：Frida的Node.js的bindings 安装：Frida的Node.js的bindings 说明： 默认不用安装 需要用到时，再去安装即可 安装命令npm install frida 安装后 安装frida后，可以查看和确认位置和版本： 举例： ➜ ~ which frida /opt/homebrew/bin/frida ➜ ~ frida --version 16.4.5 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-07-22 15:42:03 "},"install_upgrade/install_frida/mobile/":{"url":"install_upgrade/install_frida/mobile/","title":"移动端","keywords":"","body":"移动端 此处介绍，移动端中如何安装Firda： 核心思路 给移动端安装一个frida的server（frida-server） 举例 iOS（iPhone） 包管理器（Sileo/Cydia）中（通过软件源：https://build.frida.re）安装frida的插件 Android Magisk中安装MagiskFrida插件 说明 Frida官网的Android版frida-server有问题，所以换装第三方可用版本 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-07-22 15:37:33 "},"install_upgrade/install_frida/mobile/ios.html":{"url":"install_upgrade/install_frida/mobile/ios.html","title":"iOS","keywords":"","body":"iOS 此处介绍，移动端的iOS（iPhone）中，如何安装Frida（的server）： 前提 iPhone已越狱 安装步骤 用Sileo/Cydia，添加软件源：https://build.frida.re，搜索并安装frida，即可 Sileo Cydia 安装后 确保服务端正在正常运行 以及确保iPhone端的frida-server的确正在运行，正常运行中： iPhone8-150:~ root# ps -A | grep frida 2150 ?? 0:00.02 /usr/sbin/frida-server 2194 ttys000 0:00.00 grep frida frida的位置和版本 安装frida后，可以查看iPhone中的frida的位置和版本： iPhone8-150:~ root# frida-server --version 16.0.10 iPhone8-150:~ root# which frida-server /usr/sbin/frida-server iPhone8-150:~ root# ls /usr/sbin/frida-server /usr/sbin/frida-server* frida插件详情 frida插件 详情页 Sileo Cydia 已安装的文件 列表 /Library/LaunchDaemons/re.frida.server.plist /usr/lib/frida/frida-agent.dylib /usr/sbin/frida-server 图： Sileo Cydia crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-07-22 15:16:20 "},"install_upgrade/install_frida/mobile/android.html":{"url":"install_upgrade/install_frida/mobile/android.html","title":"Android","keywords":"","body":"Android 此处介绍，移动端的Android安卓中，如何安装Frida（的server）。 前提 安卓手机已root 安装步骤 概述 安装Magisk插件：MagiskFrida 详解 安卓手机中安装frida-server 背景 由于之前手动从下载frida-server并放到安卓手机Pixel3中，结果后续会报错Failed to enumerate processes connection closed，而无法使用 最后解决办法是：安装Magisk的插件： ViRb3/magisk-frida: 🔐 Run frida-server on boot with Magisk, always up-to-date 具体步骤 下载到此处最新版的：MagiskFrida的zip包 https://github.com/ViRb3/magisk-frida/releases/download/16.1.3-1/MagiskFrida-16.1.3-1.zip 得到：MagiskFrida-16.1.3-1.zip （用adb push）传输到安卓手机中（的下载目录） 然后去： Magisk->模块->从本地安装->找到并点击MagiskFrida-16.1.3-1.zip->开始自动安装->重启 重启安卓手机后，都可以看到Magisk中的插件：MagiskFrida 安装后 确保frida-server正常运行 （以后）每次重启安卓手机后，都会自动运行frida-server blueline:/ # ps -A | grep frida root 4408 1321 10877092 3696 do_sys_poll 0 S frida-server 后续即可正常使用Frida。 Mac中用确认frida工具MagiskFrida是否可用 此处的MagiskFrida，也并不是很完美，但是也基本够用。 具体细节是： 可用的 frida-psfrida-ps -U frida-ps -Uai fridafrida -U -F com.example.displaydemo frida-tracefrida-trace -U -F com.example.displaydemo -i open 不可用 frida-ls➜ frida frida-ls -U Failed to retrieve listing: Error: Invalid mode: 0x0 at I (agent.ts:274) at L (agent.ts:274) at ls (agent.ts:274) at apply (native) at (frida/runtime/message-dispatcher.js:13) at c (frida/runtime/message-dispatcher.js:23) 暂时无法解决 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-07-22 15:23:28 "},"install_upgrade/upgrade_frida.html":{"url":"install_upgrade/upgrade_frida.html","title":"升级Frida","keywords":"","body":"升级Frida 什么时候才要升级Frida版本？ 当遇到如下场景时，（可能）需要升级Frida： 当（两端的）Frida版本不匹配时 （iPhone等）移动端中的Frida版本 查看现有版本frida-server --version （Mac等）PC端的Frida的版本 查看现有版本frida --version Frida有新版可用，想要升级到最新版 举例 Sileo中提示Frida有新版本16.0.11 Cydia中提示有新版本Frida 如何升级Frida版本？ 和安装Frida类似，也是分2部分： PC端 Mac 用pip升级Fridapip install --upgrade frida 如果需要，也去同时升级frida-toolspip install --upgrade frida-tools 移动端 Android 重复之前 安装Magisk插件：MagiskFrida 的步骤，只是下载时，下载最新版本的MagiskFrida的zip包即可 iOS(iPhone) 用（Cydia/Sileo等）包管理器，升级Frida到最新版 如何安装指定版本的Frida？ TODO：找之前如何指定frida版本，当用pip安装时 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-07-22 15:09:40 "},"use_frida/":{"url":"use_frida/","title":"使用Frida","keywords":"","body":"使用Frida crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-22 22:08:11 "},"use_frida/typical_logic/":{"url":"use_frida/typical_logic/","title":"Frida典型使用逻辑","keywords":"","body":"Frida典型使用逻辑 先搞懂大的概念 从逻辑概念角度分 核心工具：frida命令行 辅助工具：frida-tools 包括frida-trace、frida-ps、frida-ls等工具 从使用角度分 最常用：frida命令行 分析调试逻辑的主力工具 经常用：frida-trace 分析函数调用堆栈关系 偶尔用：frida-tools（包括frida-ps、frida-ls等） 其他辅助用途，比如查看进程PID等 去hook调试iPhone中的app或二进制 = Frida典型使用逻辑 准备工作 先要搞懂当前连接了哪些iPhone设备：frida-ls-deviecs 再去搞懂要去hook的目标（app或二进制）：frida-ps （或ssh连接的iPhone中的ps） 辅助：查看iPhone中有哪些相关文件：frida-ls 真正去hook调试 前期用=经常用：frida-trace -》调试（app页面操作过程中都）调用了哪些ObjC的（类和）函数 后期用=最常用：frida -》 写js去调试具体的ObjC的函数 具体干什么 查看 传入的参数的类型和值 函数调用堆栈 微调=改动 （临时）修改传入参数的值-》研究程序逻辑变化 （临时）修改返回值-》研究程序逻辑变化 常用到的内部功能 主要是：Interceptor（的Interceptor.attach）-》 去拦截=触发=hook对应的类的函数 偶尔用：ApiResolver -》 （模糊）搜索有哪些类，类有哪些函数等 高级用法：Stalker -》 研究（被混淆的）代码实际的执行过程和逻辑等 用Frida辅助iOS逆向的思路 iOS逆向开发心得=思路：利用frida，打印函数调用 -》找到url、找到全部被调函数 对于iOS逆向的话，有空试试 frida的hook。 就像之前别的某一个iOS技术人员沟通的方法：Hook所有方法调用 比如 估计是 hook objc_msgSend 这类函数？ 都打印出来 就知道调用了哪些类的哪些函数了，甚至可以加上额外的统计调用次数之类的。 以及也可以把后面的几个参数的值，只要是字符串的也都打印出来。 另外去hook url调用HTTP的。 估计也是能轻易的搞清楚当前调用过哪些网络请求以及相关的什么参数。 估计就能找出来NSUrlRequet之类的相关调用和url和其他参数。 总之有空还是去多试试frida的hook。 【后记1】 其实就是所有类的所有方法 之前试过，效果还行。 不过要排除掉输出太多的，否则容易卡死崩溃。 【后记2】 有机会去试试： frida去hook： objc_msgSend函数 看看有多少objc的函数调用 不过突然想到，貌似就是：frida-trace加上-m *[* *]的意思？ 【后记3】 Hook所有方法调用 看来应该是： 用Frida去hook：所有类的所有方法？ 或者是：frida-trace去hook所有类的所有方法 又或者是：只hook objc_msgSend方法？这样也能打印出所有ObjC函数的调用 有空去试试 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-27 22:44:28 "},"use_frida/frida_cli/":{"url":"use_frida/frida_cli/","title":"frida","keywords":"","body":"frida frida 是什么：命令行工具 frida是Frida整个系统中，最基础，用的最多的，命令行工具 官网称之为：frida-CLI 文档 frida-cli 安装frida Mac中用Python安装frida pip3 install frida help语法帮助 ➜ frida-trace frida --help usage: frida [options] target positional arguments: args extra arguments and/or target options: -h, --help show this help message and exit -D ID, --device ID connect to device with the given ID -U, --usb connect to USB device -R, --remote connect to remote frida-server -H HOST, --host HOST connect to remote frida-server on HOST --certificate CERTIFICATE speak TLS with HOST, expecting CERTIFICATE --origin ORIGIN connect to remote server with “Origin” header set to ORIGIN --token TOKEN authenticate with HOST using TOKEN --keepalive-interval INTERVAL set keepalive interval in seconds, or 0 to disable (defaults to -1 to auto-select based on transport) --p2p establish a peer-to-peer connection with target --stun-server ADDRESS set STUN server ADDRESS to use with --p2p --relay address,username,password,turn-{udp,tcp,tls} add relay to use with --p2p -f TARGET, --file TARGET spawn FILE -F, --attach-frontmost attach to frontmost application -n NAME, --attach-name NAME attach to NAME -N IDENTIFIER, --attach-identifier IDENTIFIER attach to IDENTIFIER -p PID, --attach-pid PID attach to PID -W PATTERN, --await PATTERN await spawn matching PATTERN --stdio {inherit,pipe} stdio behavior when spawning (defaults to “inherit”) --aux option set aux option when spawning, such as “uid=(int)42” (supported types are: string, bool, int) --realm {native,emulated} realm to attach in --runtime {qjs,v8} script runtime to use --debug enable the Node.js compatible script debugger --squelch-crash if enabled, will not dump crash report to console -O FILE, --options-file FILE text file containing additional command line options --version show program's version number and exit -l SCRIPT, --load SCRIPT load SCRIPT -P PARAMETERS_JSON, --parameters PARAMETERS_JSON parameters as JSON, same as Gadget -C USER_CMODULE, --cmodule USER_CMODULE load CMODULE --toolchain {any,internal,external} CModule toolchain to use when compiling from source code -c CODESHARE_URI, --codeshare CODESHARE_URI load CODESHARE_URI -e CODE, --eval CODE evaluate CODE -q quiet mode (no prompt) and quit after -l and -e -t TIMEOUT, --timeout TIMEOUT seconds to wait before terminating in quiet mode --pause leave main thread paused after spawning program -o LOGFILE, --output LOGFILE output to log file --eternalize eternalize the script before exit --exit-on-error exit with code 1 after encountering any exception in the SCRIPT --kill-on-exit kill the spawned program when Frida exits --auto-perform wrap entered code with Java.perform --auto-reload Enable auto reload of provided scripts and c module (on by default, will be required in the future) --no-auto-reload Disable auto reload of provided scripts and c module crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-23 08:14:57 "},"use_frida/frida_cli/debug_target.html":{"url":"use_frida/frida_cli/debug_target.html","title":"调试目标方式","keywords":"","body":"Frida调试目标的方式 背景知识 iOS的进程的类型 iOS的进程有2类： app=Bundle=软件包 举例 （iOS系统自带的）设置app=包名是：com.apple.Preferences Executable=可执行文件=二进制文件 举例 （AppleMediaServices.framework 的 ）amsaccountsd frida和frida-trace是调试目标的方式的逻辑是一样的 frida --help 和： frida-trace --help 都可以看到对应help语法： -f TARGET, --file TARGET spawn FILE -F, --attach-frontmost attach to frontmost application -n NAME, --attach-name NAME attach to NAME -N IDENTIFIER, --attach-identifier IDENTIFIER attach to IDENTIFIER -p PID, --attach-pid PID attach to PID -W PATTERN, --await PATTERN await spawn matching PATTERN frida/frida-trace调试目标的方式 frida/frida-trace的调试目标方式 概述 支持2种模式：Spawn和Attach Spawn模式：只有一种写法 -f TARGET TARGET是 app包名 或 Executable二进制文件名 Attach模式：有多种写法=针对app或Executable有不同写法 同时支持app或Executable的：-p PID PID是app或Executable的进程ID 针对Executable的： -n NAME NAME是Executable的二进制文件名，比如amsaccountsd 针对app的：-N IDENTIFIER IDENTIFIER是app的包名，比如com.apple.Prefrences 特殊的：针对当前手机中正在运行的frontmost最前台的：-F 由于是，当前最前台的正在运行的= 那只能是带页面显示的app，且也无需再加额外参数指定app 详解 frida/frida-trace的调试目标方式的详细解释： Spawn模式：孵化出新进程 典型使用场景：app/Executable还没运行，想要从app/Executable刚开始启动就去hook调试 语法 -f TARGET, --file TARGET spawn FILE 举例frida -U -f com.apple.Preferences 说明 TARGET：是 APP包名 或 Executable二进制文件名？ spawn方式启动后，会立刻暂停运行 需要继续运行，需要手动输入：%resume 如果不想要每次spawn启动后暂停，则可以加上参数：--no-pause 注：旧版本才有--no-pause，新版本已不支持--no-pause Attach模式：挂载到一个已经正在运行的进程 典型使用场景：app/Executable已经在运行了，想要hook调试相关逻辑 常见写法 针对于app的 frida -N com.app.identifier 语法 -N IDENTIFIER, --attach-identifier IDENTIFIER attach to IDENTIFIER 举例frida -U -N com.apple.Preferences 说明 如何查看到app的包名 Mac中用frida-psfrida-ps -Ua frida-ps -Uai frida -F 语法 -F, --attach-frontmost attach to frontmost application 举例 当前iPhone中正在显示设置app的界面frida -U -F 说明 F=Frontmost=Focused 在操作之前，确保要调试的app，处在前台=正在运行=当前界面 针对于Executable的 frida -n executableFilename 语法 -n NAME, --attach-name NAME attach to NAME 举例frida -U -n amsaccountsd 针对于 app 或 Executable 的 frida -p PID 语法 -p PID, --attach-pid PID attach to PID 举例 12886是msaccountsd的PIDfrida -U -p 12886 19641是com.apple.Preferences的进程IDfrida -U -p 19641 说明 如何获取PID iPhone中通过ssh运行psps -A | grep yourAppOrExecutableName Mac中用frida-psfrida-ps -U frida-ps -Ua 注意事项 如果调试方式对应参数使用有误，是无法正常调试的 举例 对于app，用-n（而不是-N），会报错 对于app：系统内置的应用：Preferences（包名com.apple.Preferences） 虽然也有对应的二进制文件：/Applications/Preferences.app/Preferences 但是是无法通过Executable的Attach参数去启动的 即，下面写法是无效的，会报错的：➜ ~ frida-trace -U -n Preferences Failed to spawn: unable to find process with name 'Preferences' 如果用-N出现异常情况，则可考虑换用-F 举例 Frida调试设置app 用-N 包名 或 -F不加包名frida-trace -U -N com.apple.Preferences -O Preferences_accoutLogin_hook.txt frida-trace -U -F -O Preferences_accoutLogin_hook.txt -> 就会导致：设置app异常 -》点击登录iPhone，会出现弹框：接入互联网以登录iPhone，好像是：此时设置app无法联网了 而换用-F 包名去调试frida-trace -U -F com.apple.Preferences -O Preferences_accoutLogin_hook.txt -> 就一切正常，设置app工作正常，点击登录iPhone，可以出现Apple ID登录页 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-22 21:59:31 "},"use_frida/frida_cli/js_script.html":{"url":"use_frida/frida_cli/js_script.html","title":"写js脚本","keywords":"","body":"写js脚本 frida的利用方式，从使用角度来说，主要分2类： frida-trace：无需js脚本，直接去hook对应的函数 frida ... -l xxx.js：最常见的用法，通过js脚本实现自己的功能 即，写js脚本，再用frida去加载调用 js脚本文件的类型 + 利用js脚本的方式 最早的，大家用的最多的，最常见的：.js文件=JavaScript文件 对应用法frida ... -l xxx.js 举例frida -U -p 8229 -l hookAccountLogin_singleClassSingleMethod.js 最新的，官网推荐的：.ts文件=TypeScript文件 对应用法frida ... -l xxx.ts js脚本的来源 可以自己写 比如 iOS的ObjC 中的各种例子 也可以，借用别人已有的 比如 Frida Codeshare js脚本中的内容 主要取决于你的具体使用方法 根据使用场景分，主要有3种： Interceptor=拦截器 作用：去实现hook函数，打印参数等调试操作 效果：每次匹配到（对应函数），都会触发执行js代码 举例：Interceptor=hook函数 ApiResolver=解析器 效果：只运行一次 只有第一次（解析时）匹配到，才会执行，后续代码运行期间，不再去（匹配）执行 作用 如果有些情况需要批量 Hook，比如对某一个类的所有方法进行 Hook，或者对某个模块的特定名称的函数进行 Hook，可能我们并不知道准确的名称是什么，只知道大概的关键字，这种情况怎么 Hook 呢？这时就得使用 API查找器（ApiResolver）先把感兴趣函数给找出来，得到地址之后就能 Hook了 举例：ApiResolver Stalker = 跟踪器 效果：跟踪代码的实际运行的过程 期间可以打印和查看对应的值，便于实现调试真正代码运行的逻辑 详见：Frida的Stalker 举例：Stalker crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-27 23:00:47 "},"use_frida/frida_cli/typical_usage.html":{"url":"use_frida/frida_cli/typical_usage.html","title":"典型使用方式","keywords":"","body":"Frida的典型使用方式 在搞懂了调试目标方式和写js脚本后，再来介绍 Frida的典型使用方式 用哪个命令？ 主要是用：frida 大都是都是frida然后加上-l xxx.js加上js脚本，实现自己特定的调试的目的 偶尔使用：frida-trace 偶尔直接用frida-trace，加上要hook的类或函数，去追踪代码执行过程中，调用到哪些函数 常见写法 = 怎么用？ 命令行中使用 frida xxx frida-trace xxx （其中xxx中）常用参数有 要调试的设备用：-U -U：调试的是USB连接的移动端的设备（比如iPhone） 要调试的目标app/二进制：-p PID / -n executableName / -N com.app.identifier / -F / -F com.app.identifier 有多种写法，选择合适的一个即可 app或二进制均支持 通过PID指定进程：-p PID 仅支持二进制 通过-n指定二进制可执行文件名：-n executableName 仅支持app 通过-N指定app的包名：-N com.app.identifier 通过-F指定当前最顶层正在运行的app：-F 有时候可以额外给-F再加上app的包名，效果更好：-F com.app.identifier -》所以常见写法举例 frida 无需js：直接动态交互式的调试frida -U -f com.apple.Preferences 需要js：实现特定调试目的 自己写js 使用-p指定进程PIDfrida -U -F -p 18533 -l ./hookAccountLogin_Interceptor.js -U：调试的设备是（当前Mac用）USB连接的iPhone -F -p 18533：调试的app是 -F：表示是当前最前端显示的app -p 18533：（额外）加上PID，指定app的进程ID -l ./hookAccountLogin_Interceptor.js：所要具体调试的内容，放在js中 使用-n指定二进制文件名=进程名=ProcessNamefrida -U -n akd -l ./fridaStalker_akdSymbol2575.js -n akd：要调试的目标是，进程名=二进制名是akd的进程 注：akd=AuthKit的daemon进程 借助别人的jsfrida --codeshare lichao890427/ios-utils -F com.apple.Preferences frida-trace 用frida-trace追踪Preferences设置中Apple账号登录过程调用了哪些函数frida-trace -U -F com.apple.Preferences -m \"*[AA* *]\" -m \"*[AK* *]\" -m \"*[AS* *]\" -m \"*[NSXPC* *]\" -M \"-[ASDBundle copyWithZone:]\" -M \"-[ASDInstallationEvent copyWithZone:]\" -M \"-[NSXPCEncoder _encodeArrayOfObjects:forKey:]\" -M \"-[NSXPCEncoder _encodeUnkeyedObject:]\" -M \"-[NSXPCEncoder _replaceObject:]\" -M \"-[NSXPCEncoder _checkObject:]\" -M \"-[NSXPCEncoder _encodeObject:]\" -M \"-[NSXPCConnection replacementObjectForEncoder:object:]\" 说明 -U -F com.apple.Preferences：调试目标设备和目标app是和frida写法一致 但是后续要trace的函数写法，是frida-trace所特有的语法： -m xxx：include=包含要调试的Objc的类 -M xxx：exclue=排除掉Objc的类，不调试 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-23 23:15:37 "},"use_frida/frida_cli/ios_objc/":{"url":"use_frida/frida_cli/ios_objc/","title":"iOS的ObjC","keywords":"","body":"Frida中iOS的ObjC Frida支持hook调试iOS的ObjC的类和函数。 Frida的ObjC 官网文档 Frida API - ObjC ObjC.available ObjC.api ObjC.classes ObjC.Object ObjC.protocols ObjC.Protocol ObjC.mainQueue ObjC.schedule(queue, work) new ObjC.Object(handle[, protocol]) new ObjC.Protocol(handle) new ObjC.Block(target[, options]) ObjC.implement(method, fn) ObjC.registerProxy(properties) ObjC.registerClass(properties) ObjC.registerProtocol(properties) ObjC.bind(obj, data) ObjC.unbind(obj) ObjC.getBoundData(obj) ObjC.enumerateLoadedClasses([options, ]callbacks) ObjC.enumerateLoadedClassesSync([options]) ObjC.choose(specifier, callbacks) ObjC.chooseSync(specifier) ObjC.selector(name) ObjC.selectorAsString(sel) 常用工具类 iOS Utils 下面继续介绍，关于Frida中ObjC的基本逻辑： crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-23 23:29:20 "},"use_frida/frida_cli/ios_objc/objc_para.html":{"url":"use_frida/frida_cli/ios_objc/objc_para.html","title":"ObjC的参数","keywords":"","body":"Frida中ObjC的参数 当触发到Interceptor.attach的onEnter函数后 举例：相关的典型的代码function hook_specific_method_of_class(className, funcName) { var curClass = ObjC.classes[className]; if (typeof(curClass) !== 'undefined') { var curMethod = curClass[funcName]; if (typeof(curMethod) !== 'undefined') { Interceptor.attach(curMethod.implementation, { onEnter: function(args) { ... 传入Frida中iOS的ObjC的参数 == ObjC的底层函数objc_msgSend的参数 注：objc_msgSend函数的定义id objc_msgSend(id self, SEL _cmd, ...) 此时默认参数名叫做args的参数 == 是一个参数的数组列表，每个元素的类型是NativePointer 此时对应（Frida中iOS的ObjC）的参数逻辑是： 第一个参数 = args[0] == objc_msgSend的self(类型是id) 第二个参数 = args[1] == objc_msgSend的_cmd（类型是SEL） 后续才是：真正的函数的参数 函数的真正的第1个参数 = args[2] 函数的真正的第2个参数 = args[3] ... Frida中获取ObjC的参数 第一个参数args[0] 获取第一个参数args[0] // args[0] is self = id const argSelf = args[0]; console.log(\"argSelf: \", argSelf); 典型log输出argSelf: 0x105744c00 第二个参数args[1] 获取第二个参数args[1]： // args[1] is selector const argSel = args[1]; console.log(\"argSel: \", argSel); 典型log输出argSelf: 0x105744c00 ObjC函数的真正参数 获取 函数的真正的第1个参数 = args[2] // args[2] holds the first function argument const args2 = args[2]; console.log(\"args2: \", args2); 典型log输出args2: 0x105743850 获取 函数的其他更多参数（如果有的话） const args3 = args[3]; console.log(\"args3: \", args3); const args4 = args[4]; console.log(\"args4: \", args4); ... 计算ObjC的函数的真正参数的个数 + 打印全部参数 TODO：把这部分代码，整理成 独立的工具类函数，转移到：工具类函数 根据ObjC的基础知识，目前得知：可以通过SEL=selector字符串中的:=冒号的个数，判断后续真正有几个参数 所以，可以用如下代码，循环的、批量的、挨个、打印所有参数： /** Function that count occurrences of a substring in a string; * @param {String} string The string * @param {String} subString The sub string to search for * @param {Boolean} [allowOverlapping] Optional. (Default:false) * * @author Vitim.us https://gist.github.com/victornpb/7736865 * @see Unit Test https://jsfiddle.net/Victornpb/5axuh96u/ * @see https://stackoverflow.com/a/7924240/938822 */ function occurrences(string, subString, allowOverlapping) { // console.log(\"string=\" + string + \",subString=\" + subString + \", allowOverlapping=\" + allowOverlapping) string += \"\"; subString += \"\"; if (subString.length = 0) { ++n; pos += step; } else break; } return n; } ... function hook_specific_method_of_class(className, funcName) { var iOSObjCallStr = toiOSObjcCall(className, funcName) // var hook = ObjC.classes[className][funcName]; // var hook = eval('ObjC.classes.' + className + '[\"' + funcName + '\"]'); var curClass = ObjC.classes[className]; if (typeof(curClass) !== 'undefined') { var curMethod = curClass[funcName]; if (typeof(curMethod) !== 'undefined') { Interceptor.attach(curMethod.implementation, { onEnter: function(args) { console.log(\"=========== [*] Detected call to: \" + iOSObjCallStr); ... const argSelStr = ObjC.selectorAsString(argSel); console.log(\"argSelStr: \", argSelStr); const argCount = occurrences(argSelStr, \":\"); // console.log(\"funcName=\", funcName); // const argCount = occurrences(funcName, \":\"); // console.log(\"argCount: \", argCount); for (let curArgIdx = 0; curArgIdx 某次的输出日志的效果： =========== [*] Detected call to: +[NSURLRequest requestWithURL:cachePolicy:timeoutInterval:] funcName= + requestWithURL:cachePolicy:timeoutInterval: argSelStr: requestWithURL:cachePolicy:timeoutInterval: argCount: 3 ---------- [0] curArgPtr=0x2831f2530 curArgPtrObj: https://setup.icloud.com/setup/signin/v2/login curArgPtrObj className: NSURL ---------- [1] curArgPtr=0x0 ---------- [2] curArgPtr=0x0 注意： 当Frida调试期间，输出log日志太多，或者打印参数太多时，经常会导致app或进程崩溃而无法继续调试 所以当遇到Frida调试导致的崩溃问题时，可以适当的减少log日志的输出，以缓解崩溃问题 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-23 23:44:27 "},"use_frida/frida_cli/ios_objc/objc_var_type.html":{"url":"use_frida/frida_cli/ios_objc/objc_var_type.html","title":"ObjC的变量类型","keywords":"","body":"Frida中ObjC的变量类型 通用逻辑 获取ObjC的某个类 写法：ObjC.classes.someClassName == ObjC.classes[someClassName] 举例 ObjC.classes.NSMutableData.data() ObjC.classes.NSString.stringWithString_(\"Crifan Li\") ObjC的Object 此处的第一个参数和后续的真正的函数的（第一个以及后续的其他）参数，往往是个（iOS中ObjC的）Class或Instance，在Frida中对应的叫做： ObjC的Object ObjC的Object的常见的操作 转换为ObjC的类 const argSelf = args[0] const argSelfObj = new ObjC.Object(argSelf) const args2 = args[2] const args2Obj = new ObjC.Object(args2) // const args2Obj = new ObjC.Object(ptr(args2)) 以及紧接着的： 打印类的信息 console.log(\"argSelfObj: \", argSelfObj) console.log(\"args2Obj: \", args2Obj) 典型log输出 argSelfObj: connection from pid 46847 on mach service named com.apple.ak.auth.xpc args2Obj: 以及，把Object转换成String字符串，再去打印 const args2ObjStr = args2Obj.toString(); console.log(\"args2ObjStr: \", args2ObjStr); 典型log输出args2ObjStr: 注：此处从调试输出类的信息的角度来说，往往Object转换成String后再输出的字符串，和上述直接打印Object的效果是一样的 ObjC的Object的特殊属性 对于Frida中的ObjC的Object，有很多内置的特殊的属性： $kind $super $superClass $class $className $moduleName $protocols $methods $ownMethods $ivars 所以，一些常见操作是： $className 查看（当前Object对象的）类名=类的名字 const argSelfClassName = argSelfObj.$className; console.log(\"argSelfClassName: \", argSelfClassName); const args2ObjClassName = args2Obj.$className; console.log(\"args2ObjClassName: \", args2ObjClassName); 典型log输出 argSelfClassName: NSXPCConnection args2ObjClassName: AKAppleIDAuthenticationService $kind 查看（当前Object对象的）类型 const argSelfKind = argSelfObj.$kind; console.log(\"argSelfKind:\", argSelfKind); 典型log输出argSelfKind: instance $methods和$ownMethods 注意 此处的$methods、$ownMethods中的method method的英文单词本意是：方法=函数 但实际上此处：method = 类的property + 类的method 注： property=属性 method=方法=函数 举例：$methods和$ownMethods ObjC的Object的自己类的属性 而对于本身ObjC的类的属性，也是支持访问的： 访问ObjC的自己类的属性的方式：把属性当做函数访问 -》加上括号() 语法：iosObjcObj.propertyName() 举例 获取NSXPCConnection的serviceName 对于Objc的Object对象：argSelfObj: connection from pid 46847 on mach service named com.apple.ak.auth.xpc 去获取其serviceName属性的代码： const connnServiceNameNSStr = argSelfObj.serviceName(); console.log(\"connnServiceNameNSStr: \", connnServiceNameNSStr); 输出logconnnServiceNameNSStr: com.apple.ak.auth.xpc 获取NSString的UTF8String 代码： const connnServiceNameJsStr = connnServiceNameNSStr.UTF8String(); console.log(\"connnServiceNameJsStr: \", connnServiceNameJsStr); 输出logconnnServiceNameJsStr: com.apple.ak.auth.xpc ObjC的Object的自己类的函数 Frida中，是可以调用Objc中类的函数的。 举例：+[NSString stringWithString:] ObjC中NSString的原始函数： +[NSString stringWithString:@\"Hello World\"] 根据规则： 把冒号=:变成下划线=_ 给函数加上括号() 把参数放到括号()中 而变成： const { NSString } = ObjC.classes; NSString.stringWithString_(\"Hello World\"); 或另外一种写法：ObjC.classes.NSString.stringWithString_(\"Hello World\"); 举例：-[NSString cStringUsingEncoding:] ObjC的函数：-[NSString cStringUsingEncoding:] -> Frida中的调用：const NSUTF8StringEncoding = 4; const curJsStr = curNsStr.cStringUsingEncoding_(NSUTF8StringEncoding)` ObjC的selector ObjC中，有个稍微特殊一点的变量，叫做SEL=selector 也就是前面获取到的，第二个参数，类型是SEL SEL的常见操作之一就是：转换成字符串，再去打印const argSel = args[1] const argSelStr = ObjC.selectorAsString(argSel); console.log(\"argSelStr: \", argSelStr); 典型log输出 argSelStr: setExportedObject: ObjC的Protocol ObjC的Block crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-27 23:10:39 "},"use_frida/frida_cli/data_type/":{"url":"use_frida/frida_cli/data_type/","title":"数据类型","keywords":"","body":"数据类型 Frida中典型的数据类型有： Int64 https://frida.re/docs/javascript-api/#int64 UInt64 https://frida.re/docs/javascript-api/#uint64 NativePointer ArrayBuffer https://frida.re/docs/javascript-api/#arraybuffer 其他相关 Function函数 NativeFunction https://frida.re/docs/javascript-api/#nativefunction SystemFunction https://frida.re/docs/javascript-api/#systemfunction Callback回调 NativeCallback https://frida.re/docs/javascript-api/#nativecallback 常见缩写 和数据类型有关的，常见缩写有： int64(v) == new Int64(v) uint64(v) == new UInt64(v) ptr(s) == new NativePointer(s) NULL == ptr(\"0\") crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-23 22:10:37 "},"use_frida/frida_cli/data_type/nativepointer.html":{"url":"use_frida/frida_cli/data_type/nativepointer.html","title":"NativePointer","keywords":"","body":"NativePointer NativePointer 是什么：Frida中一个最基本的变量类型 常简称：ptr 官网文档 NativePointer - JavaScript API NativePointer的函数=支持的操作 NativePointer的函数=支持的操作 new NativePointer(s)：传入字符串，生成NativePointer 大家常用=其简写为：ptr(s) isNull()：判断是否为空 add(rhs), sub(rhs), and(rhs), or(rhs), xor(rhs) shr(n), shl(n) not() sign([key, data]) strip([key]) blend(smallInteger) equals(rhs) compare(rhs) toInt32() toString([radix = 16]) toMatchPattern() readPointer() writePointer(ptr) readS8(), readU8(), readS16(), readU16(), readS32(), readU32(), readShort(), readUShort(), readInt(), readUInt(), readFloat(), readDouble() writeS8(value), writeU8(value), writeS16(value), writeU16(value), writeS32(value), writeU32(value), writeShort(value), writeUShort(value), writeInt(value), writeUInt(value), writeFloat(value), writeDouble(value) readS64(), readU64(), readLong(), readULong() writeS64(value), writeU64(value), writeLong(value), writeULong(value) readByteArray(length) writeByteArray(bytes) readCString([size = -1]), readUtf8String([size = -1]), readUtf16String([length = -1]), readAnsiString([size = -1]) writeUtf8String(str), writeUtf16String(str), writeAnsiString(str) NativePointer的典型用法 一些常见的写法 myOffsetPtr = myBaseAddr.add(ptr('0x76E')) console.log(hexdump(ptr(0x7cbe43acd0))) Memory.protect(ptr('0x1234'), 4096, 'rw-'); ptr('0x7fff870135c9') onEnter中的args frida中最常涉及到NativePointer的地方就是：Interceptor.attach的onEnter中的args，就是一个NativePointer的数组 = an array of NativePointer objects 单个类的单个函数的代码举例中的： const curMethod = ObjC.classes.NSXPCConnection[\"- setExportedObject:\"]; Interceptor.attach(curMethod.implementation, { onEnter: function(args) { const arg0 = args[0] const arg1 = args[1] const arg2 = args[2] console.log(\"args: Objc self id=\" + arg0 + \", SEL=\" + arg1 + \", objcRealArg1=\" + arg2); } }); 中的args，就是NativePointer的数组，所以：arg0、arg1、arg2，都是NativePointer=ptr类型 而典型的后续的操作就是，去转换成对应的类型，去处理 比如： ObjC中，把传入的参数，转换成真正的ObjC的类const argSelf = args[0]; const argSelfObj = new ObjC.Object(argSelf); 用add计算函数地址 Stalker实例代码 中的 var funcRelativeStartAddr = 0xa0460; var functionSize = 0x24C8; // 9416 == 0x24C8 var funcRelativeEndAddr = funcRelativeStartAddr + functionSize; const moduleName = \"akd\"; const moduleBaseAddress = Module.findBaseAddress(moduleName); const funcRealStartAddr = moduleBaseAddress.add(funcRelativeStartAddr); const funcRealEndAddr = funcRealStartAddr.add(functionSize); 中就是用到了Module.findBaseAddress的返回值，类型就是NativePointer，然后： const funcRealStartAddr = moduleBaseAddress.add(funcRelativeStartAddr); 通过add加上起始地址，计算出函数真正的起始地址 const funcRealEndAddr = funcRealStartAddr.add(functionSize); 通过add加上函数大小，计算出真正的结束地址 输出的相关log： funcRelativeStartAddr=656480, functionSize=9416, funcRelativeEndAddr=665896 moduleName=akd, moduleBaseAddress=0x10015c000 funcRealStartAddr=0x1001fc460, funcRealEndAddr=0x1001fe928 注意： 如果是NativePointer类型的变量，直接相加+普通的数值，则结果，不是数值上的相加，而是：数值的字符串拼接 对比 上述代码const funcRealEndAddr = funcRealStartAddr.add(functionSize); 结果：funcRealEndAddr=0x1001fe928 = 0x1001fc460 + 0x24C8 如果改为const funcRealEndAddr = funcRealStartAddr + functionSize; 则结果是：funcRealEndAddr=0x1001fc4609416 = 地址的字符串0x1001fc460 拼接上 9416(=16进制的0x24C8的10进制值) crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-23 23:17:59 "},"use_frida/frida_cli/frida_stalker.html":{"url":"use_frida/frida_cli/frida_stalker.html","title":"Frida的Stalker","keywords":"","body":"Frida的Stalker Frida的Stalker 别称：frida-stalker 有人翻译成：潜行者 作用：汇编指令级别的hook 用途：追踪真实代码指令的执行过程 官网文档 Stalker介绍 API接口 接口形式 普通用户常直接调用：JS的API Stalker - JavaScript API | Frida 内部接口：Gum接口 TypeScript type definitions DefinitelyTyped/index.d.ts 接口内容 最核心接口 Stalker.follow([threadId, options]) 其他 Stalker.exclude(range) Stalker.unfollow([threadId]) Stalker.parse(events[, options]) Stalker.flush() Stalker.garbageCollect() Stalker.invalidate(address) Stalker.invalidate(threadId, address) Stalker.addCallProbe(address, callback[, data]) Stalker.removeCallProbe Stalker.trustThreshold Stalker.queueCapacity Stalker.queueDrainInterval 用法 概述 核心逻辑 在frida命令上，和普通frida一样，都是调用jsfrida -U -n akd -l ./fridaStalker_akdSymbol2575.js js内部逻辑 最初要初始化：计算出当前要hook的函数所属的模块和地址 在普通的Interceptor.attach的onEnter中，加上Stalker.follow 在transform中，计算是否是原始函数的代码 如果是，再去：实现特定的调试的目的 打印真实执行的指令的信息instruction.toString() 打印当时的变量的值context 等等 详解 举例 Stalker示例代码 何时需要用到Frida的Stalker 如下场景： 你想要搞懂该函数内部的执行的逻辑，想要查看哪个函数，甚至是哪个代码块codeblock，被执行了 还比如你想要搞懂，当传入不同参数时，函数内部代码执行的流程路径，是否有何不同。 就可以去用： Stalker.follow() Frida的Stalker中transform的逻辑 Frida的Stalker中transform的逻辑： 除了官网文档： https://frida.re/docs/stalker/ 介绍了内部具体实现机制和过程之外： 对于，想要搞懂如何利用transform去调试代码来说： 需要明白的逻辑是： 此处代码： Interceptor.attach(funcRealStartAddr, { onEnter: function(args) { ... var curTid = Process.getCurrentThreadId(); console.log(\"curTid=\", curTid); Stalker.follow(curTid, { events: { call: true, // CALL instructions: yes please ret: false, // RET instructions exec: false, // all instructions: not recommended as it's block: false, // block executed: coarse execution trace compile: false // block compiled: useful for coverage }, // transform: (iterator: StalkerArm64Iterator) => { transform: function (iterator) { ... 触发到的transform的iterator来说： 每次触发=每个iterator：都（对应着）单个block=（basic）代码块 此处代码块有2种 非原始函数代码 == isAppCode=false 对应着应该是Stalker内部实现原理说的，copy拷贝出的代码 其中会额外加上很多逻辑，用于实现Stalker的功能和逻辑 估计就是这里说的这些内容 [原创] sktrace：基于 Frida Stalker 的 trace 工具-Android安全-看雪-安全社区|安全招聘|kanxue.com 每当执行到一个基本块，Stalker 都会做以下几件事： 对于方法调用，保存 lr 等必要信息 重定位位置相关指令，例如：ADR Xd, label 建立此块的索引，如果此块在达到可信阈值后，内容未曾变化，下次将不再重新编译（为了加快速度） 根据 transform 函数，编译生成一个新的基本块 GumExecBlock ，保存到 GumSlab 。void transform(GumStalkerIterator iterator, GumStalkerOutput output, gpointer user_data) 可以控制读取，改动，写入指令。 transform 过程中还可通过 void gum_stalker_iterator_put_callout (GumStalkerIterator self,GumStalkerCallout callout, gpointer data, GDestroyNotify data_destroy) 来设置一个当此位置被执行到时的 callout。通过此 void callout(GumCpuContext cpu_context, gpointer user_data) 获取 cpu 信息。 执行一个基本快 GumExecBlock，开始下一个基本快 所以无需操作具体内部过程，直接忽略即可 原始函数代码 == isAppCode=true 是实际运行的代码，才是我们所要关注的代码 才会真正的去处理：比如判断是否是对应的（某个偏移量的）代码，然后去打印查看调试寄存器的值等等 此处去通过计算是否是 原始函数代码isAppCode 决定是否处理 具体详见示例代码：___lldb_unnamed_symbol2575$$akd Stalker.follow中的events的属性含义 Stalker.follow中的events的属性含义 概述 Stalker.follow中的events中某个属性是true，含义是：当出现对应指令，则触发对应event事件 详解 属性 对应的属性的含义是 call：call指令 Intel的：call指令 ARM的：BL类的指令 普通的=arm64的：BL、BLR等 arm64e的，带PAC的：BLRAA、BLRAAZ、BLRAB、BLRABZ等 ret：ret指令 exec：所有指令 block：（单个）block的（所有）指令 compile：特殊，（单个）block被编译时，仅用于测试代码覆盖率？ 除去特殊的compile参数，其他几个参数，按照范围大小去划分，更容易理解： exec：所有代码的级别 block：单个代码块的级别 某些特殊指令的级别 call：单独的call指令 ret：单独的ret指令 event事件 会触发onReceive(events)函数 其中可以events是二进制（的blob），需要去用Stalker.parse()解析后才能看懂 -》events和onReceive的作用 暂时不完全懂，只是知道，可以设置参数，决定call、ret等指令的触发时去打印，其他用途暂时不清楚 Stalker.follow()内部实现原理 当用户调用Stalker.follow()时，内部调用： 要么是：gum_stalker_follow_me() ：去跟踪当前的线程thread 函数原型GUM_API void gum_stalker_follow_me (GumStalker * self, GumStalkerTransformer * transformer, GumEventSink * sink); 底层JS引擎：是QuickJS或V8 要么是：gum_stalker_follow(thread_id)：去跟踪当前process进程中的其他某个线程thread gum_stalker_follow_me的内部原理 #ifdef __APPLE__ .globl _gum_stalker_follow_me _gum_stalker_follow_me: #else .globl gum_stalker_follow_me .type gum_stalker_follow_me, %function gum_stalker_follow_me: #endif stp x29, x30, [sp, -16]! mov x29, sp mov x3, x30 #ifdef __APPLE__ bl __gum_stalker_do_follow_me #else bl _gum_stalker_do_follow_me #endif ldp x29, x30, [sp], 16 br x0 -》 内部原理 LR=Link Register=X30=链接寄存器 AArch64架构中，根据LR去决定从哪里开始跟踪 当遇到BR，BLR等跳转指令时，会去设置LR LR被设置为，当前函数返回后，继续运行的地址 由于只有一个LR，如果被调用函数调用了其他函数，此时LR的值就会被保存起来，比如保存到Stack栈上，后续当RET指令执行之前，会重新把LR从Stack栈中加载到寄存器中，最终返回到调用者 FP=Frame Pointer=X29=帧指针 FP始终指向Stack top栈的顶部，表示当前函数被调用时的栈的位置 所以就可以通过固定的偏移量去访问到，所有通过Stack栈传入的参数和基于栈的局部变量 且每个函数都有自己的FP，所以需要调用新函数时，保存之前的FP，返回之前函数时，恢复FP。 在刚进入新函数后，备份FP后，就可以去设置：mov x29, sp，把SP给X29=FP了。 保持了原先传入x0-x2的3个参数，额外加上x3=x30=LR，所以再去调用函数，就对应上参数了： gpointer_gum_stalker_do_follow_me (GumStalker * self, GumStalkerTransformer * transformer, GumEventSink * sink, gpointer ret_addr) gum_stalker_follow的内部原理 和gum_stalker_follow_me()类似，但有额外参数：thread_id void gum_stalker_follow (GumStalker * self, GumThreadId thread_id, GumStalkerTransformer * transformer, GumEventSink * sink) { if (thread_id == gum_process_get_current_thread_id ()) { gum_stalker_follow_me (self, transformer, sink); } else { GumInfectContext ctx; ctx.stalker = self; ctx.transformer = transformer; ctx.sink = sink; gum_process_modify_thread (thread_id, gum_stalker_infect, &ctx); } } 其中：gum_process_modify_thread()，不属于Stalker，但属于Gum 回调callback会去修改：GumCpuContext GumCpuContext GumCpuContext的定义： typedef GumArm64CpuContext GumCpuContext; struct _GumArm64CpuContext { guint64 pc; guint64 sp; guint64 x[29]; guint64 fp; guint64 lr; guint8 q[128]; }; 相关： static void gum_stalker_infect (GumThreadId thread_id, GumCpuContext * cpu_context, gpointer user_data) gum_process_modify_thread() 内部实现 Linux/Android：ptrace GDB也用的这个：挂载到进程上，读写寄存器 Stalker每次只处理一个代码块block 内部机制： 新申请一块内存，写入给原始代码中加了调试代码后的代码 加的指令，用于生成事件、提供其他Stalker所支持的功能。 以及根据情况去relocate重定位指令代码。 比如对于下面代码，要重定位： ADR Address of label at a PC-relative offset. ADR Xd, label Xd Is the 64-bit name of the general-purpose destination register, in the range 0 to 31. label Is the program label whose address is to be calculated. It is an offset from the address of this instruction, in the range ±1MB. 底层通过Gum的Relocator frida-gum/gumarm64relocator.c at main · frida/frida-gum · GitHub 现在，回想一下我们说过潜行者一次工作一个块。那么我们如何检测下一个块呢？我们还记得每个块也以分支指令结尾，如果我们修改这个分支以分支回 Stalker 引擎，但确保我们存储分支打算结束的目的地，我们可以检测下一个块并在那里重定向执行。这个相同的简单过程可以一个接一个地继续。 Stalker=潜行者 现在，这个过程可能有点慢，因此我们可以应用一些优化。首先，如果我们多次执行相同的代码块（例如循环，或者可能只是一个多次调用的函数），我们不必重新检测它。我们可以重新执行相同的检测代码。出于这个原因，我们保留了一个哈希表，其中包含我们之前遇到的所有块以及我们放置块的检测副本的位置。 其次，当遇到呼叫指令时，在发出检测的呼叫后，我们随后会发出一个着陆板，我们可以返回该着陆板而无需重新进入 Stalker。Stalker使用记录真实返回地址（real_address）和此着陆垫（code_address）的GumExecFrame结构构建了一个侧堆栈。当一个函数返回时，我们发出代码，该代码将根据real_address检查侧堆栈中的返回地址，如果匹配，它可以简单地返回到code_address，而无需重新进入运行时。这个着陆板最初将包含进入 Stalker 引擎以检测下一个块的代码，但稍后可以将其反向修补以直接分支到该块。这意味着可以处理整个返回序列，而无需输入和离开 Stalker。 如果返回地址与存储的GumExecFrame real_address不匹配，或者我们在侧堆栈中的空间不足，我们只需从头开始重新构建一个新的。我们需要在应用程序代码执行时保留 LR 的值，以便应用程序不能使用它来检测 Stalker 的存在（反调试），或者如果它将其用于除简单返回之外的任何其他目的（例如，在代码部分中引用内联数据）。此外，我们希望 Stalker 能够随时取消关注，所以我们不想不得不返回我们的堆栈来更正我们在此过程中修改的 LR 值。 最后，虽然我们总是用对 Stalker 的调用来替换分支以检测下一个块，但根据 Stalker.trustThreshold 的配置，我们可能会对此类检测代码进行反向修补，以将调用替换为下一个检测块的直接分支。确定性分支（例如，目的地是固定的，分支不是有条件的）很简单，我们可以将分支替换为下一个块。但是我们也可以处理条件分支，如果我们检测两个代码块（一个是分支，一个是不是）。然后，我们可以将原始条件分支替换为一个条件分支，该条件分支将控制流定向到获取分支时遇到的块的检测版本，然后是另一个检测块的无条件分支。我们还可以部分处理目标不是静态的分支。假设我们的分支是这样的： BR X0 这种指令在调用函数指针或类方法时很常见。虽然 X0 的值可以更改，但通常它实际上总是相同的。在这种情况下，我们可以将最终的分支指令替换为代码，该代码将 X0 的值与我们的已知函数进行比较，如果它将分支与代码的检测副本的地址匹配。然后，如果不匹配，则可以将无条件分支返回到 Stalker 引擎。因此，如果函数指针 say 的值发生了变化，那么代码仍然有效，无论我们最终到达哪里，我们都将重新输入 Stalker 和乐器。但是，如果如我们预期的那样它保持不变，那么我们可以完全绕过 Stalker 引擎并直接进入仪器化功能。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-25 23:53:53 "},"use_frida/frida_trace/":{"url":"use_frida/frida_trace/","title":"frida-trace","keywords":"","body":"frida-trace frida-trace 官网文档 frida-trace 官网代码 frida-tools/frida_tools/tracer.py 核心参数解释 调试目标方式 frida-trace去hook调试的目标的写法，是和frida是一样的 详见：frida调试目标方式 通用逻辑 -m、-M等参数，支持通配符 *：表示任意个数的字符=所有的（类或方法名） 举例-m \"-[NSURL *]\" // 匹配NSURL类的所有实例方法 -m \"+[NSURL *]\" // 匹配NSURL类的所有类方法 -m \"*[NSURL *]\" // 匹配NSURL类的所有方法 -m \"*[*URL *]\" // 匹配以URL结尾类的所有方法 -m \"*[URL* *]\" // 匹配以URL开头类的所有方法 -m \"*[*URL* *]\" // 匹配包含URL的类的所有方法 -m \"*[*URL* *login*]\" // 匹配包含URL的类的带login的所有方法 注意 不支持：? 如果用了?，则会报错：Error: invalid query; format is: -[NS*Number foo:bar:], +[Foo foo*] or *[Bar baz] 参数 -m 语法：-m OBJC_METHOD, --include-objc-method OBJC_METHOD include OBJC_METHOD 含义：（要去hook的）包含的ObjC的（类和）方法 -M 语法：-M OBJC_METHOD, --exclude-objc-method OBJC_METHOD exclude OBJC_METHOD 含义：（ 不要hook的）排除掉的ObjC的（类和）方法 -O 语法：-O FILE, --options-file FILE text file containing additional command line options 含义：用Option文件，包含额外的命令行参数 典型用法是，觉得-m、-M等要去hook和要去排除掉的类和方法，太多了，就转去放到Option文件中 举例 概述 hook调试Preferences：-m、-M等参数直接放到命令行中 hook单个的类：AAUISignInViewControllerfrida-trace -U -F com.apple.Preferences -m \"*[AAUISignInViewController *]\" （用*匹配）去hook多个类，且排除特定（实际上会输出很多次但对调试逻辑没帮助）的函数frida-trace -U -F com.apple.Preferences -m \"*[AA* *]\" -M \"-[ASDBundle copyWithZone:]\" -M \"-[* copyWithZone:]\" -M \"-[AAUILabel *]\" 通用参数含义说明 -U -F com.apple.Preferences：调试目标设备和目标app是和frida写法一致 -U：调试设备是（Mac中通过）USB连接的iPhone -F com.apple.Preferences：调试的app是当前iPhone中，最前端所显示的app = 设置app = 包名是com.apple.Preferences 但是后续要trace的函数写法，是frida-trace所特有的语法 -m xxx：include=包含要调试的Objc的类 -M xxx：exclue=排除掉Objc的类，不调试 hook调试akd：觉得-m、-M等参数太多，则放到-O的Option文件中frida-trace -U -n akd -O akdObjcMethods.txt Option文件akdObjcMethods.txt-m \"*[AA* *]\" -m \"*[AK* *]\" -m \"*[AS* *]\" -m \"*[NSXPC* *]\" -M \"-[NSXPC*coder *]\" -M \"-[NSXPCConnection replacementObjectForEncoder:object:]\" 一些用法frida-trace -U -i \"CCCryptorCreate*\" Twitter frida-trace --decorate -i \"recv*\" -i \"send*\" Safari frida-trace -m \"-[NSView drawRect:]\" Safari frida-trace -U -f com.toyopagroup.picaboo -I \"libcommonCrypto*\" frida-trace -U -f com.google.android.youtube --runtime=v8 -j '*!*certificate*/isu' frida-trace -U -i \"Java_*\" com.samsung.faceservice frida-trace -p 1372 -i \"msvcrt.dll!*mem*\" frida-trace -p 1372 -i \"*open*\" -x \"msvcrt.dll!*open*\" frida-trace -p 1372 -a \"libjpeg.so!0x4793c\" 详见 frida-trace的iOS的ObjC的举例 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-10-26 09:06:38 "},"use_frida/frida_trace/help.html":{"url":"use_frida/frida_trace/help.html","title":"help语法","keywords":"","body":"frida-trace的help语法 ➜ ~ frida-trace --help usage: frida-trace [options] target positional arguments: args extra arguments and/or target options: -h, --help show this help message and exit -D ID, --device ID connect to device with the given ID -U, --usb connect to USB device -R, --remote connect to remote frida-server -H HOST, --host HOST connect to remote frida-server on HOST --certificate CERTIFICATE speak TLS with HOST, expecting CERTIFICATE --origin ORIGIN connect to remote server with “Origin” header set to ORIGIN --token TOKEN authenticate with HOST using TOKEN --keepalive-interval INTERVAL set keepalive interval in seconds, or 0 to disable (defaults to -1 to auto-select based on transport) --p2p establish a peer-to-peer connection with target --stun-server ADDRESS set STUN server ADDRESS to use with --p2p --relay address,username,password,turn-{udp,tcp,tls} add relay to use with --p2p -f TARGET, --file TARGET spawn FILE -F, --attach-frontmost attach to frontmost application -n NAME, --attach-name NAME attach to NAME -N IDENTIFIER, --attach-identifier IDENTIFIER attach to IDENTIFIER -p PID, --attach-pid PID attach to PID -W PATTERN, --await PATTERN await spawn matching PATTERN --stdio {inherit,pipe} stdio behavior when spawning (defaults to “inherit”) --aux option set aux option when spawning, such as “uid=(int)42” (supported types are: string, bool, int) --realm {native,emulated} realm to attach in --runtime {qjs,v8} script runtime to use --debug enable the Node.js compatible script debugger --squelch-crash if enabled, will not dump crash report to console -O FILE, --options-file FILE text file containing additional command line options --version show program's version number and exit -I MODULE, --include-module MODULE include MODULE -X MODULE, --exclude-module MODULE exclude MODULE -i FUNCTION, --include FUNCTION include [MODULE!]FUNCTION -x FUNCTION, --exclude FUNCTION exclude [MODULE!]FUNCTION -a MODULE!OFFSET, --add MODULE!OFFSET add MODULE!OFFSET -T INCLUDE_IMPORTS, --include-imports INCLUDE_IMPORTS include program's imports -t MODULE, --include-module-imports MODULE include MODULE imports -m OBJC_METHOD, --include-objc-method OBJC_METHOD include OBJC_METHOD -M OBJC_METHOD, --exclude-objc-method OBJC_METHOD exclude OBJC_METHOD -j JAVA_METHOD, --include-java-method JAVA_METHOD include JAVA_METHOD -J JAVA_METHOD, --exclude-java-method JAVA_METHOD exclude JAVA_METHOD -s DEBUG_SYMBOL, --include-debug-symbol DEBUG_SYMBOL include DEBUG_SYMBOL -q, --quiet do not format output messages -d, --decorate add module name to generated onEnter log statement -S PATH, --init-session PATH path to JavaScript file used to initialize the session -P PARAMETERS_JSON, --parameters PARAMETERS_JSON parameters as JSON, exposed as a global named 'parameters' -o OUTPUT, --output OUTPUT dump messages to file crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-10-26 09:06:45 "},"use_frida/frida_tools/":{"url":"use_frida/frida_tools/","title":"frida-tools","keywords":"","body":"frida-tools frida-tool是Frida的一套工具的集合，包括： 相对常用的 frida-trace frida-ps frida-ls 不太常用的 frida-apk frida-compile frida-create frida-discover frida-join frida-ls-devices frida-kill frida-pull frida-push frida-rm 对应源码是：frida-tools 安装frida-tools Mac中用Python的pip3去安装： pip3 install frida-tools 其他工具 gum-graft crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-23 23:20:40 "},"use_frida/frida_tools/frida_ps.html":{"url":"use_frida/frida_tools/frida_ps.html","title":"frida-ps","keywords":"","body":"frida-ps frida-ps 是frida-tools中一个常用的工具 作用：显示系统进程列表 类似于ps 支持显示当前（Mac等）PC端的进程和（iPhone等）移动端中的进程 官网文档 frida-ps 用法 显示当前PC端进程：不加参数frida-ps 显示USB连接的（iPhone等）移动端的（默认显示）所有进程，进程：-Ufrida-ps -U 显示USB连接的（iPhone等）移动端的正在运行的应用程序的进程：-Ua = USB + only (running) applicationsfrida-ps -Ua 显示USB连接的（iPhone等）移动端的应用程序的已安装的全部（正在运行和没有运行）的应用程序的进程：-Uai = USB + only (running) applications + (not runnning but) installedfrida-ps -Uai 另外： 可以加grep去搜索特定app 举例➜ frida-ps -Ua | grep -i preferences 46847 设置 com.apple.Preferences 举例 frida-ps ➜ ~ frida-ps PID Name --- ------------------------------------------------------------ ... 1205 weatherd 639 wifianalyticsd 612 wifip2pd 913 wifivelocityd 11153 wine64-preloader ... 11120 wineserver 633 writeconfig 17438 xpcroleaccountd ... 94172 zsh frida-ps -U crifan@licrifandeMacBook-Pro  ~/dev/dev_tool/reverse_security/iOS/palera1n  frida-ps -U PID Name --- ------------------------------------------------------------ 262 App Store 328 Filza 260 GTA Car Tracker 261 Safari浏览器 291 Shadowrocket 350 Sileo 265 TrollStore 316 palera1n 234 微信 315 截屏 312 搜索 264 播客 263 设置 100 ACCHWComponentAuthService 339 ASPCarryLog 230 AppPredictionIntentsHelperService 252 AppSSODaemon 81 AppleCredentialManagerDaemon 140 BlueTool 219 CAReportingService 335 CMFSyncAgent 276 CacheDeleteAppContainerCaches 285 CacheDeleteExtension 307 CategoriesService 237 CategoriesService 214 CategoriesService 187 CategoriesService 119 CloudKeychainProxy 91 CommCenter 185 CommCenterMobileHelper 188 ContextService 322 EnforcementService ... frida-ps -Ua ➜ ~ frida-ps -Ua PID Name Identifier 5 --------- ----------------------- 27692 Sileo org.coolstar.SileoStore 23650 微信 com.tencent.xin 11941 日历 com.apple.mobilecal 19641 设置 com.apple.Preferences frida-ps -Uai ➜ ~ frida-ps -Uai PID Name Identifier 5 ------------------- ------------------------------------- 27692 Sileo org.coolstar.SileoStore 23650 微信 com.tencent.xin 11941 日历 com.apple.mobilecal 19641 设置 com.apple.Preferences - App Store com.apple.AppStore - Apple Store com.apple.store.Jolly - CocoaTop ru.domo.cocoatop64 - FaceTime通话 com.apple.facetime - Filza com.tigisoftware.Filza - GTA Car Tracker com.icraze.gtatracker - Safari浏览器 com.apple.mobilesafari - Shadowrocket com.liguangming.Shadowrocket - ShowSystemInfo com.crifan.ShowSystemInfo - Substitute com.ex.substitute.settings - TrollStore com.opa334.TrollStore - Watch com.apple.Bridge - iTunes Store com.apple.MobileStore - palera1n com.llsc12.palera1nLoader - 信息 com.apple.MobileSMS - 健康 com.apple.Health - 反馈 com.apple.appleseed.FeedbackAssistant - 图书 com.apple.iBooks - 地图 com.apple.Maps - 备忘录 com.apple.mobilenotes - 天气 com.apple.weather - 家庭 com.apple.Home - 快捷指令 com.apple.shortcuts - 指南针 com.apple.compass - 提示 com.apple.tips - 提醒事项 com.apple.reminders - 播客 com.apple.podcasts - 放大器 com.apple.Magnifier - 文件 com.apple.DocumentsApp - 时钟 com.apple.mobiletimer - 查找 com.apple.findmy - 测距仪 com.apple.measure - 照片 com.apple.mobileslideshow - 爱思全能版 com.ownbook.notes - 电话 com.apple.mobilephone - 相机 com.apple.camera - 翻译 com.apple.Translate - 股市 com.apple.stocks - 视频 com.apple.tv - 计算器 com.apple.calculator - 语音备忘录 com.apple.VoiceMemos - 通讯录 com.apple.MobileAddressBook - 邮件 com.apple.mobilemail - 钱包 com.apple.Passbook - 音乐 com.apple.Music 语法help ➜ ~ frida-ps --help usage: frida-ps [options] options: -h, --help show this help message and exit -D ID, --device ID connect to device with the given ID -U, --usb connect to USB device -R, --remote connect to remote frida-server -H HOST, --host HOST connect to remote frida-server on HOST --certificate CERTIFICATE speak TLS with HOST, expecting CERTIFICATE --origin ORIGIN connect to remote server with “Origin” header set to ORIGIN --token TOKEN authenticate with HOST using TOKEN --keepalive-interval INTERVAL set keepalive interval in seconds, or 0 to disable (defaults to -1 to auto- select based on transport) --p2p establish a peer-to-peer connection with target --stun-server ADDRESS set STUN server ADDRESS to use with --p2p --relay address,username,password,turn-{udp,tcp,tls} add relay to use with --p2p -O FILE, --options-file FILE text file containing additional command line options --version show program's version number and exit -a, --applications list only applications -i, --installed include all installed applications -j, --json output results as JSON crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-23 23:19:37 "},"use_frida/frida_tools/frida_ls.html":{"url":"use_frida/frida_tools/frida_ls.html","title":"frida-ls","keywords":"","body":"frida-ls frida-ls 是frida-tools中一个工具 作用：显示系统中的文件列表 类似于ls 支持：当前（Mac等）PC端的文件和（iPhone等）移动端中的文件 用法 显示当前PC端的文件：不加参数frida-ls 显示USB连接的（iPhone等）移动端中的所有文件：-U == USBfrida-ls -U 举例 frida-ls ➜ ~ frida-ls drwxr-xr-x 20 root wheel 640 Thu Feb 9 09:39:53 2023 . drwxr-xr-x 20 root wheel 640 Thu Feb 9 09:39:53 2023 .. lrwxr-xr-x 1 root admin 36 Thu Feb 9 09:39:53 2023 .VolumeIcon.icns -> System/Volumes/Data/.VolumeIcon.icns ---------- 1 root admin 0 Thu Feb 9 09:39:53 2023 .file drwxr-xr-x 2 root wheel 64 Thu Feb 9 09:39:53 2023 .vol drwxrwxr-x 45 root admin 1440 Wed Jun 14 14:45:54 2023 Applications drwxr-xr-x 66 root wheel 2112 Fri May 12 19:14:14 2023 Library drwxr-xr-x 10 root wheel 320 Thu Feb 9 09:39:53 2023 System drwxr-xr-x 5 root admin 160 Sat Mar 18 14:26:26 2023 Users drwxr-xr-x 3 root wheel 96 Mon Jun 5 02:34:08 2023 Volumes drwxr-xr-x 39 root wheel 1248 Thu Feb 9 09:39:53 2023 bin drwxrwxr-x 2 root admin 64 Mon Oct 24 06:20:41 2022 cores dr-xr-xr-x 4 root wheel 5127 Sat Mar 18 14:26:04 2023 dev lrwxr-xr-x 1 root wheel 11 Thu Feb 9 09:39:53 2023 etc -> private/etc lrwxr-xr-x 1 root wheel 25 Sat Mar 18 14:27:10 2023 home -> /System/Volumes/Data/home drwxr-xr-x 7 root wheel 224 Mon May 29 03:57:47 2023 opt drwxr-xr-x 6 root wheel 192 Sat Mar 18 14:27:03 2023 private drwxr-xr-x 64 root wheel 2048 Thu Feb 9 09:39:53 2023 sbin lrwxr-xr-x 1 root wheel 11 Thu Feb 9 09:39:53 2023 tmp -> private/tmp drwxr-xr-x 11 root wheel 352 Thu Feb 9 09:39:53 2023 usr lrwxr-xr-x 1 root wheel 11 Thu Feb 9 09:39:53 2023 var -> private/var frida-ls -U 注：Mac中用USB连接的是，iOS 15.0的iPhone8，已用palera1n实现rootful越狱 ➜ ~ frida-ls -U drwxr-xr-x 26 root wheel 832 Fri May 5 07:03:51 2023 . drwxr-xr-x 26 root wheel 832 Fri May 5 07:03:51 2023 .. -rw-r--r-- 1 mobile staff 6148 Mon Feb 6 03:41:36 2023 .DS_Store drwx------ 2 root wheel 64 Thu Sep 16 05:39:21 2021 .ba ---------- 1 root admin 0 Thu Sep 16 05:39:21 2021 .file drwx------ 2 root wheel 64 Fri May 5 06:58:46 2023 .fseventsd drwx------ 2 root wheel 64 Thu Sep 16 05:39:21 2021 .mb -rw-r--r-- 1 mobile staff 0 Sun Nov 20 01:58:22 2022 .palecursus_strapped -rw-r--r-- 1 root staff 0 Fri May 5 07:03:50 2023 .procursus_strapped drwxrwxr-x 121 root admin 3872 Wed Jun 14 13:34:36 2023 Applications drwxr-xr-x 7 root wheel 306 Thu Sep 16 05:39:46 2021 Developer drwxrwxr-x 26 root admin 832 Thu May 18 15:05:28 2023 Library drwxr-xr-x 5 root wheel 160 Thu Sep 16 05:39:21 2021 System lrwxr-xr-x 1 root wheel 12 Fri May 5 07:03:50 2023 User -> //var/mobile drwxr-xr-x 39 root wheel 1248 Fri May 5 07:40:50 2023 bin drwxr-xr-x 2 root wheel 64 Fri May 5 07:03:50 2023 boot drwxrwxr-x 4 root admin 440 Wed Jun 14 06:35:22 2023 cores dr-xr-xr-x 4 root wheel 1492 Wed Jun 14 06:35:21 2023 dev lrwxr-xr-x 1 root wheel 11 Thu Sep 16 05:39:21 2021 etc -> private/etc drwxr-xr-x 2 root wheel 64 Fri May 5 07:03:50 2023 lib drwxr-xr-x 2 root wheel 64 Fri May 5 07:03:50 2023 mnt drwxr-xr-x 7 root wheel 224 Thu Sep 16 05:39:21 2021 private drwxr-xr-x 24 root wheel 768 Fri May 5 07:39:45 2023 sbin lrwxr-xr-x 1 root wheel 15 Thu Sep 16 05:39:21 2021 tmp -> private/var/tmp drwxr-xr-x 10 root wheel 320 Fri May 5 07:03:49 2023 usr lrwxr-xr-x 1 root admin 11 Thu Sep 16 05:39:21 2021 var -> private/var 语法help ➜ ~ frida-ls --help usage: frida-ls [options] [FILE]... positional arguments: files files to list information about options: -h, --help show this help message and exit -D ID, --device ID connect to device with the given ID -U, --usb connect to USB device -R, --remote connect to remote frida-server -H HOST, --host HOST connect to remote frida-server on HOST --certificate CERTIFICATE speak TLS with HOST, expecting CERTIFICATE --origin ORIGIN connect to remote server with “Origin” header set to ORIGIN --token TOKEN authenticate with HOST using TOKEN --keepalive-interval INTERVAL set keepalive interval in seconds, or 0 to disable (defaults to -1 to auto- select based on transport) --p2p establish a peer-to-peer connection with target --stun-server ADDRESS set STUN server ADDRESS to use with --p2p --relay address,username,password,turn-{udp,tcp,tls} add relay to use with --p2p -O FILE, --options-file FILE text file containing additional command line options --version show program's version number and exit crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-22 22:01:30 "},"use_frida/frida_tools/frida_ls_devices.html":{"url":"use_frida/frida_tools/frida_ls_devices.html","title":"frida-ls-devices","keywords":"","body":"frida-ls-devices 官网文档：frida-ls-devices 举例 ➜ frida-ls-devices Id Type Name OS ---------------------------------------- ------ --------------------------- -------------- local local crifanlideMacBook-Pro.local macOS 13.2.1 abdc0dd961c3cb96f5c4afe109de4eb48b88433a usb iPhone8_150 iPhone OS 15.0 socket remote Local Socket 语法help ➜ frida-ls-devices --help usage: frida-ls-devices [options] options: -h, --help show this help message and exit -O FILE, --options-file FILE text file containing additional command line options --version show program's version number and exit crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-22 23:19:24 "},"use_frida/other_related/":{"url":"use_frida/other_related/","title":"其他相关","keywords":"","body":"其他相关 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-23 08:10:11 "},"use_frida/other_related/frida_server.html":{"url":"use_frida/other_related/frida_server.html","title":"frida-server","keywords":"","body":"frida-server 越狱手机iPhone安装Frida后，就可以通过Frida插件的已安装文件： 看到安装了2个核心文件： /usr/lib/frida/frida-agent.dylib /usr/sbin/frida-server 其中frida-server就是Frida的server端 frida-server语法help iPhone11-151:~ root# frida-server --help Usage: frida [OPTION?] Help Options: -h, --help Show help options Application Options: --version Output version information and exit -l, --listen=ADDRESS Listen on ADDRESS --certificate=CERTIFICATE Enable TLS using CERTIFICATE --origin=ORIGIN Only accept requests with ?Origin? header matching ORIGIN (by default any origin will be accepted) --token=TOKEN Require authentication using TOKEN --asset-root=ROOT Serve static files inside ROOT (by default no files are served) -d, --directory=DIRECTORY Store binaries in DIRECTORY -D, --daemonize Detach and become a daemon --policy-softener=system|internal Select policy softener -P, --disable-preload Disable preload optimization -C, --ignore-crashes Disable native crash reporter integration -v, --verbose Be verbose crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-22 22:08:31 "},"frida_example/":{"url":"frida_example/","title":"Frida用法举例","keywords":"","body":"Frida用法举例 Frida用法举例 官网 Frida CodeShare 其他 oleavr/frida-agent-example: Example Frida agent written in TypeScript frida-presentations Frida在iOS平台进行OC函数hook的常用方法 | 8Biiit's Blog personal_script/Frida_script at master · lich4/personal_script · GitHub frida-ios-hook/frida-scripts 0xdea/frida-scripts misc/frida-read-process-memory.py at master · poxyran/misc · GitHub frida-snippets/README.md at master · iddoeldor/frida-snippets · GitHub crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-05-22 22:11:25 "},"frida_base_tool/":{"url":"frida_base_tool/","title":"基于Frida的工具","keywords":"","body":"基于Frida的工具 基于Frida的工具 脱壳/砸壳工具 frida-ios-dump https://github.com/AloneMonkey/frida-ios-dump pull decrypted ipa from jailbreak device frida-unpack https://github.com/dstmath/frida-unpack 基于Frida的脱壳工具 调试工具 frick https://github.com/iGio90/frick frick - aka the first debugger built on top of frida frick：基于（Unicorn、capstone和）frida的调试工具 frida-ios-hook https://github.com/noobpk/frida-ios-hook A tool that helps you easy trace classes, functions, and modify the return values of methods on iOS platform Fridump https://github.com/Nightbringer21/fridump A universal memory dumper using Frida for Android frida_dump https://github.com/lasting-yang/frida_dump frida dump dex, frida dump so frida-cycript https://github.com/nowsecure/frida-cycript Cycript fork powered by Frida r2frida https://github.com/nowsecure/r2frida Radare2 and Frida better together frida-trace https://github.com/nowsecure/frida-trace Trace APIs declaratively through Frida crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-24 21:31:58 "},"frida_use_case/":{"url":"frida_use_case/","title":"Frida的用途","keywords":"","body":"Frida的用途 可以用Frida实现各种逆向的用途。 其中 Frida Codeshare 就有很多例子，感兴趣的自己去挖掘挖掘。 下面整理出部分相关内容。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-27 23:00:31 "},"frida_use_case/anti_debug.html":{"url":"frida_use_case/anti_debug.html","title":"反调试","keywords":"","body":"反调试 据说，可以用frida脚本（临时）去规避掉反调试的ptrace： 使用Frida绕过iOS反调试 | La0s 一例简单的frida反调试绕过 - 网安 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-27 22:28:26 "},"frida_use_case/anti_obfuscation.html":{"url":"frida_use_case/anti_obfuscation.html","title":"辅助反混淆","keywords":"","body":"辅助反混淆 据说可以借助于Frida的Stalker，追踪提示真正指令执行过程后，然后：用于辅助反混淆。 关于Stalker的使用案例，详见： Stalker · Frida逆向实例和工具函数 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-05-22 22:09:14 "},"frida_use_case/bypass_encrypted_para.html":{"url":"frida_use_case/bypass_encrypted_para.html","title":"绕过参数加密","keywords":"","body":"绕过参数加密 通过frida的hook去实现绕过参数加密 用frida绕过apk中加密参数？ 部分参考资料： 利用frida快速解决APP中某tong加密 | 大熊の笔记 frida跑加密算法和绕过抓包验证_不想写程序(╥╯^╰╥)的博客-CSDN博客 【保姆级教学】某金融app FRIDA hook加解密算法+jsrpc=乱杀 - T00ls.Com 某金融app的加解密hook+rpc+绕过SSLPinning抓包 - T00ls.Com crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-27 22:29:51 "},"frida_use_case/reverse_app/":{"url":"frida_use_case/reverse_app/","title":"逆向app","keywords":"","body":"逆向app 抖音 从app启动最开始就开始hook调试 交互式调试frida -U -f com.ss.iphone.ugc.Aweme 用js脚本 调试dyldfrida -U -f com.ss.iphone.ugc.Aweme -l frida/dyldImage.js 其他 【未解决】Mac中Frida启动抖音app进程并调试和hook函数 【未解决】用Frida的frida-trace去hook函数iOS版抖音 【未解决】frida调试抖音app去hook函数：_dyld_get_image_name 【未解决】frida去hook函数_dyld_get_image_name时打印参数为字符串 【未解决】用Frida动态调试iOS版抖音app 【未解决】Mac中用Frida调试iOS版抖音 【已解决】用frida启动hook调试iOS抖音app 【未解决】尝试Frida的stalker能否修复抖音AwemeCore中函数名常量字符串 Apple账号 ~= AppleStore Apple账号 ~= AppleStore = Preferences + （AuthKit的daemon）akd + AppleAccount + AppleAccountUI + AppleMediaServices + libMobileGestalt + 其他 【记录】iOS逆向Apple账号：用frida和frida-trace去hook打印更多账号相关函数调用 【无法解决】iOS逆向Apple账号：用frida的ssl bypyass脚本尝试解决Charles抓包代理报错 【未解决】iOS逆向Apple账号：用Frida去监控NSURL去调试Apple账号登录过程 【未解决】iOS逆向Apple账号：用Frida去调试NSURL核心网络请求函数调用 【未解决】iOS逆向Apple账号：分析研究frida抓包到的Apple账号登录过程和网络相关的内容 迅雷 迅雷 【记录】用frida动态调试重新打包后的安卓迅雷apk 【未解决】Mac中搭建Frida的动态调试安卓apk的开发环境 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-27 22:38:29 "},"sub_books/":{"url":"sub_books/","title":"子教程","keywords":"","body":"子教程 逆向调试利器：Frida Frida逆向实例和工具函数 Frida调试经验总结 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-05-22 22:11:04 "},"appendix/":{"url":"appendix/","title":"附录","keywords":"","body":"附录 下面列出相关参考资料。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-22 22:04:13 "},"appendix/reference.html":{"url":"appendix/reference.html","title":"参考资料","keywords":"","body":"参考资料 【整理】Frida相关资料 【已解决】frida-core代码对应着frida中是哪个文件 【未解决】Mac中安装frida 【记录】iOS的iPhone中安装Frida 【记录】Sileo中安装tweak插件：Frida 【已解决】Mac M2 Max中安装Frida环境 【已解决】Mac中升级Frida到最新版本16.0.11 【未解决】Mac中安装frida 【已解决】Mac中升级Frida到新版本16.0.10 【记录】palera1n普通越狱后安装插件：Frida 【规避解决】palera1n的rootless越狱iPhone中初始化frida开发环境 【记录】下载Frida的动态库：FridaGadget.dylib 【记录】iPhone8中的升级frida到最新版16.0.11 【记录】iOS的iPhone中安装Frida 【已解决】确认palera1n的rootful普通越狱中Frida是否可用 【已解决】frida启动时到底有哪几种attach和spwan启动方式 【整理】再次研究确认Frida调试目标的几种方式 【已解决】iOS逆向：Frida调试设置出现页面弹框：接入互联网以登录iPhone 【未解决】XinaA15越狱的rootless的iPhone11中frida出错：安装和卸载时的路径异常/var/jb/var/jb/ 【记录】iPhone11重新安装XinaA15后重新安装Frida 【已解决】XinaA15越狱的iPhone11中安装Frida 【记录】XinaA15恢复越狱环境后重新安装Frida 【记录】iPhone8中用Sileo安装Frida 【记录】iPhone11中Sileo中安装最新版16.0.11的Frida 【记录】Sileo中安装tweak插件：Frida 【记录】iPhone11中用Sileo重新安装最新版16.0.10的Frida 【已解决】iPhone中Cydia中安装升级最新版的16.0.2的Frida 【未解决】Frida从16.0.8到升级到新版本16.0.10 【已解决】越狱后的iPhone11中卸载和重新安装Frida 【已确认】iPhone11中重新确认新版XinaA和新版Frida是否可以正常使用 【基本解决】Frida的Stalker.follow中events的含义和用法 【已解决】优化Frida调用脚本时无需每次查看PID直接传入进程名 【已解决】iOS逆向：frida调试hook类NSXPCConnection的setExportedObject 【已解决】Frida中Stalker如何在Stalker.follow中写代码追踪指令代码运行 【已解决】用frida去hook打印一个类的所有的方法 【已解决】frida去hook函数时确保已执行函数但不触发不输出日志log 【已解决】iOS逆向Apple账号：用frida打印com.apple.ak.auth.xpc的NSXPCConnection的其他属性值 【记录】iOS逆向akd：frida-trace追踪出iPhone8中iOS15.0中账号验证的函数调用过程结果 【已解决】Mac中如何使用frida的Stalker的js脚本 【已解决】Frida调试时如何指定进程 【已解决】Frida中如何通过frida启动被测app程序iOS版抖音 【已解决】frida调试进程直接运行不要每次都输入%resume才运行 【未解决】iOS逆向Apple账号：用frida去hook打印所有iOS的ObjC函数调用 【已解决】Frida中js代码中两个地址指针数值相加 【已解决】frida中ptr的含义 【已解决】js中把ObjC函数调用写法转换成Frida中ObjC函数调用写法 【已解决】frida打印iOS的ObjC函数的参数的值 【已解决】frida动态判断iOS的ObjC函数的参数个数并打印参数值 【已解决】frida去hook单个类的单个函数 【已解决】用frida去hook打印一个类的所有的方法 【已解决】frida去hook监控ObjC函数时把类名和函数名整合成Objc的语法 【已解决】Frida中hook打印iOS中的类和函数 【已解决】iOS逆向：Frida的hook中onLeave中如何获取到self类本身的实例变量 【已解决】frida中ObjC.Object的语法和含义 【未解决】frida中打印ObjC参数类型NSPathStore2的值 【已解决】frida的hook中如何把NSString转换为C的string并打印 【未解决】frida去hook时判断函数参数的类型是否是NSString 【已解决】frida中打印操作Objc的参数SEL导致程序崩溃 【已解决】Mac中Frida去hook函数：用frida还是frida-trace 【已解决】iOS逆向akd：用frida-trace追踪账号验证的过程 【已解决】frida-trace中把更多参数放到参数文件中 【已解决】frida-trace输出log日志到文件中 【记录】iOS逆向Apple账号：分析frida-trace去hook到的下一步按钮内部的函数调用逻辑 【记录】iOS逆向akd：frida-trace追踪出iPhone8中iOS15.0中账号验证的函数调用过程结果 【记录】iOS逆向Apple账号：frida-trace去hook逻辑加上NSString和NSError等通用的类 【已解决】iOS逆向调试：用Frida-trace实时追踪相关ObjC函数调用 【未解决】iOS逆向Apple账号：用frida-trace去hook监控NSURL网络请求 【未解决】iOS逆向Apple账号：用Frida去hook网络请求NSURL相关函数调用 【记录】iOS逆向Apple账号：frida-trace追踪多个ObjC函数的调用过程 【记录】iOS逆向Apple账号：优化frida-trace的函数hook范围以定位账号登录过程核心逻辑 【未解决】iOS逆向Apple账号：用frida-trace调试signin/v2/login的函数调用过程 【记录】frida-trace调试追踪到的输入密码下一步的账号登录过程中的ObjC函数调用过程 【记录】Mac中测试Frida各个命令的效果 【已解决】Mac中frida报错：ValueError file descriptor cannot be a negative integer -42 【记录】frida的frida-ps用法 【整理】frida心得：frida-ps用法详解 【未解决】iPhone11中如何停止frida-server 【未解决】iPhone中用launchctl去启动和停止frida-server服务进程 【未解决】frida导致iPhone重启：分析panic-full的ips是否和frida-server崩溃有关系 【基本解决】iOS 15.1的iPhone11中frida-server所用架构是arm64e还是arm64 【未解决】Frida的stalker trace 【基本解决】Frida的Stalker.follow中events的含义和用法 【已解决】Frida去hook函数报错：Error unable to intercept function at please file a bug 【无法解决】Frida的Stalker中transform中的instruction是否可以获取到bytes即opcode 【已解决】优化Frida的Stalker的代码追踪逻辑 【已解决】Frida的Stalker中函数地址和指令地址匹配不上 【已解决】搞懂Frida的Stalker.follow的transform的调试指令运行的逻辑 【已解决】Frida的Stalker.follow中transform中的指令instruction 【记录】分析Frida的Stalker对于___lldb_unnamed_symbol2575代码追踪的输出结果 【记录】学习Frida官网文档Stalker搞懂基本用法和逻辑 【已解决】Frida的Stalker中去判断是否是函数的代码指令的逻辑 【整理】Frida中对于js代码的支持不够完美 【无法解决】iOS逆向Apple账号：用frida的ssl bypyass脚本尝试解决Charles抓包代理报错 【未解决】iOS逆向Apple账号：用Frida去监控NSURL去调试Apple账号登录过程 【未解决】iOS逆向Apple账号：用Frida去调试NSURL核心网络请求函数调用 【未解决】iOS逆向Apple账号：分析研究frida抓包到的Apple账号登录过程和网络相关的内容 【记录】用frida动态调试重新打包后的安卓迅雷apk 【未解决】Mac中搭建Frida的动态调试安卓apk的开发环境 【已解决】iPhone和Mac中升级Frida到最新版16.1.1 【已解决】iOS逆向WhatsApp：Frida的js的函数堆栈打印优化：给个别特定函数加到排除列表 【已解决】iOS逆向WhatsApp：用Frida的带函数堆栈调用的js去hook注册过程 【已解决】js中判断字符串是否在列表中 【已解决】Frida中js打印日志log优化：自动生成中间字符串加上左右对称的单行log日志 【已解决】Frida打印iOS函数调用堆栈：优化同一函数只输出一次 【已解决】iOS逆向WhatsApp：加了代理后Frida去hook却始终崩溃 【已解决】Frida去hook抖音报错：Error java.lang.ClassNotFoundException Didn't find class on path DexPathList zip file 【已解决】Frida去hook安卓类找不到：Error java.lang.ClassNotFoundException Didn't find class com.android.server.pm.Settings 初始化Frida开发环境 · Android逆向：动态调试 (crifan.org) frida-ios-dump · iOS逆向开发：砸壳ipa (crifan.org) 某金融app的加解密hook+rpc+绕过SSLPinning抓包 - T00ls.Com 【保姆级教学】某金融app FRIDA hook加解密算法+jsrpc=乱杀 - T00ls.Com 利用frida快速解决APP中某tong加密 | 大熊の笔记 frida跑加密算法和绕过抓包验证_不想写程序(╥╯^╰╥)的博客-CSDN博客 使用Frida绕过iOS反调试 | La0s 一例简单的frida反调试绕过 - 网安 【iOS逆向】某营业厅算法分析_小陈_InfoQ写作社区 [原创] sktrace：基于 Frida Stalker 的 trace 工具-Android安全-看雪-安全社区|安全招聘|kanxue.com oleavr (Ole André Vadla Ravnås) Frida 12.3 Debuts New Crash Reporting Feature - NowSecure 【iOS逆向与安全】frida-trace入门 - 移动端小陈 - 博客园 Frida HandBook regex - How do you access the matched groups in a JavaScript regular expression? - Stack Overflow NativePointer - JavaScript API frida-ios-hook/hook-all-methods-of-specific-class.js at master · noobpk/frida-ios-hook · GitHub mikeash.com: objc_msgSend's New Prototype Frida basics - Frida HandBook iOS security overview & reverse engineering tools / Habr objc_msgSend | Apple Developer Documentation Frida CodeShare Project: iOS Utils Frida CodeShare BROWSE CODE Project: iOS SSL Bypass personal_script/Frida_script at master · lich4/personal_script · GitHub Frida在iOS平台进行OC函数hook的常用方法 | 8Biiit's Blog frida-ios-hook/frida-scripts 0xdea/frida-scripts Beginning Frida: by example. Frida, https://frida.re/, is one of… | by Román Ramírez | Medium Hacking | Frida • A world-class dynamic instrumentation toolkit Frida 1.6.3 Released | Frida • A world-class dynamic instrumentation toolkit Frida 1.6.2 Released | Frida • A world-class dynamic instrumentation toolkit frida/frida: Clone this repo to build Frida frida-core frida-gum frida-tools frida-python frida-node frida-swift frida-clr frida-go frida-rust frida-qml frida-objc-bridge frida-java-bridge Capstone Frida Docs Quick-start guide Installation Modes of Operation Gadget Hacking Stalker Presentations Functions Messages iOS Android Windows macOS Linux iOS Android JavaScript Frida CLI frida-ps frida-trace frida-discover frida-ls-devices frida-kill gum-graft JavaScript API C API Swift API Go API Best Practices Troubleshooting Building Footprint GSoC Ideas 2015 GSoD Ideas 2023 History frida-presentations 【Frida 实战】API查找器和拦截器的组合使用 – exchen's blog Stalker的API DefinitelyTyped/index.d.ts Tampering and Reverse Engineering on iOS - OWASP MASTG (gitbook.io) Cesar Rodriguez | Personal blog (cmrodriguez.me) Dalvik 可执行文件格式 | Android Open Source Project runtime/native/dalvik_system_DexFile.cc - platform/art - Git at Google (googlesource.com) crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-05-22 22:37:49 "}}