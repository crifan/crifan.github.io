{"./":{"url":"./","title":"前言","keywords":"","body":"Frida调试经验总结 最新版本：0.8.4 更新时间：20251213 简介 总结Frida调试期间遇到的各种问题和解决方案，以及各种经验和心得，帮助读者更好地理解和使用Frida进行调试。 源码+浏览+下载 本书的各种源码、在线浏览地址、多种格式文件下载如下： HonKit源码 crifan/frida_debug_summary: Frida调试经验总结 如何使用此HonKit源码去生成发布为电子书 详见：crifan/honkit_template: demo how to use crifan honkit template and demo 在线浏览 Frida调试经验总结 book.crifan.org Frida调试经验总结 crifan.github.io 离线下载阅读 Frida调试经验总结 PDF Frida调试经验总结 ePub Frida调试经验总结 Mobi 版权和用途说明 此电子书教程的全部内容，如无特别说明，均为本人原创。其中部分内容参考自网络，均已备注了出处。如发现有侵权，请通过邮箱联系我 admin 艾特 crifan.com，我会尽快删除。谢谢合作。 各种技术类教程，仅作为学习和研究使用。请勿用于任何非法用途。如有非法用途，均与本人无关。 鸣谢 感谢我的老婆陈雪的包容理解和悉心照料，才使得我crifan有更多精力去专注技术专研和整理归纳出这些电子书和技术教程，特此鸣谢。 其他 作者的其他电子书 本人crifan还写了其他150+本电子书教程，感兴趣可移步至： crifan/crifan_ebook_readme: Crifan的电子书的使用说明 关于作者 关于作者更多介绍，详见： 关于CrifanLi李茂 – 在路上 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-12-13 23:12:24 "},"frida_debug_overview/":{"url":"frida_debug_overview/","title":"Frida调试概述","keywords":"","body":"Frida调试概述 之前已整理出： Frida教程：逆向调试利器：Frida 相关工具类：Frida逆向实例和工具函数 现在对于，Frida调试（iOS和Android）期间，遇到的各种经验心得和常见问题等内容，单独整理成册，供参考。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-05-22 22:01:42 "},"summary_note/":{"url":"summary_note/","title":"经验心得","keywords":"","body":"经验心得 此处整理frida中的一些经验和心得。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-23 22:04:58 "},"summary_note/frida/":{"url":"summary_note/frida/","title":"frida","keywords":"","body":"frida crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2023-06-24 21:57:15 "},"summary_note/frida/hook_via_addr.html":{"url":"summary_note/frida/hook_via_addr.html","title":"通过函数地址去hook","keywords":"","body":"通过函数地址去hook函数 已知：函数的（二进制内偏移量）地址 想要：去hook拦截函数 举例说明 akd中函数___lldb_unnamed_symbol2575$$akd的二进制内偏移量是：0xa0460 思路：动态计算加上模块后的真实函数地址，再去hook 核心代码：console.log(\"dynamicDebug/frida/scripts/fridaStalker_akdSymbol2575.js\"); // var akdSymbol2575_functionAddress = 0x1000a0460; var akdSymbol2575_functionAddress = 0xa0460; // arm64 akd: ___lldb_unnamed_symbol2575$$akd const moduleName = \"akd\"; const moduleBaseAddress = Module.findBaseAddress(moduleName); console.log(\"moduleName=\", moduleName, \"moduleBaseAddress=\", moduleBaseAddress); const functionRealAddress = moduleBaseAddress.add(akdSymbol2575_functionAddress); console.log(\"functionRealAddress=\", functionRealAddress); Interceptor.attach(functionRealAddress, { onEnter: function(args) { var arg0 = args[0] var arg1 = args[1] var arg2 = args[2] console.log(\"arg0=\" + arg0 + \", arg1=\" + arg1 + \", arg2=\" + arg2); var curTid = Process.getCurrentThreadId(); console.log(\"curTid=\", curTid); ... 输出dynamicDebug/frida/scripts/fridaStalker_akdSymbol2575.js moduleName= akd moduleBaseAddress= 0x102b40000 functionRealAddress= 0x102be0460 arg0=0xfffffffffffffffe, arg1=0x16d346838, arg2=0x16d346838 curTid= 35847 ... 完整代码和输出，详见 ___lldb_unnamed_symbol2575$$akd · Frida高级调试：Stalker crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-08-22 21:33:08 "},"summary_note/frida_trace/":{"url":"summary_note/frida_trace/","title":"frida-trace","keywords":"","body":"frida-trace crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-05-25 10:50:40 "},"summary_note/frida_trace/hook_multi_lib.html":{"url":"summary_note/frida_trace/hook_multi_lib.html","title":"hook多个库文件","keywords":"","body":"hook指定的多个二进制库文件 想要去用frida-trace追踪的iOS的ObjC的库=Framework=二进制： AppleAccount AppleAccountUI Accounts AccountsDaemon AuthKitUI AuthKit UserManagement 最后是用： 去include 多个 module frida-trace -U -F com.apple.Preferences -I \"AppleAccount*\" -I \"UserManagement\" -I \"Accounts*\" -I \"AuthKit*\" 可以运行，但是结果： 只找到少数几个函数，不是我们要的 -》这么多库，一共才有107个函数 -》其中AppleAccount只有7个函数，其中就有上面的_AALogSystem仅仅是日志的函数，而不是我们要的：很多其他账号登录相关的函数 -》正常情况下，应该会有非常多的函数才对 注： 也可以换另外写法： frida-trace -U -F com.apple.Preferences -i \"AppleAccount\\!\" -i \"AppleAccountUI\\!\" -i \"Accounts\\!\" -i \"AccountsDaemon\\!\" -i \"AuthKit\\!\" -i \"AuthKitUI\\!\" -i \"UserManagement\\!\" 不过结果都一样：hook的函数都很少，不是我们想要的。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-05-25 10:49:03 "},"summary_note/frida_trace/log_to_file.html":{"url":"summary_note/frida_trace/log_to_file.html","title":"输出日志到文件中","keywords":"","body":"输出日志到文件中 解决办法：加上-o参数，去指定输出log到文件 命令frida-trace -U -F com.apple.Preferences -o traceAccount.log -m \"*[AA* *]\" -m \"*[AK* *]\" -m \"*[AS* *]\" -m \"*[NSXPC* *]\" -M \"-[ASDBundle copyWithZone:]\" -M \"-[ASDInstallationEvent copyWithZone:]\" -M \"-[NSXPCEncoder _encodeArrayOfObjects:forKey:]\" -M \"-[NSXPCEncoder _encodeUnkeyedObject:]\" -M \"-[NSXPCEncoder _replaceObject:]\" -M \"-[NSXPCEncoder _checkObject:]\" -M \"-[NSXPCEncoder _encodeObject:]\" -M \"-[NSXPCConnection replacementObjectForEncoder:object:]\" 缺点 之前=输出日志到终端：带颜色和缩进 -> 利于查看函数调用关系 现在=输出日志到文件：丢失了颜色，更主要是缩进也丢失了 -> 非常不利于查看函数调用关系 Mac中想要保留所有的frida-trace的带缩进的日志 如上所述，想要：保留所有的frida-trace的日志，但如果用输出到日志文件，却又丢失缩进（和颜色） 另外有个规避办法： 修改当前终端的最大显示行数 -> 就可以避免输出日志行数太多，之前内容被冲掉，看不到的问题了 比如： Mac中iTerm2中，右键当前tab页顶部-》右键-》Edit Session->Terminal->Scrollback Buffer->Scrollback line：改为足够大的数值，比如5000 甚至如果log日志特别长，那么可以考虑：设置为无限行数都保留 == Unlimited scrollback 这样就完全不用担心日志行数太多，前面的日志被冲掉，看不到的问题了。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-05-25 11:00:54 "},"summary_note/frida_trace/edit_js_print_para.html":{"url":"summary_note/frida_trace/edit_js_print_para.html","title":"修改函数hook的js去打印参数值","keywords":"","body":"修改函数hook的js去打印参数值 对于之前的需求：frida-trace时，打印其中特定的某个ObjC函数的参数 之前不知道如何解决，后来参考这里，突然想到： 倒是可以借助其所说的，对于frida-trace自动为每个类的函数，所生成的js文件： 位置：__handlers__/{ClassName}/{FunctionName}.js 去修改js代码，加上打印对应的args的代码，即可打印对应参数值了。 举例 -[AAAccountManager addAccount:] frida-trace为函数-[AAAccountManager addAccount:]自动生成的： js文件 /Users/crifan/dev/dev_root/iosReverse/AppleStore/AuthKit_akd/dynamicDebug/frida/scripts/__handlers__/AAAccountManager/addAccount_.js 完整js代码 /* * Auto-generated by Frida. Please modify to match the signature of -[AAAccountManager addAccount:]. * This stub is currently auto-generated from manpages when available. * * For full API reference, see: https://frida.re/docs/javascript-api/ */ { /** * Called synchronously when about to call -[AAAccountManager addAccount:]. * * @this {object} - Object allowing you to store state for use in onLeave. * @param {function} log - Call this function with a string to be presented to the user. * @param {array} args - Function arguments represented as an array of NativePointer objects. * For example use args[0].readUtf8String() if the first argument is a pointer to a C string encoded as UTF-8. * It is also possible to modify arguments by assigning a NativePointer object to an element of this array. * @param {object} state - Object allowing you to keep state across function calls. * Only one JavaScript function will execute at a time, so do not worry about race-conditions. * However, do not use this to store function arguments across onEnter/onLeave, but instead * use \"this\" which is an object for keeping state local to an invocation. */ onEnter(log, args, state) { log(`-[AAAccountManager addAccount:${args[2]}]`); }, /** * Called synchronously when about to return from -[AAAccountManager addAccount:]. * * See onEnter for details. * * @this {object} - Object allowing you to access state stored in onEnter. * @param {function} log - Call this function with a string to be presented to the user. * @param {NativePointer} retval - Return value represented as a NativePointer object. * @param {object} state - Object allowing you to keep state across function calls. */ onLeave(log, retval, state) { } } 可以拷贝把其中的： log(`-[AAAccountManager addAccount:${args[2]}]`); 改为： log(`-[AAAccountManager addAccount:${new ObjC.Object(args[2])}]`); 就可以：打印出ObjC对象的信息了，而不仅仅是：ptr=NativePointer的指针的字符串 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-05-25 11:14:58 "},"summary_note/js/":{"url":"summary_note/js/","title":"js","keywords":"","body":"js 总体感觉，Frida对于js支持的不够完美： js报错时，代码错误行数指示有误 console.log的参数格式化不支持 putCallout中传递有名的独立函数会导致崩溃，改为匿名函数即可 等等 下面总结遇到的各种问题和解决办法、以及相关的Frida中js方面的心得。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-08-20 22:30:02 "},"summary_note/js/misc/":{"url":"summary_note/js/misc/","title":"其他细节","keywords":"","body":"其他细节 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-08-20 22:19:36 "},"summary_note/js/misc/addr_ptr_add.html":{"url":"summary_note/js/misc/addr_ptr_add.html","title":"地址指针相加","keywords":"","body":"地址指针相加 js中，普通2个，原以为都是普通的数值的值，用加号相加： var functionSize = 0x24C8; // 9416 == 0x24C8 ... const moduleBaseAddress = Module.findBaseAddress(moduleName); const funcRealStartAddr = moduleBaseAddress.add(funcRelativeStartAddr); // 0x1001fc460 ... var funcRealEndAddr = funcRealStartAddr + functionSize; 结果却是： funcRealEndAddr=0x10015c0006564809416 而不是以为的： funcRealEndAddr=0x1001fe928 其中：0x1001fe928 - 0x1001fc460 = 0x24C8 原因： 此处的值funcRealStartAddr，其实是Frida中的特殊定义的类型，叫做：NativePointer 所以，两个NativePointer类型的地址相加，要用特殊写法，否则就变成了：字符串级别的拼接相加了。 解决办法： 搞懂定义和方法： NativePointer 文档： NativePointer - JavaScript API | Frida 属性、函数： add() sub() ... equals() compare() toInt32() 后，改为： 用NativePointer的add（和前面写法一样） var funcRealEndAddr = funcRealStartAddr.add(functionSize); 即可 -> 输出正常的值： funcRelativeStartAddr=656480, functionSize=9416, funcRelativeEndAddr=665896 moduleName=akd, moduleBaseAddress=0x10015c000 funcRealStartAddr=0x1001fc460, funcRealEndAddr=0x1001fe928 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-08-20 22:23:58 "},"summary_note/js/support_js_not_good/":{"url":"summary_note/js/support_js_not_good/","title":"Frida对于js支持的不够好","keywords":"","body":"Frida对于js支持的不够好 Frida对于js支持的不够好，不够完美： console.log不支持参数格式化 js报错时代码错误行数指示有误 putCallout中传递有名的独立函数会导致崩溃 -> 改为匿名函数才可以 下面详细解释： crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-05-25 11:08:34 "},"summary_note/js/support_js_not_good/console_log_no_para_formating.html":{"url":"summary_note/js/support_js_not_good/console_log_no_para_formating.html","title":"console.log不支持参数的格式化","keywords":"","body":"console.log不支持参数的格式化 问题 Frida中console.log打印参数，去格式化参数：console.log(\"moduleName=%s, moduleBaseAddress=%p\", moduleName, moduleBaseAddress) 输出：moduleName=%s, moduleBaseAddress=%p akd 0x10015c000 结论：Frida中js的console.log，不支持参数格式化 == %s、%d、%o、%p等格式化参数无效 规避办法 用逗号=, 或 加号=+ 去打印参数 console.log(\"moduleName=\", moduleName, \", moduleBaseAddress=\", moduleBaseAddress) console.log(\"moduleName=\" + moduleName + \", moduleBaseAddress=\" + moduleBaseAddress) crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-05-25 11:08:11 "},"summary_note/js/support_js_not_good/err_line_indicate_wrong.html":{"url":"summary_note/js/support_js_not_good/err_line_indicate_wrong.html","title":"js报错时代码错误行数指示有误","keywords":"","body":"js报错时代码错误行数指示有误 问题： Frida的js代码文件中，参考别人的ts的代码，写了： transform: (iterator: StalkerArm64Iterator) => { ... var arm64Context = ctx as Arm64CpuContext; 结果语法报错 Error: could not parse ‘xxxf/ridaStalker_akdSymbol2575.js' line 1: expecting ',' at (/frida/repl-2.js:1) 解决过程 Frida中对js代码报错，始终是第一行代码有问题 后来是，花了很长时间和精力，才定位到真正问题： 原因：js代码中，后面的某2行中，先后出现的2个变量，没有定义 2个变量是：StalkerArm64Iterator和Arm64CpuContext 导致的整体js代码无法运行而报错 解决办法：注释掉2个未定义的变量（StalkerArm64Iterator和Arm64CpuContext） 心得： 总之说明，js代码的解析，是Frida整个框架去基于js引擎（v8或其他？）去解析的 所以最终输出的报错信息，不够友好，导致容易让人误判错误原因，从而增加解决问题的难度 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-05-25 11:06:41 "},"summary_note/js/console_log/":{"url":"summary_note/js/console_log/","title":"console.log日志","keywords":"","body":"console.log日志 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-05-25 11:13:11 "},"summary_note/js/console_log/json_stringify_print_obj.html":{"url":"summary_note/js/console_log/json_stringify_print_obj.html","title":"用JSON.stringify打印对象","keywords":"","body":"用JSON.stringify打印对象 问题 console.log(… \",operands=\" + instruction.operands) 输出的是： operands=[object Object],[object Object] 或者是，改为：%o去格式化打印对象，但是问题依旧 解决办法 用JSON.stringify去转化为JSON再去用console.log打印： 举例： console.log(\"instruction: address=\" + instruction.address + \",next=\" + instruction.next + \",size=\" + instruction.size + \",mnemonic=\" + instruction.mnemonic + \",opStr=\" + instruction.opStr + \",operands=\" + JSON.stringify(instruction.operands) + \",regsRead=\" + JSON.stringify(instruction.regsRead) + \",regsWritten=\" + JSON.stringify(instruction.regsWritten) + \",groups=\" + JSON.stringify(instruction.groups) + \",toString()=\" + instruction.toString() ); 输出效果： instruction: address=0x1091dbcd8,next=0x4,size=4,mnemonic=b,opStr=#0x1091dbce8,operands=[{\"type\":\"imm\",\"value\":\"4447911144\",\"access\":\"r\"}],regsRead=[],regsWritten=[],groups=[\"jump\",\"branch_relative\"],toString()=b #0x1091dbce8 [0x1091dbcd8] b #0x1091dbce8 +++ into iterator= instruction: address=0x1091dbce8,next=0x4,size=4,mnemonic=str,opStr=wzr, [x19, #0x90],operands=[{\"type\":\"reg\",\"value\":\"wzr\",\"access\":\"r\"},{\"type\":\"mem\",\"value\":{\"base\":\"x19\",\"disp\":144},\"access\":\"rw\"}],regsRead=[],regsWritten=[],groups=[],toString()=str wzr, [x19, #0x90] [0x1091dbce8] str wzr, [x19, #0x90] crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-08-20 22:27:07 "},"summary_note/js/console_log/output_log_to_file.html":{"url":"summary_note/js/console_log/output_log_to_file.html","title":"console.log输出日志到文件","keywords":"","body":"console.log输出日志到文件 需求：希望Frida中console.log打印的日志，不是输出到当前终端，而是输出到文件中 目的：方便后续随时查看，方便调试 解决办法： 在运行Frida带js的命令行最后加上： > xxx.log 2>&1 参数说明 > xxx.log：把普通的=stdout日志信息，都输出到log文件 2>&1：把特殊的stderr=错误日志信息，输出到终端 举例frida -U -p 13098 -l ./fridaStalker_akdSymbol2575.js > stalker_akd1575.log 2>&1 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-05-25 11:11:50 "},"summary_note/frida_server/":{"url":"summary_note/frida_server/","title":"frida-server","keywords":"","body":"frida-server crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-05-25 10:54:13 "},"summary_note/frida_server/build_frida_server.html":{"url":"summary_note/frida_server/build_frida_server.html","title":"自己编译frida-server","keywords":"","body":"自己编译frida-server iPhone11中，已用XinaA15进行了rootless越狱，然后去用frida： crifan@licrifandeMacBook-Pro  ~  frida -U -f com.apple.store.Jolly -l /Users/crifan/dev/dev_root/iosReverse/AppleStore/dynamicDebug/frida/hookNSFileManager.js ____ / _ | Frida 16.0.8 - A world-class dynamic instrumentation toolkit | (_| | > _ | Commands: /_/ |_| help -> Displays the help system . . . . object? -> Display information about 'object' . . . . exit/quit -> Exit . . . . . . . . More info at https://frida.re/docs/home/ . . . . . . . . Connected to iPhone (id=00008030-00011C49366B802E) Failed to attach: missing gProcessInfo 结果报错：Failed to attach missing gProcessInfo 之后就是尝试解决此问题，最终涉及到：自己去编译frida-server的过程。 此处记录相关内容和心得，供参考。 研究gProcessInfo的来源 之前frida-ios-dump也遇到类似问题 而之前就见过此处的missing gProcessInfo，找到之前的： 原因是：属于偶尔的bug 解决办法：多试几次 -》此处：继续尝试多次，始终无法规避，始终报错。 研究frida中是否存在导入外部变量gProcessInfo 从报错信息Failed to attach: missing gProcessInfo中推测： gProcessInfo是（iOS的app启动阶段涉及到的）dyld中的变量 怀疑是类似于： frida import 变量：gProcessInfo dyld export 变量：gProcessInfo 这种机制 所以去研究看看： frida中，是否有import的变量，叫做gProcessInfo 后来确认，missing gProcessInfo来自iPhone端的frida-server 去导出frida-server scp root@192.168.2.12:/var/sbin/frida-server frida-server 然后继续静态分析： rabin2 -i frida-server > fridaServer_rabin2_i_imports.txt rabin2 -E frida-server > fridaServer_rabin2_E_exports.txt 没找到gProcessInfo 另外找到： dyld/dyldMain.cpp namespace dyld4 { ... #if TARGET_OS_OSX static void* getProcessInfo() { return gProcessInfo; } 而根据： 【记录】dyld相关资料：启动过程 知道了： dyld 之前是：dyld2 后来是：dyld3 此处是：dyld4 即：dyld有3个版本，dyld2、dyld3、dyld4 最后确认： 不是Frida（的frida-server）引用了外部的变量： dyld源码中的gProcessInfo 而是： frida源码中有gProcessInfo 即： frida-core/src/fruity/injector.vala中就有对应代码： ensure_libsystem_initialized_for_dyld_v4_and_above ... throw new Error.UNSUPPORTED (\"Missing gProcessInfo\"); Frida源码中找到了：gProcessInfo missing gProcessInfo相关完整的代码： frida-core/src/fruity/injector.valaprivate async void ensure_libsystem_initialized_for_dyld_v4_and_above (uint64 libdyld_initialize, Cancellable? cancellable) throws GLib.Error { uint64? process_info_ptr = dyld_symbols[\"_gProcessInfo\"]; if (process_info_ptr == null) throw new Error.UNSUPPORTED (\"Missing gProcessInfo\"); ... 其他地方也有： frida-core/src/fruity/helpers/symbol-fetcher.c size_t frida_fetch_dyld_symbols (char * output_buffer, const void * dyld_load_address) { ... for (i = dyld.dysymtab->ilocalsym; i != dyld.dysymtab->nlocalsym; i++) { const struct nlist_64 * sym = &symbols[i]; const char * name = strings + sym->n_un.n_strx; if (frida_str_contains (name, \"libdyld_initialize\") || frida_str_contains (name, \"restartWithDyldInCache\") || frida_str_equals (name, \"_gProcessInfo\") || frida_str_contains (name, \"launchWithClosure\") || frida_str_contains (name, \"initializeMainExecutable\") || frida_str_contains (name, \"registerThreadHelpers\") || frida_str_has_prefix (name, \"_dlopen\") || frida_str_has_prefix (name, \"_strcmp\") || frida_str_contains (name, \"doModInitFunctions\") || frida_str_contains (name, \"doGetDOFSections\")) { if (n != 0) frida_append_char (&cursor, '\\n'); frida_append_uint64 (&cursor, (uint64_t) (dyld.base + sym->n_value)); frida_append_char (&cursor, '\\t'); frida_append_string (&cursor, name); n++; } } frida-core/src/darwin/frida-helper-backend-glue.m modern_entry_address = gum_darwin_module_resolve_symbol_address (dyld, \"__ZN5dyld44APIs19_libdyld_initializeEPKNS_16LibSystemHelpersE\"); instance->dyld_flavor = (modern_entry_address != 0) ? FRIDA_DYLD_V4_PLUS : FRIDA_DYLD_V3_MINUS; if (instance->dyld_flavor == FRIDA_DYLD_V4_PLUS) { instance->modern_entry_address = modern_entry_address; legacy_entry_address = 0; instance->info_ptr_address = gum_darwin_module_resolve_symbol_address (dyld, \"_gProcessInfo\"); if (instance->info_ptr_address == 0) goto dyld_probe_failed; } ... instance->dlopen_address = gum_darwin_module_resolve_symbol_address (dyld, \"_dlopen\"); if (instance->dlopen_address == 0) instance->dlopen_address = gum_darwin_module_resolve_symbol_address (dyld, \"_dlopen_internal\"); instance->register_helpers_address = gum_darwin_module_resolve_symbol_address (dyld, \"__ZL21registerThreadHelpersPKN4dyld16LibSystemHelpersE\"); instance->dlerror_clear_address = gum_darwin_module_resolve_symbol_address (dyld, \"__ZL12dlerrorClearv\"); instance->info_address = gum_darwin_module_resolve_symbol_address (dyld, \"__ZN4dyld12gProcessInfoE\"); instance->helpers_ptr_address = gum_darwin_module_resolve_symbol_address (dyld, \"__ZN4dyld17gLibSystemHelpersE\"); instance->do_modinit_strcmp_checks = frida_find_modinit_strcmp_checks (task, dyld); ... 心得： 其中有很多这种： 编译器编译后的固定的函数名： _dlopen _dlopen_internal __ZL21registerThreadHelpersPKN4dyld16LibSystemHelpersE __ZL12dlerrorClearv __ZN4dyld12gProcessInfoE 其中包含：gProcessInfo __ZN4dyld17gLibSystemHelpersE 研究Frida中Missing gProcessInfo出错的逻辑和原因 经过后续了解： 【记录】dyld源码中的gProcessInfo 应该把： 只判断是否存在：_gProcessInfo 改为： 同时判断多种情况（先后顺序是） _gProcessInfo 对应原始代码中：gProcessInfo __ZN5dyld412gProcessInfoE 对应原始代码中：dyld4::gProcessInfo __ZN4dyld12gProcessInfoE 对应原始代码中：dyld::gProcessInfo 应该就可以了。 研究二进制/usr/lib/dyld中是否包含或导出变量_gProcessInfo 对于iPhone中的dyld： iPhone11-151:~ root# ls -lh /usr/lib/dyld -rwxr-xr-x 1 root wheel 630K Oct 15 2021 /usr/lib/dyld* 用： scp root@192.168.2.12:/usr/lib/dyld dyld 导出后，再从dyld中导出符号： rabin2 -s dyld > dyld_rabin2_s_symbols.txt 发现是有的： dyld_rabin2_s_symbols.txt 2185 0x00064008 0x00064008 LOCAL FUNC 0 dyld4::gProcessInfo 另外，突然注意到： fromiPhone/dyld_rabin2_s_symbols.txt891 0x0002e500 0x0002e500 LOCAL FUNC 0 dyld4::APIs::_dyld_shared_cache_optimized() 892 0x0002e57c 0x0002e57c LOCAL FUNC 0 dyld4::APIs::_dyld_register_for_image_loads(void (*)(mach_header const*, char const*, bool)) 893 0x0002e680 0x0002e680 LOCAL FUNC 0 ____ZN5dyld44APIs30_dyld_register_for_image_loadsEPFvPK11mach_headerPKcbE_block_invoke 894 0x0002e76c 0x0002e76c LOCAL FUNC 0 ____ZN5dyld44APIs30_dyld_register_for_image_loadsEPFvPK11mach_headerPKcbE_block_invoke_2 895 0x0002e7b4 0x0002e7b4 LOCAL FUNC 0 ____ZN5dyld44APIs35_dyld_register_for_bulk_image_loadsEPFvjPPK11mach_headerPPKcE_block_invoke_2 896 0x0002e7c8 0x0002e7c8 LOCAL FUNC 0 dyld4::APIs::dyld_shared_cache_file_path() 897 0x0002e810 0x0002e810 LOCAL FUNC 0 dyld4::APIs::dyld_has_inserted_or_interposing_libraries() 898 0x0002e874 0x0002e874 LOCAL FUNC 0 dyld4::APIs::dyld_shared_cache_find_iterate_text(unsigned char const*, char const**, void ( block_pointer)(dyld_shared_cache_dylib_text_info const*)) 899 0x0002ea8c 0x0002ea8c LOCAL FUNC 0 dyld4::findCacheInDirAndMap(dyld4::RuntimeState&, unsigned char const*, char const*, unsigned long&) 900 0x0002eb5c 0x0002eb5c LOCAL FUNC 0 ____ZN5dyld44APIs35dyld_shared_cache_find_iterate_textEPKhPPKcU13block_pointerFvPK33dyld_shared_cache_dylib_text_infoE_block_invoke.173 901 0x0002ebe0 0x0002ebe0 LOCAL FUNC 0 dyld4::APIs::dyld_shared_cache_iterate_text(unsigned char const*, void ( block_pointer)(dyld_shared_cache_dylib_text_info const*)) 902 0x0002ec60 0x0002ec60 LOCAL FUNC 0 dyld4::APIs::_dyld_fork_child() 即： 此处symbol中，也是有一些： ____ZN5dyld44APIs30_dyld_register_for_image_loadsEPFvPK11mach_headerPKcbE_block_invoke 这种编译后的函数名的值的 同时，也有，编译前的，普通的函数名： dyld4::APIs::_dyld_register_for_image_loads(void ()(mach_header const, char const*, bool)) -》所以突然想到： 估计是，编译前的，普通函数名，是： 此处rabin2，自动帮忙翻译的（因为其懂得编译和反编译函数名 symbol的内在逻辑？） -》所以去找找： 是否有机会，让rabin2，只输出： 编译后的symbol名字？ 这样就能找到，确认： dyld4::gProcessInfo 是不是： __ZN5dyld44gProcessInfo 了 去找找看： rabin2的其他参数，能输出原始的symbol的？ 对了，或许也可以用另外的工具：jtool2 jtool2 -S dyld > dyld_jtool2_S_symbol.txt 果然是我们希望的，原始的，编译后的，没有被解析的：gProcessInfo dyld_jtool2_S_symbol.txt0000000000064008 d __ZN5dyld412gProcessInfoE 所以就是： dyld4::gProcessInfo 编译生成：__ZN5dyld412gProcessInfoE 不是我以为的：__ZN5dyld44gProcessInfo 再去dyld源码中，多搜搜： namespace dyld4 看看是否有其他新发现 namespace dyld4 /Users/crifan/dev/dev_src/ios_reverse/AppleOpenSource/dyld/dyld-dyld-1042.1/dyld/DebuggerSupport.h namespace dyld4 { using lsl::Allocator; void addImagesToAllImages(RuntimeState& state, uint32_t infoCount, const dyld_image_info info[], uint32_t initialImageCount); void removeImageFromAllImages(const mach_header* loadAddress); ... } extern \"C\" void lldb_image_notifier(enum dyld_image_mode mode, uint32_t infoCount, const dyld_image_info info[]); extern dyld_all_image_infos* gProcessInfo; ->也还是：gProcessInfo ->不是放在namespace dyld4中的 /Users/crifan/dev/dev_src/ios_reverse/AppleOpenSource/dyld/dyld-dyld-1042.1/dyld/DyldAPIs.cpp // internal libc.a variable that needs to be reset during fork() extern mach_port_t mach_task_self_; using dyld3::MachOFile; using dyld3::MachOLoaded; extern const dyld3::MachOLoaded __dso_handle; ... namespace dyld4 { ... } -》自己当前是dyld4的namespace，但是也会引用外部变量： 其中也有： 没有namespace的： extern mach_port_t mach_task_self_; 和另外的namespace的：dyld3 extern const dyld3::MachOLoaded __dso_handle; 然后去： 【未解决】rabin2输出C++的未解析的原始的编译后的函数名mangle name 所以去： 【未解决】C++代码中函数变量编译生成符号symbol的规则 期间去： 【已解决】从C++的编译后的符号symbol得到原始的变量函数名 另外，看看此处的dyld版本： iPhone11-151:~ root# /usr/lib/dyld --version -sh: /usr/lib/dyld: cannot execute binary file: Exec format error 无法查看。 【已解决】iOS 13.3的iPhone7中/usr/lib/dyld的版本和gProcessInfo相关信息 也去研究：dyld源码中的gProcessInfo 至此找到： gProcessInfo 变量来源： dyld/dyld-dyld-1042.1/dyld/DebuggerSupport.cppstruct dyld_all_image_infos* gProcessInfo = &dyld_all_image_infos; 以及： struct dyld_all_image_infos 定义 libdyld/dyld_process_info_internal.h struct dyld_all_image_infos_32 struct dyld_all_image_infos_64 include/mach-o/dyld_images.h struct __attribute__((aligned(16))) dyld_all_image_infos 具体定义详见： （1）include/mach-o/dyld_images.h // Must be aligned to support atomic updates // Note sim cannot assume alignment until all host dylds are new enough #if TARGET_OS_SIMULATOR struct dyld_all_image_infos #else struct __attribute__((aligned(16))) dyld_all_image_infos #endif { uint32_t version; /* 1 in Mac OS X 10.4 and 10.5 */ uint32_t infoArrayCount; #if defined(__cplusplus) && (BUILDING_LIBDYLD || BUILDING_DYLD) std::atomic infoArray; #else const struct dyld_image_info* infoArray; #endif dyld_image_notifier notification; bool processDetachedFromSharedRegion; /* the following fields are only in version 2 (Mac OS X 10.6, iPhoneOS 2.0) and later */ bool libSystemInitialized; const struct mach_header* dyldImageLoadAddress; /* the following field is only in version 3 (Mac OS X 10.6, iPhoneOS 3.0) and later */ void* jitInfo; /* the following fields are only in version 5 (Mac OS X 10.6, iPhoneOS 3.0) and later */ const char* dyldVersion; const char* errorMessage; uintptr_t terminationFlags; /* the following field is only in version 6 (Mac OS X 10.6, iPhoneOS 3.1) and later */ void* coreSymbolicationShmPage; /* the following field is only in version 7 (Mac OS X 10.6, iPhoneOS 3.1) and later */ uintptr_t systemOrderFlag; /* the following field is only in version 8 (Mac OS X 10.7, iPhoneOS 3.1) and later */ uintptr_t uuidArrayCount; const struct dyld_uuid_info* uuidArray; /* only images not in dyld shared cache */ /* the following field is only in version 9 (Mac OS X 10.7, iOS 4.0) and later */ struct dyld_all_image_infos* dyldAllImageInfosAddress; /* the following field is only in version 10 (Mac OS X 10.7, iOS 4.2) and later */ uintptr_t initialImageCount; /* the following field is only in version 11 (Mac OS X 10.7, iOS 4.2) and later */ uintptr_t errorKind; const char* errorClientOfDylibPath; const char* errorTargetDylibPath; const char* errorSymbol; /* the following field is only in version 12 (Mac OS X 10.7, iOS 4.3) and later */ uintptr_t sharedCacheSlide; /* the following field is only in version 13 (Mac OS X 10.9, iOS 7.0) and later */ uint8_t sharedCacheUUID[16]; /* the following field is only in version 15 (macOS 10.12, iOS 10.0) and later */ uintptr_t sharedCacheBaseAddress; #if defined(__cplusplus) && (BUILDING_LIBDYLD || BUILDING_DYLD) // We want this to be atomic in libdyld so that we can see updates when we map it shared std::atomic infoArrayChangeTimestamp; #else uint64_t infoArrayChangeTimestamp; #endif const char* dyldPath; mach_port_t notifyPorts[DYLD_MAX_PROCESS_INFO_NOTIFY_COUNT]; #if __LP64__ uintptr_t reserved[11-(DYLD_MAX_PROCESS_INFO_NOTIFY_COUNT/2)]; #else uintptr_t reserved[9-DYLD_MAX_PROCESS_INFO_NOTIFY_COUNT]; #endif // The following fields were added in version 18 (previously they were reserved padding fields) uint64_t sharedCacheFSID; uint64_t sharedCacheFSObjID; /* the following field is only in version 16 (macOS 10.13, iOS 11.0) and later */ uintptr_t compact_dyld_image_info_addr; size_t compact_dyld_image_info_size; uint32_t platform; // FIXME: really a dyld_platform_t, but those aren't exposed here. /* the following field is only in version 17 (macOS 10.16) and later */ uint32_t aotInfoCount; const struct dyld_aot_image_info* aotInfoArray; uint64_t aotInfoArrayChangeTimestamp; uintptr_t aotSharedCacheBaseAddress; uint8_t aotSharedCacheUUID[16]; }; （2）还有个分32和64的： struct dyld_all_image_infos_32 struct dyld_all_image_infos_64 -> libdyld/dyld_process_info_internal.h struct dyld_all_image_infos_32 { uint32_t version; uint32_t infoArrayCount; std::atomic infoArray; uint32_t notification; bool processDetachedFromSharedRegion; bool libSystemInitialized; uint32_t dyldImageLoadAddress; uint32_t jitInfo; uint32_t dyldVersion; uint32_t errorMessage; uint32_t terminationFlags; uint32_t coreSymbolicationShmPage; uint32_t systemOrderFlag; uint32_t uuidArrayCount; uint32_t uuidArray; uint32_t dyldAllImageInfosAddress; uint32_t initialImageCount; uint32_t errorKind; uint32_t errorClientOfDylibPath; uint32_t errorTargetDylibPath; uint32_t errorSymbol; uint32_t sharedCacheSlide; std::array sharedCacheUUID; uint32_t sharedCacheBaseAddress; std::atomic infoArrayChangeTimestamp; uint32_t dyldPath; uint32_t notifyMachPorts[8]; uint32_t reserved; uint64_t sharedCacheFSID; uint64_t sharedCacheFSObjID; uint32_t compact_dyld_image_info_addr; uint32_t compact_dyld_image_info_size; uint32_t platform; // the aot fields below will not be set in the 32 bit case uint32_t aotInfoCount; std::atomic aotInfoArray; uint64_t aotInfoArrayChangeTimestamp; uint64_t aotSharedCacheBaseAddress; std::array aotSharedCacheUUID[16]; }; struct dyld_all_image_infos_64 { uint32_t version; uint32_t infoArrayCount; std::atomic infoArray; uint64_t notification; bool processDetachedFromSharedRegion; bool libSystemInitialized; uint32_t paddingToMakeTheSizeCorrectOn32bitAndDoesntAffect64b; // NOT PART OF DYLD_ALL_IMAGE_INFOS! uint64_t dyldImageLoadAddress; uint64_t jitInfo; uint64_t dyldVersion; uint64_t errorMessage; uint64_t terminationFlags; uint64_t coreSymbolicationShmPage; uint64_t systemOrderFlag; uint64_t uuidArrayCount; uint64_t uuidArray; uint64_t dyldAllImageInfosAddress; uint64_t initialImageCount; uint64_t errorKind; uint64_t errorClientOfDylibPath; uint64_t errorTargetDylibPath; uint64_t errorSymbol; uint64_t sharedCacheSlide; std::array sharedCacheUUID; uint64_t sharedCacheBaseAddress; std::atomic infoArrayChangeTimestamp; uint64_t dyldPath; uint32_t notifyMachPorts[8]; uint64_t reserved[7]; uint64_t sharedCacheFSID; uint64_t sharedCacheFSObjID; uint64_t compact_dyld_image_info_addr; uint64_t compact_dyld_image_info_size; uint32_t platform; uint32_t aotInfoCount; std::atomic aotInfoArray; uint64_t aotInfoArrayChangeTimestamp; uint64_t aotSharedCacheBaseAddress; std::array aotSharedCacheUUID[16]; }; 然后： 【未解决】dyld-932.4中gProcessInfo编译后symbol却是__ZN5dyld412gProcessInfoE 自己编译arm64e版的Frida 安装依赖库： pip install colorama prompt-toolkit pygments 设置Python用新版3.10.6 local再去设置为3.10.6的版本： crifan@licrifandeMacBook-Pro  ~/dev/dev_src/ios_reverse/frida  pyenv versions system 3.5.2 3.6.6 3.7.3 * 3.9.4 (set by /Users/crifan/.pyenv/version) 3.10.6 crifan@licrifandeMacBook-Pro  ~/dev/dev_src/ios_reverse/frida  pyenv local 3.10.6 crifan@licrifandeMacBook-Pro  ~/dev/dev_src/ios_reverse/frida  python --version Python 3.10.6 clone frida的代码： git clone --recurse-submodules https://github.com/frida/frida.git 先make看看有哪些编译选项： crifan@licrifandeMacBook-Pro  ~/dev/dev_src/ios_reverse/frida/frida   main  make make[1]: Entering directory '/Users/crifan/dev/dev_src/ios_reverse/frida/frida' Usage: make TARGET [VARIABLE=value] Where TARGET specifies one or more of: /* gum */ gum-macos Build for macOS gum-ios Build for iOS gum-watchos Build for watchOS gum-tvos Build for tvOS gum-android-x86 Build for Android/x86 gum-android-x86_64 Build for Android/x86-64 gum-android-arm Build for Android/arm gum-android-arm64 Build for Android/arm64 check-gum-macos Run tests for macOS /* core */ core-macos Build for macOS core-ios Build for iOS core-watchos Build for watchOS core-tvos Build for tvOS core-android-x86 Build for Android/x86 core-android-x86_64 Build for Android/x86-64 core-android-arm Build for Android/arm core-android-arm64 Build for Android/arm64 check-core-macos Run tests for macOS /* python */ python-macos Build Python bindings for macOS check-python-macos Test Python bindings for macOS /* node */ node-macos Build Node.js bindings for macOS check-node-macos Test Node.js bindings for macOS /* tools */ tools-macos Build CLI tools for macOS check-tools-macos Test CLI tools for macOS And optionally also VARIABLE values: PYTHON Absolute path of Python interpreter including version suffix NODE Absolute path of Node.js binary For example: $ make python-macos PYTHON=/usr/local/bin/python3.6 $ make node-macos NODE=/usr/local/bin/node make[1]: Leaving directory '/Users/crifan/dev/dev_src/ios_reverse/frida/frida' 此处要去编译：iOS的，所以看起来是： core-ios Build for iOS 所以最后去： make core-ios 期间解决了证书问题： 【已解决】Mac中编译frida-core报错：FAILED /usr/bin/codesign IOS_CERTID not set 继续： ✘ crifan@licrifandeMacBook-Pro  ~/dev/dev_src/ios_reverse/frida/frida   main  export MACOS_CERTID=frida-cert crifan@licrifandeMacBook-Pro  ~/dev/dev_src/ios_reverse/frida/frida   main  export IOS_CERTID=frida-cert crifan@licrifandeMacBook-Pro  ~/dev/dev_src/ios_reverse/frida/frida   main  export WATCHOS_CERTID=frida-cert crifan@licrifandeMacBook-Pro  ~/dev/dev_src/ios_reverse/frida/frida   main  export TVOS_CERTID=frida-cert crifan@licrifandeMacBook-Pro  ~/dev/dev_src/ios_reverse/frida/frida   main  make core-ios make[1]: Entering directory '/Users/crifan/dev/dev_src/ios_reverse/frida/frida' . build/frida-env-ios-arm64.rc; \\ builddir=build/tmp-ios-arm64/frida-core; \\ if [ ! -f $builddir/build.ninja ]; then \\ meson_args=\"--native-file build/frida-macos-x86_64.txt\"; if [ ios-arm64 != macos-x86_64 ]; then meson_args=\"$meson_args --cross-file build/frida-ios-arm64.txt\"; fi; python3 /Users/crifan/dev/dev_src/ios_reverse/frida/frida/releng/meson/meson.py setup $meson_args \\ --prefix /usr \\ --default-library static -Doptimization=s -Db_ndebug=true --strip -Dconnectivity=enabled -Dmapper=auto \\ -Dassets=installed \\ frida-core $builddir || exit 1; \\ fi \\ && python3 /Users/crifan/dev/dev_src/ios_reverse/frida/frida/releng/meson/meson.py compile -C $builddir \\ && DESTDIR=\"/Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64\" python3 /Users/crifan/dev/dev_src/ios_reverse/frida/frida/releng/meson/meson.py install -C $builddir INFO: autodetecting backend as ninja INFO: calculating backend command to run: /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/toolchain-macos-x86_64/bin/ninja -C /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/tmp-ios-arm64/frida-core ninja: Entering directory `/Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/tmp-ios-arm64/frida-core' [85/85] Generating lib/gadget/frida-gadget with a custom command ninja: Entering directory `/Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/tmp-ios-arm64/frida-core' ninja: no work to do. Installing lib/base/libfrida-base-1.0.a to /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr/lib Installing lib/base/frida-base.h to /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr/include/frida-1.0 Installing lib/base/frida-base-1.0.vapi to /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr/share/vala/vapi Installing lib/payload/libfrida-payload-1.0.a to /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr/lib Installing lib/payload/frida-payload.h to /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr/include/frida-1.0 Installing lib/payload/frida-payload-1.0.vapi to /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr/share/vala/vapi Installing lib/agent/frida-agent.dylib to /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr/lib/frida Installing lib/gadget/frida-gadget.dylib to /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr/lib/frida Installing src/frida-helper to /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr/lib/frida Installing src/api/frida-core.h to /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr/include/frida-1.0 Installing src/api/frida-core-1.0.vapi to /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr/share/vala/vapi Installing src/api/frida-core-1.0.deps to /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr/share/vala/vapi Installing src/api/libfrida-core-1.0.a to /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr/lib Installing server/frida-server to /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr/bin Installing portal/frida-portal to /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr/bin Installing inject/frida-inject to /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr/bin Installing /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/tmp-ios-arm64/frida-core/meson-private/frida-base-1.0.pc to /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr/lib/pkgconfig Installing /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/tmp-ios-arm64/frida-core/meson-private/frida-payload-1.0.pc to /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr/lib/pkgconfig Installing /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/tmp-ios-arm64/frida-core/meson-private/frida-core-1.0.pc to /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr/lib/pkgconfig make[1]: Leaving directory '/Users/crifan/dev/dev_src/ios_reverse/frida/frida' 即可：编译完成。 我们要找到的：frida-server，貌似是： Installing server/frida-server to /Users/crifan/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr/bin 去看看build目录 crifan@licrifandeMacBook-Pro  ~/dev/dev_src/ios_reverse/frida/frida   main  cd build crifan@licrifandeMacBook-Pro  ~/dev/dev_src/ios_reverse/frida/frida/build   main  ll total 56 -rw-r--r-- 1 crifan staff 190B 1 16 11:45 frida-env-ios-arm64.rc -rw-r--r-- 1 crifan staff 193B 1 16 11:45 frida-env-macos-x86_64.rc drwxr-xr-x 3 crifan staff 96B 1 16 11:47 frida-ios-arm64 -rwxr-xr-x 1 crifan staff 430B 1 16 11:45 frida-ios-arm64-pkg-config -rw-r--r-- 1 crifan staff 2.9K 1 16 11:45 frida-ios-arm64.txt -rwxr-xr-x 1 crifan staff 436B 1 16 11:45 frida-macos-x86_64-pkg-config -rw-r--r-- 1 crifan staff 2.9K 1 16 11:45 frida-macos-x86_64.txt -rw-r--r-- 1 crifan staff 217B 1 16 11:44 frida-version.h drwxr-xr-x 8 crifan staff 256B 1 16 11:45 sdk-ios-arm64 drwxr-xr-x 8 crifan staff 256B 1 16 11:44 sdk-macos-x86_64 drwxr-xr-x 4 crifan staff 128B 1 16 11:47 tmp-ios-arm64 drwxr-xr-x 8 crifan staff 256B 1 16 11:44 toolchain-macos-x86_64 crifan@licrifandeMacBook-Pro  ~/dev/dev_src/ios_reverse/frida/frida/build   main  cd frida-ios-arm64 crifan@licrifandeMacBook-Pro  ~/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64   main  ll total 0 drwxr-xr-x 6 crifan staff 192B 1 16 11:47 usr crifan@licrifandeMacBook-Pro  ~/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64   main  cd usr crifan@licrifandeMacBook-Pro  ~/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr   main  ll total 0 drwxr-xr-x 6 crifan staff 192B 1 16 15:14 bin drwxr-xr-x 3 crifan staff 96B 1 16 11:47 include drwxr-xr-x 13 crifan staff 416B 1 16 15:14 lib drwxr-xr-x 3 crifan staff 96B 1 16 11:47 share crifan@licrifandeMacBook-Pro  ~/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr   main  cd bin crifan@licrifandeMacBook-Pro  ~/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr/bin   main  ll total 40752 -rwxr-xr-x 1 crifan staff 6.2M 1 16 15:13 frida-inject -rwxr-xr-x 1 crifan staff 5.2M 1 16 15:13 frida-portal -rwxr-xr-x 1 crifan staff 6.4M 1 16 15:13 frida-server -rwxr-xr-x 1 crifan staff 2.1M 1 16 11:47 gum-graft crifan@licrifandeMacBook-Pro  ~/dev/dev_src/ios_reverse/frida/frida/build/frida-ios-arm64/usr/bin   main  file ./frida-server ./frida-server: Mach-O 64-bit executable arm64 的确是编译成功了 回去看看之前frida-server的大小和file输出信息 crifan@licrifandeMacBook-Pro  ~/dev/dev_root/iosReverse/AppleStore/debug/gProcessInfo/iPhone11_151  ll total 55248 -rwxr-xr-x@ 1 crifan staff 629K 1 13 10:06 dyld -rw-r--r-- 1 crifan staff 2.5M 1 13 22:14 dyld.id0 -rw-r--r-- 1 crifan staff 1.6M 1 13 22:13 dyld.id1 -rw-r--r-- 1 crifan staff 40K 1 13 22:13 dyld.nam -rw-r--r-- 1 crifan staff 1.3K 1 13 22:13 dyld.til -rw-r--r-- 1 crifan staff 173K 1 13 10:44 dyld_jtool2_S_symbol.txt -rw-r--r-- 1 crifan staff 277B 1 13 10:07 dyld_rabin2_E_exports.txt -rw-r--r-- 1 crifan staff 125B 1 13 10:07 dyld_rabin2_i_imports.txt -rw-r--r-- 1 crifan staff 249K 1 13 21:33 dyld_rabin2_s_r_symbols.txt -rw-r--r-- 1 crifan staff 381K 1 13 10:13 dyld_rabin2_s_symbols.txt -rwxr-xr-x 1 crifan staff 20M 1 12 17:55 frida-server -rw-r--r-- 1 crifan staff 169B 1 12 17:58 fridaServer_rabin2_E_exports.txt -rw-r--r-- 1 crifan staff 17K 1 12 17:58 fridaServer_rabin2_i_imports.txt -rw-r--r-- 1 crifan staff 1.9M 1 13 10:18 fridaSever_rabin2_s_symbols.txt crifan@licrifandeMacBook-Pro  ~/dev/dev_root/iosReverse/AppleStore/debug/gProcessInfo/iPhone11_151  file ./frida-server ./frida-server: Mach-O universal binary with 3 architectures: [arm64:Mach-O 64-bit executable arm64] [arm64e] [arm64e] ./frida-server (for architecture arm64): Mach-O 64-bit executable arm64 ./frida-server (for architecture arm64e): Mach-O 64-bit executable arm64e ./frida-server (for architecture arm64e): Mach-O 64-bit executable arm64e -》此处frida-server很大：20M 不过明显是：FAT格式，包含多个架构： arm64 arm64e 那看起来，貌似有个问题： 此处，从iPhone导出的真实在用的frida-server，支持：arm64e 而此处自己编译出来的，只支持arm64，不支持arm64e 而记得：此处的iPhone中的架构都是：arm64e的？ 感觉需要： 确认iOS 15.1的iPhone11中，此处arm的架构是：arm64e还是arm64 确定其中的frida-server是否需要支持arm64e 如果需要支持arm64e，再去看：frida编译core-ios时，如何指定或加上arm64e的支持 先去： 【基本解决】iOS 15.1的iPhone11中frida-server所用架构是arm64e还是arm64 -》arm64的二进制，是能放到arm64e的A13的iPhone11中运行的。 那先继续看看： 【未解决】自己编译出的arm64的frida-server能否在iPhone11正常运行 其他过程详见： 【未解决】用frida源码自己编译出frida的iOS的包含frida-server的deb安装包 【未解决】自己编译出包含arm64和arm64e的FAT格式的frida-server二进制 【未解决】自己修改编译frida-core源码以尝试解决Frida的Missing gProcessInfo问题 【未解决】Frida中如何编译出iOS的arm64e的frida-server二进制 【未解决】自己编译Frida的frida-core代码生成可用二进制frida-server 找arm64e版的Frida 从Frida源码和build中找 【未解决】找Frida中iOS的arm6e4：从Frida源码和build中找 从Frida的github中找 【未解决】找Frida中iOS的arm6e4：从Frida的github中找 自己给make加echo打印日志调试 【未解决】找Frida中iOS的arm6e4：自己给make加echo打印日志调试 从github的ci的workflow中找arm64e 【未解决】找Frida中iOS的arm6e4：从github的ci的workflow中找arm64e 从编译日志中的Downloading ios-arm64入手 【未解决】找Frida中iOS的arm6e4：从编译日志中的Downloading ios-arm64入手 make时如何传入arm64e的arch参数 【未解决】找Frida中iOS的arm6e4：make时如何传入arm64e的arch参数 从make编译时的log日志入手 【未解决】找Frida中iOS的arm6e4：从make编译时的log日志入手 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-05-25 10:55:36 "},"common_issue/":{"url":"common_issue/","title":"常见问题","keywords":"","body":"常见问题 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-07-21 15:57:12 "},"common_issue/universal/":{"url":"common_issue/universal/","title":"通用","keywords":"","body":"通用 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-07-21 16:00:50 "},"common_issue/universal/process_terminated.html":{"url":"common_issue/universal/process_terminated.html","title":"Process terminated","keywords":"","body":"Process terminated 关于Process terminated=进程结束=崩溃退出，目前遇到多种现象和可能原因： 由于hook函数太多导致崩溃 现象一：用frida-trace去hook太多的类Obj的函数frida-trace -U -F com.apple.Preferences -m \"*[AA* *]\" -m \"*[AK* *]\" -m \"*[AS* *]\" -m \"*[NS* *]\" -M \"-[ASDBundle copyWithZone:]\" -M \"-[ASDInstallationEvent copyWithZone:]\" 导致崩溃退出报错：Process terminated 原因：frida-trace去hook的函数太多了，估计是，加了-m \"*[NS* *]\"后导致崩溃 注：iOS的ObjC的内部的多数，甚至是大多数，都是NS开头的，导致匹配到太多的类和函数，系统处理不过来了，导致frida崩溃，同时导致被调试的app崩溃。 注：NS=NextStep，是iOS系统前身的苹果收购的NextStep公司名字 解决办法：减少hook的范围=缩小匹配范围，比如此处改为：-m \"*[NSXPC* *]\"，暂时只关注我们要调试的NSXPCConnection的相关内容，基本上可以：避免崩溃 frida的new ObjC.Object方面的bug 现象： 概述frida调试时，由于加了new ObjC.Object(someArg)的ptr转换成ObjC的对象，结果就会时不时的遇到Process terminated，而崩溃停止退出调试 详解=具体现象 代码： ... function hook_class_method(class_name, method_name) { var hook = ObjC.classes[class_name][method_name]; Interceptor.attach(hook.implementation, { onEnter: function(args) { console.log(\"=========== [*] Detected call to: \" + class_name + \" -> \" + method_name); //objc的函数，第0个参数是id，第1个参数是SEL，真正的参数从args[2]开始 const argId = args[0]; // console.log(\"argId: \", argId); const argSel = args[1]; // console.log(\"argSel: \", argSel); const argSelStr = ObjC.selectorAsString(argSel); console.log(\"argSelStr: \", argSelStr); const argCount = occurrences(argSelStr, \":\"); console.log(\"argCount: \", argCount); for (let curArgIdx = 0; curArgIdx 可以hook输出部分log日志，但是很快，时不时的，就崩溃退出了： ✘ crifan@licrifandeMacBook-Pro  ~/dev/dev_root/iosReverse/AppleStore/Preferences_app/dynamicDebug/frida  frida -U -l hookAccountLogin_NSURL.js -F ____ / _ | Frida 16.0.10 - A world-class dynamic instrumentation toolkit | (_| | > _ | Commands: /_/ |_| help -> Displays the help system . . . . object? -> Display information about 'object' . . . . exit/quit -> Exit . . . . . . . . More info at https://frida.re/docs/home/ . . . . . . . . Connected to iPhone (id=abdc0dd961c3cb96f5c4afe109de4eb48b88433a) [*] Started: Hook all methods of a specific class [+] Class Name: NSURL [*] Omit hooking + allocWithZone: [*] Omit hooking - _cfTypeID [*] Omit hooking - retain [*] Omit hooking - release [*] Omit hooking - copyWithZone: [*] Completed: Hook all methods of a specific class [iPhone::设置 ]-> =========== [*] Detected call to: NSURL -> - scheme argSelStr: scheme argCount: 0 =========== [*] Detected call to: NSURL -> - _cfurl argSelStr: _cfurl argCount: 0 =========== [*] Detected call to: NSURL -> - scheme argSelStr: scheme argCount: 0 =========== [*] Detected call to: NSURL -> - _cfurl argSelStr: _cfurl argCount: 0 =========== [*] Detected call to: NSURL -> + fileURLWithPath:isDirectory: argSelStr: fileURLWithPath:isDirectory: argCount: 2 ---------- [0] curArg=0x282336580 curArg className: undefined curArgObj: /var/mobile/Library/Caches/com.apple.AppleAccount curArgObj className: NSPathStore2 ---------- [1] curArg=0x0 =========== [*] Detected call to: NSURL -> - initFileURLWithPath:isDirectory: argSelStr: initFileURLWithPath:isDirectory: argCount: 2 ---------- [0] curArg=0x282336580 curArg className: undefined curArgObj: /var/mobile/Library/Caches/com.apple.AppleAccount curArgObj className: NSPathStore2 ---------- [1] curArg=0x0 =========== [*] Detected call to: NSURL -> - setResourceValues:error: argSelStr: setResourceValues:error: argCount: 2 Process terminated [iPhone::设置 ]-> Thank you for using Frida! 原因：暂不完全清楚 可能原因：frida的ObjC的Objcect转换方面的bug，暂时无法解决 详见： 【未解决】frida中hook函数打印参数值时最后app崩溃frida输出Process terminated 【未解决】frida中hook调试iOS的ObjC的函数参数时始终出现崩溃Process terminated crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-07-21 15:57:08 "},"common_issue/universal/unable_find_process.html":{"url":"common_issue/universal/unable_find_process.html","title":"unable to find process with name","keywords":"","body":"Failed to spawn: unable to find process with name 报错：Failed to spawn: unable to find process with name 'Preferences' 原因：frida命令用的是frida -U -l ./hookAccountLogin.js -n Preferences 其中-n是加二进制名称，此处Preferences是app，所以属于参数使用错误，调试目标语法搞错了 解决办法： 搞懂frida的调试目标方式，改为别的方式即可 方式1：用-N app_package_idfrida -U -l ./hookAccountLogin.js -N com.apple.Preferences 方式2：换-p PIDfrida -U -l ./hookAccountLogin.js -p 18031 其中是用iPhone中ssh中通过ps查看到~ ps -A | grep Preferences ... 18031 ?? 0:02.43 /Applications/Preferences.app/Preferences 得知Preferences的PID是18031 方式3：用-Ffrida -U -l ./hookAccountLogin.js -F 注：确保Preferences=系统的设置app，处于最前台在运行才能用-F crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-07-21 16:01:33 "},"common_issue/universal/unable_to_attach_to_the_specified_proces.html":{"url":"common_issue/universal/unable_to_attach_to_the_specified_proces.html","title":"unable to attach to the specified proces","keywords":"","body":"Failed to attach unable to attach to the specified proces 背景：用palera1nC越狱后 注：之前只有palera1nC能越狱15.6的系统 现象：frida-trace去hook调试报错~% frida-trace -U -i CCCrypt -p 12959 Failed to attach: unable to attach to the specified proces 原因：iPhone端的frida（frida-server）没有正常运行 如何确认=如何找到的问题的原因？iPhone:~ root# ps -A l grep frida 3576 ttys000 0:00.00 grep frida iPhone:~root# 解决办法 iPhone端，重新安装frida，确保安装后frida-server已正常启动在运行 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-07-23 17:16:38 "},"common_issue/universal/pause_or_no_pause.html":{"url":"common_issue/universal/pause_or_no_pause.html","title":"--no-pause和--pause","keywords":"","body":"--no-pause和--pause 关于frida启动后，被调试的目标，是否暂停运行的问题： 背景 frida启动调试后，被调试的目标（app或进程），是否已经暂停运行 旧版frida：自动暂停运行 支持参数：--no-pause 新版frida：（逻辑已经变成了）不暂停运行 = 已经继续运行了 支持参数：--pause 所以 旧版frida 常会遇到一个问题：每次frida（以Attach后Spawn去）启动调试后，程序自动暂停运行 解决办法：手动输入%resume 所以就希望：frida调试开始后，自动继续运行，不要每次都输入%resume才继续运行 解决办法：加--no-pause参数 参数含义：--no-pause automatically start main thread after startup 举例frida -U --no-pause -f com.ss.iphone.ugc.Aweme -l frida/dyldImage.js 新版frida 用新版frida，加了参数--no-pause，报错不支持此参数：frida: error: unrecognized arguments: --no-pause 解决办法：不要加任何参数 举例frida -U -N com.apple.Preferences -l hookAccountLogin_singleClassAllMethod.js -》 如果需要启动后 自动继续运行 则：无需加任何参数 因为新版frida已经变成这个逻辑了 自动暂停运行 再去加新版才支持的参数：--pause 参数含义：--pause leave main thread paused after spawning program crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-07-21 16:04:01 "},"common_issue/universal/bad_access_invalid_address.html":{"url":"common_issue/universal/bad_access_invalid_address.html","title":"Bad access due to invalid address","keywords":"","body":"Process crashed: Bad access due to invalid address 问题： Called: -[WARegistrationURLBuilder clientLogRequestURLWithCurrentScreen:previousScreen:actionTaken:] ... argCount: 3 ---------- [0] curArgPtr=0xc Process crashed: Bad access due to invalid address ... 原因 表面原因：访问了非法地址：0xc 深层次原因：对于值明显异常的地址，没有做过滤，没有排除掉 解决办法：加上过滤，排除掉，地址值明显异常的地址 具体步骤： 代码改为： // check pointer is valid or not // example // 0x103e79560 => true // 0xc => false function isValidPointer(curPtr){ let MinValidPointer = 0x10000 var isValid = curPtr > MinValidPointer return isValid } ... if (isValidPointer(curArg)) { ... } 即可避免访问非法地址指针，避免崩溃。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-07-21 16:04:45 "},"common_issue/universal/file_descriptor_cannot_negative_integer.html":{"url":"common_issue/universal/file_descriptor_cannot_negative_integer.html","title":"ValueError file descriptor cannot be a negative integer","keywords":"","body":"ValueError: file descriptor cannot be a negative integer 问题：frida-ps、frida-ls-devices等frida-tools工具运行时报错：ValueError: file descriptor cannot be a negative integer (-42) 原因：当前12.0.3的frida-tools有bug 解决办法：升级到最新版frida-tools 具体步骤：pip install --upgrade frida_tools 注：查看当前frida-tools的版本：pip show frida_tools crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-07-21 15:55:41 "},"common_issue/universal/stuck_spawning.html":{"url":"common_issue/universal/stuck_spawning.html","title":"卡死在Spawning","keywords":"","body":"卡死在Spawning 现象：frida去hook时，一直显示=卡死在Spawning➜ frida frida -U -f com.ss.android.ugc.aweme -l hook_douyin.js ____ / _ | Frida 16.4.6 - A world-class dynamic instrumentation toolkit | (_| | > _ | Commands: /_/ |_| help -> Displays the help system . . . . object? -> Display information about 'object' . . . . exit/quit -> Exit . . . . . . . . More info at https://frida.re/docs/home/ . . . . . . . . Connected to Pixel 5 (id=9C181A8D3C3F3B) Spawning `com.ss.android.ugc.aweme`... -> 当时的错误操作：以为真的卡死了，所以去找别的可能的原因，所以就去直接用Ctrl+C中断运行了 原因：其实并没有卡死，而是多等会，会有最终结果 是超时报错，还是能正常运行 解决办法：多等一会，看看最终的结果 结果1：正常 结果1：正常继续hook和输出log ➜ frida frida -U -f com.ss.android.ugc.aweme -l hook_douyin.js ... Spawning `com.ss.android.ugc.aweme`... Java is available Java.androidVersion=13 Spawned `com.ss.android.ugc.aweme`. Resuming main thread! [Pixel 5::com.ss.android.ugc.aweme ]-> 解决办法：无需任何操作，只是稍微多等会 结果2：异常 结果1：报错超时等异常 情况1 ➜ frida frida -U -f com.ss.android.ugc.aweme -l hook_douyin.js ... . . . . Connected to Pixel 5 (id=9C181A8D3C3F3B) Failed to spawn: timeout was reached 此处的背景 此处之前Frida的hook，触发输出太多log，自己强制输入（多次输入，因为输出log太多，都无法顺利输入）exit退出Frida后，然后不知道什么情况，总之是：导致了安卓端的Frida异常 解决办法：重启Android手机 情况2 ➜ frida frida -U -f com.ss.android.ugc.aweme -l hook_douyin.js ... . . . . Connected to Pixel 5 (id=9C181A8D3C3F3B) Failed to spawn: unexpectedly timed out while waiting for app to launch 解决办法：多试试几次（有时候就正常了） crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-07-26 09:57:19 "},"common_issue/js/":{"url":"common_issue/js/","title":"js","keywords":"","body":"js常见问题 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-05-25 11:01:53 "},"common_issue/js/rangeerror_invalid_arr_idx.html":{"url":"common_issue/js/rangeerror_invalid_arr_idx.html","title":"RangeError invalid array index","keywords":"","body":"RangeError: invalid array index 错误：Frida的hook脚本js中Interceptor.attach(functionRealAddress, { onEnter: function(args) { console.log(args); 会报错：RangeError: invalid array index 原因：无法知道准确的args的数组的大小，无法直接打印，所以报错 解决办法：不去直接打印，而改为去获取对应的前几个参数（前提：已知参数个数），再去打印：Interceptor.attach(functionRealAddress, { onEnter: function(args) { var arg0 = args[0] var arg1 = args[1] var arg2 = args[2] console.log(\"arg0=\" + arg0 + \", arg1=\" + arg1 + \", arg2=\" + arg2); 进一步优化：甚至是，计算出此处的ObjC的参数的个数，循环批量打印所有参数 具体详见：ObjC的参数 · 逆向调试利器：Frida中的计算ObjC的函数的真正参数的个数 + 打印全部参数 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-05-25 11:02:43 "},"sub_books/":{"url":"sub_books/","title":"子教程","keywords":"","body":"子教程 Frida调试经验总结 Frida调试Android经验总结 Frida调试iOS经验总结 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-12-13 21:55:56 "},"appendix/":{"url":"appendix/","title":"附录","keywords":"","body":"附录 下面列出相关参考资料。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2022-03-17 20:39:28 "},"appendix/reference.html":{"url":"appendix/reference.html","title":"参考资料","keywords":"","body":"参考资料 【已解决】frida-trace去hook导致app崩溃最后输出Process terminated 【未解决】Mac中frida-trace报错：Failed to spawn unable to find process with name 【已解决】用frida去hook报错：Failed to spawn unable to find process with name 【已解决】Frida启动js脚本报错：Error could not parse line 1 expecting , 【规避解决】frida中console.log打印时参数格式化无效 【未解决】Frida中js的console.log日志打印格式化参数 【已解决】frida的脚本中console.log打印args报错：RangeError invalid array index 【已解决】js中console.log如何打印对象[object Object] 【已解决】Frida启动js脚本报错：Error could not parse line 1 expecting , 【未解决】frida报错：Failed to spawn: the connection is closed 【已解决】frida运行报错：Waiting for USB device to appear 【未解决】Mac中用Frida但报错Failed to enumerate processes the connection is closed且导致iPhone重启 【已解决】frida去hook函数报错：TypeError cannot read property implementation of undefined 【未解决】frida中hook函数打印参数值时最后app崩溃frida输出Process terminated 【未解决】frida-server运行报错：Failed to spawn this feature requires an iOS Developer Disk Image to be mounted 【未解决】frida去hook监控iOS的ObjC函数时经常会崩溃Process terminated 【未解决】研究frida崩溃Process terminated：通过Preferences的崩溃日志找原因 【记录】Frida调试导致iPhone8重启而丢失palera1n越狱 【未解决】Mac中Frida报错且导致iPhone重启：重新修复XinaA15越狱环境 【未解决】frida导致iPhone重启：从崩溃日志ips文件分析去找可能原因 【未解决】Mac中用Frida但报错Failed to enumerate processes the connection is closed且导致iPhone重启 【未解决】Frida调试Apple Store报错：Failed to attach missing gProcessInfo 【已解决】frida-ios-dump给iOS 15.1的iPhone中app砸壳报错：missing gProcessInfo 【已解决】研究frida中是否存在导入外部变量gProcessInfo 【未解决】研究Frida中Missing gProcessInfo出错的逻辑和原因 【已解决】研究二进制/usr/lib/dyld中是否包含或导出变量_gProcessInfo 【记录】dyld源码中的gProcessInfo 【已解决】Frida源码中找到了：gProcessInfo 【未解决】找Frida中iOS的arm6e4：从Frida源码和build中找 【未解决】找Frida中iOS的arm6e4：从Frida的github中找 【未解决】找Frida中iOS的arm6e4：自己给make加echo打印日志调试 【未解决】找Frida中iOS的arm6e4：从github的ci的workflow中找arm64e 【未解决】找Frida中iOS的arm6e4：从编译日志中的Downloading ios-arm64入手 【未解决】找Frida中iOS的arm6e4：make时如何传入arm64e的arch参数 【未解决】找Frida中iOS的arm6e4：从make编译时的log日志入手 【基本解决】iOS 15.1的iPhone11中frida-server所用架构是arm64e还是arm64 【未解决】自己编译出的arm64的frida-server能否在iPhone11正常运行 【未解决】用frida源码自己编译出frida的iOS的包含frida-server的deb安装包 【未解决】自己编译出包含arm64和arm64e的FAT格式的frida-server二进制 【未解决】自己修改编译frida-core源码以尝试解决Frida的Missing gProcessInfo问题 【未解决】Frida中如何编译出iOS的arm64e的frida-server二进制 【未解决】自己编译Frida的frida-core代码生成可用二进制frida-server 【未解决】iOS逆向：如何反代码混淆反混淆去混淆 【未解决】Mac中Frida启动抖音app进程并调试和hook函数 【未解决】用Frida的frida-trace去hook函数iOS版抖音 【未解决】frida调试抖音app去hook函数：_dyld_get_image_name 【未解决】frida去hook函数_dyld_get_image_name时打印参数为字符串 【记录】Frida调试参数ak_sh逻辑：com.bytedance.retrofit2.client.Request的构造函数 【已解决】Frida去hook函数报错：Error unable to intercept function at please file a bug 【已解决】Frida中js代码中两个地址指针数值相加 【整理】Frida中对于js代码的支持不够完美 String (Java Platform SE 8 ) (oracle.com) crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-12-13 22:56:53 "}}