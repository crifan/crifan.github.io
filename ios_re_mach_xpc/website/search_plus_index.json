{"./":{"url":"./","title":"前言","keywords":"","body":"iOS逆向：Mach消息和XPC进程通信 最新版本：v0.6.0 更新时间：20250127 简介 整理iOS逆向涉及到的，Mach消息和XPC进程间通信相关内容。便于搞懂，进程间的消息发送的相关逻辑。 源码+浏览+下载 本书的各种源码、在线浏览地址、多种格式文件下载如下： HonKit源码 crifan/ios_re_mach_xpc: iOS逆向：Mach消息和XPC进程通信 如何使用此HonKit源码去生成发布为电子书 详见：crifan/honkit_template: demo how to use crifan honkit template and demo 在线浏览 iOS逆向：Mach消息和XPC进程通信 book.crifan.org iOS逆向：Mach消息和XPC进程通信 crifan.github.io 离线下载阅读 iOS逆向：Mach消息和XPC进程通信 PDF iOS逆向：Mach消息和XPC进程通信 ePub iOS逆向：Mach消息和XPC进程通信 Mobi 版权和用途说明 此电子书教程的全部内容，如无特别说明，均为本人原创。其中部分内容参考自网络，均已备注了出处。如发现有侵权，请通过邮箱联系我 admin 艾特 crifan.com，我会尽快删除。谢谢合作。 各种技术类教程，仅作为学习和研究使用。请勿用于任何非法用途。如有非法用途，均与本人无关。 鸣谢 感谢我的老婆陈雪的包容理解和悉心照料，才使得我crifan有更多精力去专注技术专研和整理归纳出这些电子书和技术教程，特此鸣谢。 其他 作者的其他电子书 本人crifan还写了其他150+本电子书教程，感兴趣可移步至： crifan/crifan_ebook_readme: Crifan的电子书的使用说明 关于作者 关于作者更多介绍，详见： 关于CrifanLi李茂 – 在路上 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-01-27 16:38:11 "},"mach_xpc_overview/":{"url":"mach_xpc_overview/","title":"Mach和XPC概述","keywords":"","body":"Mach和XPC概述 iOS逆向期间，会涉及到，Mach内核的Mach消息和XPC进程间通信 主要目标是：需要搞懂，一个消息，如何从A发送到B的整个流程和逻辑。 从而才能继续追踪代码运行逻辑，直至彻底搞懂底层相关代码逻辑。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-01-27 16:23:35 "},"mach/":{"url":"mach/","title":"Mach","keywords":"","body":"Mach TODO： 【整理】iOS底层机制：微内核Mach 【未解决】iOS逆向：NSXPCConnection发送mach消息event的逻辑 【未解决】iOS逆向相关：mach_msg发送消息后如何获取到返回的数据 【未解决】debugserver+lldb调试___lldb_unnamed_symbol2567$$akd的mach_msg真正发送消息的逻辑 【未解决】iOS逆向Apple账号：dispatch_mach_msg_get_msg 【整理】iOS逆向相关函数：mach_msg 【整理】iOS逆向相关定义：mach_msg_header_t 【已解决】iOS逆向相关：mach_msg和mig 【未解决】调试___lldb_unnamed_symbol2567$$akd的mach_msg之后如何获取和访问返回的数据 【未解决】iOS逆向Apple账号：_xpc_connection_mach_event 【已解决】iOS逆向相关函数：voucher_mach_msg_set 【整理】iOS中的XNU 【未解决】iOS逆向Apple账号：OS_dispatch_mach 【未解决】iOS逆向Apple账号：OS_dispatch_mach_msg 【未解决】debugserver+lldb调试___lldb_unnamed_symbol2567$$akd发送mach_msg之前的准备工作 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-01-27 15:23:59 "},"mach/core/":{"url":"mach/core/","title":"Mach内核","keywords":"","body":"Mach架构 Mach 是什么：操作系统的内核 类型：Microkernel=微内核 发展历史 最早：卡耐基梅隆大学开发 目标：取代BSD的UNIX核心 后来：Apple采用，作为Darwin的核心的XNU的其中一部分 历史版本 早期 Mach v2.5 来自：Carnegie Mellon University=卡耐基梅隆大学 Mach v3.0 来自：Carnegie Mellon University=卡耐基梅隆大学 Mach v4 来自：University of Utah=犹他大学 后来 OSFMK 7.3 OSFMK=Open Software Foundation Mach Kernel 来自：OSF=The Open Software Foundation （这个微内核）包含=组成 仅能处理最基本的操作系统职责 虚拟内存的管理=memory protection=Virtual Memory=Protected Memory virtual memory support support for large virtual address spaces, shared memory regions, and memory objects backed by persistent store support for pagers 任务管理 进程和线程的抽象 Parallel Execution Preemptive Multitasking=preemptively scheduled threads 支持SMP 任务调度 IPC=进程间通信=进程间通信和消息传递机制 messaging 概述：a messaging-centered infrastructure Message Passing=消息传递 RPC synchronization notification 特点 优点 服务进程容易扩展 得益于这种扩展性，使得 Mach-O能支持多架构文件 详见 可执行文件格式：Mach-O macOS能顺利的从PowerPC过渡到Intel再到M1 服务进程出问题不会危及到kernel 缺点 微内核的功能本来就少，其他 OS 功能是作为基础服务建设在用户模式下的。因为这个特性其内部任务的调用会有更频繁的内核态/用户态上下文切换，这会额外消耗时间。同时内核与服务进程之间的消息传递也会降低运行效率，所以这种设计通常会降低性能 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-01-27 15:29:51 "},"mach/message/":{"url":"mach/message/","title":"Mach消息","keywords":"","body":"Mach消息 Mach Message=Mach消息=Mach消息传递 （Mach的IPC的）核心点 Mach最基础的概念就是两个端点Port中交换的message message 是什么：一个message就是msgh_size大小的blob, 带着一些flags，从一个端口发送到另一个端口 核心函数 mach_msg() mach_msg_send() mach_msg_receive() mach_msg_trap() mach_msg_overwrite_trap() 架构 Mach Message细节 相关定义 typedef struct { mach_msg_header_t header; mach_msg_body_t body; } mach_msg_base_t; // 消息头是必须的，它定义了一个消息所需要的数据 typedef struct { mach_msg_bites_t msgh_bits; mach_msg_size_t msgh_size; mach_port_t msgh_remote_port; mach_port_t msgh_local_port; mach_msg_size_t msgh_reserved; mach_msg_id_t msgh_id; } mach_msg_header_t; mach_msg_return_t mach_msg( mach_msg_header_t msg,f mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t reveive_limit, mach_port_t reveive_name, mach_msg_timeout_t timeout, mach_port_t notify, ); crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-01-27 15:32:18 "},"xpc/":{"url":"xpc/","title":"XPC进程间通讯","keywords":"","body":"XPC进程间通讯 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-01-27 14:13:12 "},"xpc/nsxpcconnection/":{"url":"xpc/nsxpcconnection/","title":"NSXPCConnection","keywords":"","body":"NSXPCConnection TODO： iOS IPC NSXPCConnection launchd 【未解决】iOS逆向akd：NSXPCConnection的resume和active相关函数 【未解决】iOS逆向akd：NSXPCConnection的exportedInterface、exportedObject等内容 【已解决】iOS逆向：寻找name是com.apple.ak.auth.xpc的Server端的NSXPCConnection 【未解决】iOS逆向akd：NSXPCConnection中类__NSXPCInterfaceProxy_AKAnisetteProvisioningAndSigningDeamonInterface的函数fetchAnisetteDataAndProvisionIfNecessary:device:completion:的来源 【已解决】iOS逆向：frida调试hook类NSXPCConnection的setExportedObject 【未解决】iOS逆向Apple账号：从com.apple.ak.anisette.xpc的NSXPCConnection获取到AKAnisetteData的过程 【未解决】iOS逆向Apple账号：寻找NSXPCConnection解析调用shouldContinueWithAuthenticationResults:error:forContextID:completion:的地方 【未解决】iOS逆向：NSXPCConnection发送mach消息event的逻辑 【记录】iOS逆向Apple账号：重新用frida-trace追踪带NSXPCConnection的Apple账号的完整登录过程 【未解决】iOS逆向Apple账号：NSXPCConnection相关 【未解决】iOS逆向Apple账号：研究-[NSXPCConnection remoteObjectProxyWithErrorHandler:]返回类型是__NSXPCInterfaceProxy_AKAppleIDAuthenticationDaemonProtocol 【未解决】iOS逆向Apple账号：NSXPCConnection的AuthKit的akd如何生成AKAnisetteData 【未解决】iOS逆向Apple账号：-[NSXPCConnection _sendInvocation:orArguments:count:methodSignature:selector:withProxy:] 【已解决】iOS逆向Apple账号：-[NSXPCConnection remoteObjectProxyWithErrorHandler:]的hook代码断点加不上 【未解决】iOS逆向Apple账号：-[NSXPCConnection _sendSelector:withProxy:arg1:arg2:] 【记录】iOS逆向akd：com.apple.ak.auth.xpc的NSXPCConnection相关调用逻辑和内容 【规避解决】XCode实时调试NSXPCConnection的_XCT_fetchSnapshotForElement:attributes:parameters:reply错误 【未解决】iOS逆向Apple账号：__88-[NSXPCConnection _sendInvocation:orArguments:count:methodSignature:selector:withProxy:]_block_invoke_3 【已解决】iOS逆向akd：com.apple.ak.anisette.xpc的NSXPCConnection调用fetchAnisetteDataAndProvisionIfNecessary:device:completion:的过程 【已解决】iOS逆向Apple账号：用frida打印com.apple.ak.auth.xpc的NSXPCConnection的其他属性值 【未解决】iOS逆向akd：Preferences通过NSXPCConnection获取AnisetteData后触发了akd中什么函数去处理 【未解决】iOS逆向akd：NSXPCConnection的init初始化相关 【已解决】Xcode中Logos插件hook代码编译报错：Expected unqualified-id XPC的NSXPCConnection的基本逻辑 Client端：发送消息给Server端 举例 connection to service with pid 125 named com.apple.ak.anisette.xpc 注：Server端的akd的PID=125 remoteObjectProxy 含义：remote Object 的 Proxy== （Server端的）负责处理对应函数的所属的类 的 代理 举例 remoteObjectInterface 含义：Server端的所能处理哪些函数 举例 Protocol: AKAnisetteProvisioningAndSigningDeamonInterface 内部其实继承了2个protocol AKAnisetteProvisioningDaemonProtocol attestationDataForDevice:withRequest:completion: legacyAnisetteDataForDSID:device:completion: fetchAnisetteDataAndProvisionIfNecessary:device:completion: eraseAnisetteForDevice:completion: syncAnisetteWithSIMData:device:completion: provisionAnisetteForDevice:completion: AKAppleIDSigningDaemonProtocol signaturesForData:options:completion: absintheSignatureForData:completion: Server端=Listener端：监听别人发送来的消息 举例 connection from pid 17416 on mach service named com.apple.ak.anisette.xpc 注：Client端的Preferences的PID=17416 exportedObject 说明： 会触发到：-[NSXPCConnection setExportedObject:]，设置了后续将要用的exportedObject 举例 其对应着的，内部conform了2个protocol AKAnisetteProvisioningDaemonProtocol AKAppleIDSigningDaemonProtocol 所以能支持Client端发来的消息（中的函数，然后去处理） exportedInterface 说明： 会触发到：-[NSXPCConnection setExportedInterface:] 举例 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-01-27 16:16:23 "},"xpc/nsxpcconnection/example/":{"url":"xpc/nsxpcconnection/example/","title":"举例","keywords":"","body":"举例 Client端的Preferences发送给Server端的akd 概述 Client端的Preferences的NSXPCConnection：去发送XPC消息=调用函数 -[__NSXPCInterfaceProxy_AKAnisetteProvisioningAndSigningDeamonInterface fetchAnisetteDataAndProvisionIfNecessary:device:completion:] Server端的akd的NSXPCConnection：去接收XPC消息=找到对应函数去处理 -[AKAnisetteProvisioningService fetchAnisetteDataAndProvisionIfNecessary:device:completion:] 详解 先明白基础概念和此处所涉及到的内容： 当前的NSXPCConnection serviceName=com.apple.ak.anisette.xpc Client端 iOS的app：设置=Preferences 包名：com.apple.Preferences 二进制：/Applications/Preferences.app/Preferences Server端=Listener端 AuthKit库的daemon服务程序：akd 二进制：/System/Library/PrivateFrameworks/AuthKit.framework/akd 此处最初的情况是： Client端的：Preferences 的 NSXPCConnection log信息 connection to service with pid 125 named com.apple.ak.anisette.xpc 注：akd的PID=125 remoteObjectProxy remoteObjectInterface Protocol: AKAnisetteProvisioningAndSigningDeamonInterface 此处po能查看到：所有的函数 fetchAnisetteDataAndProvisionIfNecessary:device:completion: absintheSignatureForData:completion: attestationDataForDevice:withRequest:completion: syncAnisetteWithSIMData:device:completion: eraseAnisetteForDevice:completion: provisionAnisetteForDevice:completion: legacyAnisetteDataForDSID:device:completion: signaturesForData:options:completion: 从头文件中可以确认：其实是conform遵守了2个protocol，且对应的函数正好是2个protocol的函数 AKAnisetteProvisioningDaemonProtocol attestationDataForDevice:withRequest:completion: legacyAnisetteDataForDSID:device:completion: fetchAnisetteDataAndProvisionIfNecessary:device:completion: eraseAnisetteForDevice:completion: syncAnisetteWithSIMData:device:completion: provisionAnisetteForDevice:completion: AKAppleIDSigningDaemonProtocol signaturesForData:options:completion: absintheSignatureForData:completion: Server端的：akd 的 NSXPCConnection log信息 connection from pid 17416 on mach service named com.apple.ak.anisette.xpc 注：Preferences的PID=17416 exportedObject 而AKAnisetteProvisioningService这个类，是akd中才有的 且实现了conform了前面的2个protocol AKAnisetteProvisioningDaemonProtocol AKAppleIDSigningDaemonProtocol exportedInterface 所以最终的调用的过程是： Client端Preferences中的NSXPCConnection，去调用 -[__NSXPCInterfaceProxy_AKAnisetteProvisioningAndSigningDeamonInterface fetchAnisetteDataAndProvisionIfNecessary:device:completion:] 即： -[ fetchAnisetteDataAndProvisionIfNecessary:device:completion: 1 0 ] 过程是： 会触发到：Server端的exportedObject的类：AKAnisetteProvisioningService 去调用对应的函数去处理 -[AKAnisetteProvisioningService fetchAnisetteDataAndProvisionIfNecessary:device:completion:] 注：因为本身AKAnisetteProvisioningService就conform了对应的2个protocol：AKAnisetteProvisioningDaemonProtocol``、AKAppleIDSigningDaemonProtocol，所以支持这些函数调用 最终是触发： -[AKAnisetteProvisioningService fetchAnisetteDataAndProvisionIfNecessary:device:completion:] crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-01-27 16:20:48 "},"appendix/":{"url":"appendix/","title":"附录","keywords":"","body":"附录 下面列出相关参考资料。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-01-27 14:05:29 "},"appendix/reference.html":{"url":"appendix/reference.html","title":"参考资料","keywords":"","body":"参考资料 【已解决】iOS逆向：XPC的NSXPCConnection获取数据的基本逻辑 【未解决】iOS逆向：通过查看NSXPCConnection的属性值搞清楚目标处理的类是哪个 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2025-01-27 16:15:16 "}}