{"./":{"url":"./","title":"前言","keywords":"","body":"iOS逆向：心得集锦 最新版本：v1.0.0 更新时间：20240927 简介 把iOS逆向中的，各种不适合、不方便、不应该放到某个其他独立子教程中的心得，都整理过来，放到此处iOS逆向心得集锦中，方便参考；包括心得概述；iPhone的初始化开发环境和常用目录；app的plist文件、相关文件目录和数据，包括Bundle、Data、Shared AppGroup；二进制文件路径，app的卸载的残留数据；Keychain数据库及字段含义；以及ObjC的运行时，包括objc_msgSend、objc_alloc；Class类的打印类的描述详情信息、成员属性包括公开和私有的和扩展属性；以及类和实例的对比；以及属性值，如何获取变量的值，包括dict字典；计算类的属性值；Xcode和Frida属性值不一样；以及动态调试的调试代码逻辑，寻找函数触发时机；alloc和init和new；重装和spawn方式；寻找变量改动时机；wivar；改变运行逻辑的修改寄存器值、hook函数返回值；Xcode调试包括Attach调试、函数调用堆栈，函数名不一致；产看当前所有变量值；Fetching Variables on iPhone；汇编代码窗口保持打开状态；2个调试目标arm64和arm64e；xm文件无法定位到源代码位置；实时调试hook代码；和LLDB的正则搜索；iOSOpenDev；Mach-O的image base基地址；log日志的超过1K的打印；头文件的试试新旧不同版本；抓包的request和response；tweak插件；crash崩溃的崩溃日志解析工具、从崩溃信息找崩溃所在位置；和通用的：从汇编反推代码逻辑、必要时hook多个目标、特殊的参数传递、hook代码没生效、hook导致很慢和卡死；最后有附录相关资料。 源码+浏览+下载 本书的各种源码、在线浏览地址、多种格式文件下载如下： HonKit源码 crifan/ios_re_experience_collection: iOS逆向：心得集锦 如何使用此HonKit源码去生成发布为电子书 详见：crifan/honkit_template: demo how to use crifan honkit template and demo 在线浏览 iOS逆向：心得集锦 book.crifan.org iOS逆向：心得集锦 crifan.github.io 离线下载阅读 iOS逆向：心得集锦 PDF iOS逆向：心得集锦 ePub iOS逆向：心得集锦 Mobi 版权和用途说明 此电子书教程的全部内容，如无特别说明，均为本人原创。其中部分内容参考自网络，均已备注了出处。如发现有侵权，请通过邮箱联系我 admin 艾特 crifan.com，我会尽快删除。谢谢合作。 各种技术类教程，仅作为学习和研究使用。请勿用于任何非法用途。如有非法用途，均与本人无关。 鸣谢 感谢我的老婆陈雪的包容理解和悉心照料，才使得我crifan有更多精力去专注技术专研和整理归纳出这些电子书和技术教程，特此鸣谢。 其他 作者的其他电子书 本人crifan还写了其他150+本电子书教程，感兴趣可移步至： crifan/crifan_ebook_readme: Crifan的电子书的使用说明 关于作者 关于作者更多介绍，详见： 关于CrifanLi李茂 – 在路上 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-27 14:19:41 "},"experience_summary/":{"url":"experience_summary/","title":"iOS逆向心得概述","keywords":"","body":"iOS逆向心得概述 把iOS逆向中的，各种不适合、不方便、不应该放到某个其他独立子教程中的心得，都整理过来，放到此处iOS逆向心得集锦中，方便参考。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-03-05 22:31:20 "},"experience_summary/overall_strategy.html":{"url":"experience_summary/overall_strategy.html","title":"总体对策","keywords":"","body":"iOS逆向的总体对策 TODO： 【整理】iOS逆向心得：不同app的逆向破解出的难度不同 【整理】iOS逆向破解越狱开发：相关工具 iOS安全对应的逆向破解对策 针对iOS安全的防护手段，目前能想到的，iOS逆向破解的办法： iOS的代码混淆 被反编译后，也只能看到 乱码的函数 部分防止被破解，被猜测到核心逻辑 iOS的加壳？ 没法加壳 但是也可以去研究看看，是否有机会 iOS代码运行期间，动态下载要运行的核心代码（二进制格式？） 增加核心逻辑的安全性 好像涉及到虚拟机之类的 注：对应的iOS逆向，则是：unicorn等 模拟器 虚拟机，模拟运行对应的指令 iOS的抓包方面的：加https证书验证？ ssl pinning？ 甚至（参考抖音的做法）去本地ssl证书验证 只有破解hook后，才能Charles抓包看到https明文 后记：[原创]绕过抖音SSL Pinning-iOS安全-看雪论坛-安全社区|安全招聘|bbs.pediy.com 1.加入自己的证书2.干掉所有的证书3.不让他验证证书。很显然，你用的是第二种 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-03-05 22:31:25 "},"iphone/":{"url":"iphone/","title":"iPhone","keywords":"","body":"iPhone crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-02-26 09:38:47 "},"iphone/init_dev_env.html":{"url":"iphone/init_dev_env.html","title":"初始化开发环境","keywords":"","body":"初始化开发环境 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-02-26 09:38:47 "},"iphone/common_folder.html":{"url":"iphone/common_folder.html","title":"常用目录","keywords":"","body":"iPhone中常用目录 iOS逆向期间，常常会涉及到很多目录，且其中有些是有（软链接等）关系的。整理如下： /etc/ == /private/etc/ /var/ == /private/var/ /User/ == /var/mobile/ == /private/var/mobile/ /tmp/ == /private/var/tmp/ -> 举例： Bundle目录 入口=根目录 /private/var/containers/Bundle/Application/ == /var/containers/Bundle/Application/ 附录 根目录下文件目录和内容： iPhone8-143:/ root# pwd / iPhone8-143:/ root# ls -lh total 1.5K drwxrwxr-x 107 root admin 3.4K Dec 25 11:14 Applications/ drwxr-xr-x 7 root wheel 306 Dec 4 2020 Developer/ drwxr-xr-x 25 root wheel 800 Dec 13 10:48 Library/ drwxr-xr-x 4 root wheel 128 Jan 8 2021 System/ lrwxr-xr-x 1 root wheel 11 Dec 13 11:07 User -> /var/mobile/ drwxr-xr-x 61 root wheel 2.0K Dec 13 10:48 bin/ drwxr-xr-x 2 root wheel 64 Oct 28 2006 boot/ drwxrwxr-t 2 root admin 64 Jun 28 2018 cores/ dr-xr-xr-x 4 root wheel 1.4K Dec 13 11:01 dev/ lrwxr-xr-x 1 root wheel 11 Jun 28 2018 etc -> private/etc/ drwxr-xr-x 2 root wheel 64 Oct 28 2006 lib/ drwxr-xr-x 2 root wheel 64 Oct 28 2006 mnt/ drwxr-xr-x 7 root wheel 224 Jan 8 2021 private/ drwxr-xr-x 40 root wheel 1.3K Dec 13 10:48 sbin/ lrwxr-xr-x 1 root wheel 15 Jun 28 2018 tmp -> private/var/tmp/ drwxr-xr-x 12 root wheel 384 Dec 13 10:48 usr/ lrwxr-xr-x 1 root admin 11 Jun 28 2018 var -> private/var/ iPhone8-143:/ root# crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-02-26 09:51:56 "},"ios_app/":{"url":"ios_app/","title":"app","keywords":"","body":"app crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-02-26 09:38:47 "},"ios_app/plist.html":{"url":"ios_app/plist.html","title":"plist文件","keywords":"","body":"plist文件 plist（文件）=Property List=属性列表（文件） 相关 NSUserDefaults | Apple Developer Documentation 位置 举例 WhatsApp的suiteName=group.net.whatsapp.WhatsApp.shared的plist文件位置 /private/var/mobile/Containers/Shared/AppGroup/D70C70AC-D347-4640-9667-1AA86D05CB65/Library/Preferences/group.net.whatsapp.WhatsApp.shared.plist 详见 【未解决】iOS逆向WhatsApp：研究NSUserDefaults底层保存值的地方 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-03 09:38:12 "},"ios_app/related_data_folder/":{"url":"ios_app/related_data_folder/","title":"相关文件目录和数据","keywords":"","body":"app相关文件目录和数据 TODO: 【未解决】iOS逆向WhatsApp：调试IdentityKeypairData调用SecItemAdd写入Keychain数据库的具体逻辑 iOS的app安装后，相关数据和内容： 文件目录 Bundle目录 根目录：/private/var/containers/Bundle/Application/ Data目录 根目录：/private/var/mobile/Containers/Data/Application/ Shared AppGroup目录 根目录：/private/var/mobile/Containers/Shared/AppGroup/ 数据 Keychain数据 Keychain-2.db 位置：/private/var/Keychains/keychain-2.db 相关函数 写入数据：SecItemAdd 更新数据：SecItemUpdate 举例 WhatsApp WhatsApp WhatsApp Bundle目录 /private/var/containers/Bundle/Application/B42F04DD-E264-401B-A72C-C00B240A1E81/ Data目录 /private/var/mobile/Containers/Data/Application/3856AB23-E286-4EE0-B06E-A0519A591AA8/ AppGroup目录 /private/var/mobile/Containers/Shared/AppGroup/D70C70AC-D347-4640-9667-1AA86D05CB65/ 数据 Keychain数据 Keychain-2.db 位置：/private/var/Keychains/keychain-2.db crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-03 12:09:40 "},"ios_app/related_data_folder/bundle.html":{"url":"ios_app/related_data_folder/bundle.html","title":"Bundle","keywords":"","body":"Bundle TODO： 【已解决】越狱iPhone中确定iOS的app的Data目录位置 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-02-26 10:01:06 "},"ios_app/related_data_folder/data.html":{"url":"ios_app/related_data_folder/data.html","title":"Data","keywords":"","body":"Data TODO： 【已解决】越狱iPhone中确定iOS的app的Bundle目录位置 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-02-26 10:01:14 "},"ios_app/related_data_folder/shared_app_group.html":{"url":"ios_app/related_data_folder/shared_app_group.html","title":"Shared AppGroup","keywords":"","body":"Shared AppGroup TODO： 【已解决】越狱iPhone中确定iOS的app的Shared AppGroup目录位置 【记录】iOS函数：NSFileManager的containerURLForSecurityApplicationGroupIdentifier: 【未解决】尝试改变包名去解决container_create_or_lookup_app_group_path_by_app_group_identifier 如何获取Shared AppGroup的路径 Xcode正向开发 正向的iOS的app开发时，开启了：App Groups 代码-[NSFileManager containerURLForSecurityApplicationGroupIdentifier:] crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-02-26 09:59:32 "},"ios_app/bin_path.html":{"url":"ios_app/bin_path.html","title":"二进制文件路径","keywords":"","body":"二进制文件路径 动态调试iOS的app：核心二进制=主二进制 之前，往往要知道： iOS的主二进制，在iPhone中的完整路径 即：获取iOS的app的主二进制=核心二进制=入口二进制，在iPhone中的完整路径 iOS的app的核心二进制=主二进制=入口二进制 完整路径 /var/containers/Bundle/Application/yyyy/xxx.app/xxx 举例 WhatsApp /var/containers/Bundle/Application/2BE964D4-8DF0-4858-A06D-66CA8741ACDC/WhatsApp.app/WhatsApp 查看方式 查看方式 概述 爱思助手：文件系统（越狱）-》/var/containers/Bundle/Application/ -》能看到解析后的app的名字-》点击进去-》底部会显示路径 CocoaTop：运行app-》查看进程信息-》Command Line lldb命令行：image list -o -f的第一个 详解 方式1：通过爱思助手，查看已安装的app的相关路径 抖音：/private/var/containers/Bundle/Application/74AA2F46-7A02-47F7-A9D7-3E13E22D5471/Aweme.app/Aweme 爱思助手->文件管理->文件系统->文件系统（越狱） 方式2：通过前面的Attach模式调试期间，通过image list -o -f查看得到 举例 WhatsApp：/private/var/containers/Bundle/Application/CCFD22D2-32EE-4F23-9C81-226663100D40/WhatsApp.app/WhatsApp Attach模式调试时可查看到(lldb) image list -o -f [ 0] 0x0000000004c6c000 /private/var/containers/Bundle/Application/CCFD22D2-32EE-4F23-9C81-226663100D40/WhatsApp.app/WhatsApp(0x0000000104c6c000) ... 方式3：（app正在运行时）通过CocoaTop查看进程详情中的Command Line可以看到二进制完整路径 举例 WhatsApp crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-04 11:50:44 "},"ios_app/uninstall/":{"url":"ios_app/uninstall/","title":"app卸载","keywords":"","body":"app卸载 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-03 10:59:02 "},"ios_app/uninstall/residual_data.html":{"url":"ios_app/uninstall/residual_data.html","title":"残留数据","keywords":"","body":"app卸载后仍残留数据 卸载APP的心得： app完全卸载后仍有可能有app相关的数据 除了标准的卸载APP加上数据，额外还有可能有APP相关的数据存在 比如APP group 是同一个公司旗下的多个APP共享的数据 背景 iOS逆向调试期间，尝试模拟app首次初始化过程 而去卸载掉app，且用的是： 删除app，且同时删除数据 具体操作路径是： Settings->General->iPhone Storage->点击对应app->该app详情页：app版本号和数据大小->Delete App 如此，可以彻底删除app，包括app和数据 注： 对比，相比之下，从桌面上，长按app去删除： -》 记得是，好像是：只能删除app本身，无法删除Data数据的 但是后来的经验是： 其实，即使从iPhone Storage中，彻底删除app和data数据后，其实也还是有可能，存在app相关数据的 至少可能有2方面的数据： AppGroup数据 同一家公司（该app的开发者或所属公司）其下的，多个app，所共享的数据（目录） Keychain数据库中的数据 举例 具体举例说明： WhatsApp AppGroup数据 WhatsApp的话，独立于app本身，有个：AppGroup目录： WhatsApp的AppGroup目录 /private/var/mobile/Containers/Shared/AppGroup/8E53137F-C414-4D05-85CD-88E6B16FCA85/ 其下就有很多子目录和文件： ➜ ~ ssh root@192.168.2.6 iPhone7-1331:~ root# uname -a Darwin iPhone7-1331 19.3.0 Darwin Kernel Version 19.3.0: Thu Jan 9 21:10:55 PST 2020; root:xnu-6153.82.3~1/RELEASE_ARM64_T8010 iPhone9,1 arm64 D10AP Darwin iPhone7-1331:~ root# ls -lh /private/var/mobile/Containers/Shared/AppGroup/8E53137F-C414-4D05-85CD-88E6B16FCA85/ total 6.8M drwxr-xr-x 2 mobile mobile 64 Oct 17 14:04 AppState/ -rw-r--r-- 1 mobile mobile 76K Oct 17 08:57 AvatarSearchTags.sqlite -rw-r--r-- 1 mobile mobile 336K Oct 19 16:33 Axolotl.sqlite -rw-r--r-- 1 mobile mobile 32K Nov 23 14:01 Axolotl.sqlite-shm -rw-r--r-- 1 mobile mobile 0 Nov 23 10:17 Axolotl.sqlite-wal -rw-r--r-- 1 mobile mobile 36K Oct 19 10:10 BackedUpKeyValue.sqlite -rw-r--r-- 1 mobile mobile 32K Oct 19 10:10 BackedUpKeyValue.sqlite-shm -rw-r--r-- 1 mobile mobile 0 Oct 19 10:15 BackedUpKeyValue.sqlite-wal drwxr-xr-x 5 mobile mobile 160 Nov 22 22:04 Biz/ -rw-r--r-- 1 mobile mobile 88K Oct 19 10:05 CallHistory.sqlite -rw-r--r-- 1 mobile mobile 32K Oct 19 10:10 CallHistory.sqlite-shm -rw-r--r-- 1 mobile mobile 0 Oct 19 10:15 CallHistory.sqlite-wal -rw-r--r-- 1 mobile mobile 336K Oct 19 10:15 ChatStorage.sqlite -rw-r--r-- 1 mobile mobile 32K Oct 19 10:10 ChatStorage.sqlite-shm -rw-r--r-- 1 mobile mobile 0 Oct 19 10:15 ChatStorage.sqlite-wal -rw-r--r-- 1 mobile mobile 60K Nov 22 22:04 ContactsV2.sqlite -rw-r--r-- 1 mobile mobile 32K Nov 23 14:01 ContactsV2.sqlite-shm -rw-r--r-- 1 mobile mobile 0 Nov 23 10:17 ContactsV2.sqlite-wal -rw-r--r-- 1 mobile mobile 52K Oct 17 14:05 DeviceAgents.sqlite -rw-r--r-- 1 mobile mobile 32K Oct 19 10:10 DeviceAgents.sqlite-shm -rw-r--r-- 1 mobile mobile 0 Oct 19 10:15 DeviceAgents.sqlite-wal drwxr-xr-x 3 mobile mobile 96 Oct 13 21:10 FieldStats2/ -rw-r--r-- 1 mobile mobile 68K Oct 17 14:04 LID.sqlite -rw-r--r-- 1 mobile mobile 32K Oct 19 10:10 LID.sqlite-shm -rw-r--r-- 1 mobile mobile 21K Oct 17 15:49 LID.sqlite-wal drwxr-xr-x 4 mobile mobile 128 Oct 13 21:10 Library/ -rw-r--r-- 1 mobile mobile 1.3M Nov 23 10:17 LocalKeyValue.sqlite -rw-r--r-- 1 mobile mobile 32K Nov 23 14:01 LocalKeyValue.sqlite-shm -rw-r--r-- 1 mobile mobile 25K Nov 23 14:01 LocalKeyValue.sqlite-wal -rw-r--r-- 1 mobile mobile 84K Oct 19 10:10 Location.sqlite -rw-r--r-- 1 mobile mobile 32K Nov 23 14:01 Location.sqlite-shm -rw-r--r-- 1 mobile mobile 8.1K Oct 19 10:18 Location.sqlite-wal drwxr-xr-x 4 mobile mobile 128 Oct 19 10:06 Logs/ drwxr-xr-x 3 mobile mobile 96 Oct 16 15:50 Media/ drwxr-xr-x 3 mobile mobile 96 Oct 17 14:05 Message/ -rw-r--r-- 1 mobile mobile 204K Oct 19 10:10 Sticker.sqlite -rw-r--r-- 1 mobile mobile 32K Oct 19 10:10 Sticker.sqlite-shm -rw-r--r-- 1 mobile mobile 0 Oct 19 10:15 Sticker.sqlite-wal -rw-r--r-- 1 mobile mobile 32 Oct 19 10:12 cck.dat -rw-rw-rw- 1 mobile mobile 255 Oct 13 21:10 connection.dlock -rw-r--r-- 1 mobile mobile 0 Oct 13 21:10 connection_setup.dlock -rw-r--r-- 1 mobile mobile 10 Oct 13 21:10 consumer_version -rw-r--r-- 1 mobile mobile 464K Oct 17 14:04 current_wallpaper.jpg -rw-r--r-- 1 mobile mobile 464K Oct 17 14:04 current_wallpaper_dark.jpg -rw-r--r-- 1 mobile mobile 0 Oct 13 21:10 drestore.mark -rw-r--r-- 1 mobile mobile 1.3M Oct 16 15:50 emoji.sqlite drwxr-xr-x 3 mobile mobile 96 Oct 19 10:12 fts/ -rw-r--r-- 1 mobile mobile 0 Oct 13 21:10 main_app.lock -rw-r--r-- 1 mobile mobile 0 Oct 13 21:10 shared_storage.lock -rw-r--r-- 1 mobile mobile 0 Oct 13 21:10 signal-key-store.lock drwxr-xr-x 3 mobile mobile 96 Oct 17 15:49 stickers/ 爱思助手查看的效果： 包括很多相关数据： 比如之前调试涉及到的： 注册相关参数authKey的最终来源： /private/var/mobile/Containers/Shared/AppGroup/8E53137F-C414-4D05-85CD-88E6B16FCA85/cck.dat iPhone7-1331:~ root# ls -lh /private/var/mobile/Containers/Shared/AppGroup/8E53137F-C414-4D05-85CD-88E6B16FCA85/cck.dat -rw-r--r-- 1 mobile mobile 32 Oct 19 10:12 /private/var/mobile/Containers/Shared/AppGroup/8E53137F-C414-4D05-85CD-88E6B16FCA85/cck.dat 详见： 【记录】iOS逆向WhatsApp：AppGroup中log日志内容 【记录】iOS逆向WhatsApp：导出并研究Shared/AppGroup目录中的内容 【未解决】iOS逆向WhatsApp：-[WAStaticPrivateKeyStore privateKey] Keychain数据库中的数据 之前找WhatsApp中gena==kSecAttrGeneric的值0x45534916的来源是找到最终是： Keychain数据库中，有保存了： WhatsApp的最初写入Keychain数据库中数据： 其中此处genp中就有WhatsApp相关的12条数据记录 其中的 group.net.whatsapp.WhatsApp.shared中的gena的值，就是：0x45534916通过SHA1加密后的数值 总之，是保存有WhatsApp相关数据的。 详见： 【未解决】iOS逆向WhatsApp：Keychain中genp中WhatsApp数据何时和如何被写入的 【未解决】iOS中的keychain保存位置路径 【记录】Mac中用DB Browser for SQLite查看keychain数据库文件：/var/Keychains/keychain-2.db 【已解决】Mac中如何打开iOS中的SQLite3格式的数据库.db文件 【记录】iOS逆向WhatsApp：查找keychain的数据库/var/Keychains/keychain-2.db中WhatsApp相关数据 【整理】iOS逆向：Keychain数据库字段含义 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-03 11:08:45 "},"ios_app/keychain_db/":{"url":"ios_app/keychain_db/","title":"Keychain数据库","keywords":"","body":"Keychain数据库 背景 iOS逆向调试，后来遇到了：Keychain数据库 去整理相关内容 Keychain数据库 Keychain数据库 Keychain=中文：钥匙链 是什么：Apple中（iOS/Mac）用来保存加密等相关安全方面的数据的 iOS中的Keychain数据库 位置：/var/Keychains/keychain-2.db 内部格式：SQLite3 如何打开： Mac中的工具：DB Browser for SQLite 效果 读写Keychain数据库的相关函数 写入 SecItemAdd SecItemAdd | Apple Developer Documentation 读取 SecItemCopyMatching SecItemCopyMatching | Apple Developer Documentation 更新 SecItemUpdate SecItemUpdate | Apple Developer Documentation 删除 SecItemDelete SecItemDelete | Apple Developer Documentation 相关文档 Keychain items | Apple Developer Documentation Item class keys and values | Apple Developer Documentation Keychain services | Apple Developer Documentation Using the keychain to manage user secrets | Apple Developer Documentation TN3137: On Mac keychain APIs and implementations | Apple Developer Documentation 举例 WhatsApp Keychain读写相关 WhatsApp中，就有很多代码，与Keychain读写相关： 【未解决】iOS逆向WhatsApp：-[WASignalCoordinator regenerateKeyStore] 【未解决】iOS逆向WhatsApp：-[WASignalKeyStore saveToKeychainIdentityKeypairData:registrationIdData:] 保存写入IdentityKeypairData、registrationIdData等值到Keychain数据库 其中会调用到SecItemAdd、SecItemUpdate等函数int __cdecl -[WASignalKeyStore saveToKeychainIdentityKeypairData:registrationIdData:]( WASignalKeyStore *self, SEL a2, id inputIdentityKeypairData, id inputRegistrationIdData) { ... if ( SecItemAdd_2494(baseKeychainQueryToAdd, addResult) ) { ... saveResult = SecItemUpdate(newDictToAdd, addResult1); ... SecItem相关代码输入和输出结果 【未解决】iOS逆向WhatsApp：-[WASignalKeyStore fetchFromKeychainIdentityKeypairData:registrationIdData:] 中： 代码： IDA伪代码： queryRet1 = SecItemCopyMatching_24A0((CFDictionaryRef)baseKeychainQuery2, result); Xcode汇编代码： 0x10ba8d3cc : bl 0x10bb064a0 ; symbol stub for: SecItemCopyMatching 0x10ba8d3d0 : mov x28, x0 此时输入参数： (lldb) reg r x0 x1 x0 = 0x00000002816ee300 x1 = 0x000000016b2da558 (lldb) po 0x00000002816ee300 { acct = Axolotl; agrp = \"group.net.whatsapp.WhatsApp.shared\"; class = genp; \"r_Attributes\" = 1; svce = Axolotl; } (lldb) x/2gx 0x000000016b2da558 0x16b2da558: 0x0000000000000000 0x00000002827ddd70 相关字段含义解释： 要去获取的Class类是：kSecClassGenericPassword 获取其中的属性 kSecAttrService kSecAttrAccount kSecAttrAccessGroup -》 class = genp class = 要访问的类 值：genp=GENeric Password = kSecClassGenericPassword 访问该类的这3个属性 acct = Axolotl; acct = ACCounT = kSecAttrAccount 值：Axolotl agrp = \"group.net.whatsapp.WhatsApp.shared\" agrp = Acces GRouP = kSecAttrAccessGroup 值：group.net.whatsapp.WhatsApp.shared svce = Axolotl svce=SerViCE = kSecAttrService 值：Axolotl 后续新增的： \"r_Attributes\" = 1; 返回属性值 = dict字典 \"r_Data\" = 1; 返回Data数据=NSData 运行后，输出结果： (lldb) reg r x0 x0 = 0x0000000000000000 (lldb) x/2gx 0x000000016b2da558 0x16b2da558: 0x00000002803a1800 0x00000002827ddd70 (lldb) po 0x00000002803a1800 { accc = \"\"; acct = Axolotl; agrp = \"group.net.whatsapp.WhatsApp.shared\"; cdat = \"2023-10-19 03:12:17 +0000\"; gena = {length = 4, bytes = 0x45534916}; mdat = \"2023-10-19 03:12:17 +0000\"; musr = {length = 0, bytes = 0x}; pdmn = cku; persistref = {length = 0, bytes = 0x}; sha1 = {length = 20, bytes = 0xf77dab924958c4e14725ca4be09ee78d1a1e48c3}; svce = Axolotl; sync = 0; tomb = 0; } 其中：之前我们所要找的数据就是： gena = {length = 4, bytes = 0x45534916}; 中的： 16进制：的0x45534916 == 10进制的：1163086102 对应Keychain数据中genp表中gena的值： 保存的值，不是明文，而是SHA1加密后的值 附录 /var/Keychains目录中的内容 /var/Keychains目录中的内容 ssh命令行查看效果iPhone7-1331:/var/Keychains root# ls -lh total 45M drwxrwxr-x 29 _securityd wheel 928 Aug 22 2022 Analytics/ -rw------- 1 _securityd wheel 2 Nov 23 08:08 SOSAccountSettings.pb drwx--x--x 6 _securityd wheel 192 Nov 28 09:27 SupplementalsAssets/ -rw------- 1 _securityd wheel 24K Oct 17 08:25 TrustStore.sqlite3 -rw------- 1 _securityd wheel 28K Oct 13 04:51 caissuercache.sqlite3 -rw------- 1 _securityd wheel 0 Jan 23 2022 com.apple.security.exception_reset_counter.plist -rw-r--r-- 1 root wheel 80K Aug 17 2022 com.apple.security.keychain-defaultContext.TrustedPeersHelper.db -rw-r--r-- 1 root wheel 32K Nov 21 10:21 com.apple.security.keychain-defaultContext.TrustedPeersHelper.db-shm -rw-r--r-- 1 root wheel 2.6M Nov 27 22:21 com.apple.security.keychain-defaultContext.TrustedPeersHelper.db-wal drwx--x--x 5 _securityd wheel 160 Nov 28 12:07 crls/ -rw------- 1 root wheel 17M Nov 28 10:51 keychain-2.db -rw------- 1 _securityd wheel 32K Nov 21 10:21 keychain-2.db-shm -rw------- 1 _securityd wheel 1.1M Nov 28 10:54 keychain-2.db-wal -rw------- 1 _securityd wheel 17M Nov 28 08:19 keychain-2.db_orig -r-------- 1 root wheel 1.2M Nov 27 13:44 keychain-ota-backup.plist -rw------- 1 _securityd wheel 116K Nov 21 21:04 ocspcache.sqlite3 -rw------- 1 _securityd wheel 32K Nov 21 10:21 ocspcache.sqlite3-shm -rw------- 1 _securityd wheel 2.2M Nov 28 11:48 ocspcache.sqlite3-wal -rw------- 1 _securityd wheel 272K Oct 10 21:16 pinningrules.sqlite3 爱思助手查看效果 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-03 11:29:49 "},"ios_app/keychain_db/field_def.html":{"url":"ios_app/keychain_db/field_def.html","title":"字段含义","keywords":"","body":"Keychain数据库字段含义 概述： SecItemConstants.c (apple.com) SEC_CONST_DECL (kSecAttrGeneric, \"gena\"); Useful resources for working with iOS/ macOS Keychain API (github.com) pdmn = Protection Domain ck = kSecAttrAccessibleAfterFirstUnlock cku = kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly ak = kSecAttrAccessibleWhenUnlocked aku = kSecAttrAccessibleWhenUnlockedThisDeviceOnly 几个表 genp = kSecClassGenericPassword inet = kSecClassInternetPassword cert = kSecClassCertificate key = kSecClassKey 详解： SecItemConstants.c (apple.com) /* String constant declarations */ #define SEC_CONST_DECL(k,v) CFTypeRef k = (CFTypeRef)(CFSTR(v)); /* Class Key Constant */ SEC_CONST_DECL (kSecClass, \"class\"); /* Class Value Constants */ SEC_CONST_DECL (kSecClassGenericPassword, \"genp\"); SEC_CONST_DECL (kSecClassInternetPassword, \"inet\"); SEC_CONST_DECL (kSecClassAppleSharePassword, \"apls\"); SEC_CONST_DECL (kSecClassCertificate, \"cert\"); SEC_CONST_DECL (kSecClassKey, \"keys\"); SEC_CONST_DECL (kSecClassIdentity, \"idnt\"); /* Attribute Key Constants */ SEC_CONST_DECL (kSecAttrAccessible, \"pdmn\"); SEC_CONST_DECL (kSecAttrAccessGroup, \"agrp\"); SEC_CONST_DECL (kSecAttrCreationDate, \"cdat\"); SEC_CONST_DECL (kSecAttrModificationDate, \"mdat\"); SEC_CONST_DECL (kSecAttrDescription, \"desc\"); SEC_CONST_DECL (kSecAttrComment, \"icmt\"); SEC_CONST_DECL (kSecAttrCreator, \"crtr\"); SEC_CONST_DECL (kSecAttrType, \"type\"); SEC_CONST_DECL (kSecAttrLabel, \"labl\"); SEC_CONST_DECL (kSecAttrIsInvisible, \"invi\"); SEC_CONST_DECL (kSecAttrIsNegative, \"nega\"); SEC_CONST_DECL (kSecAttrAccount, \"acct\"); SEC_CONST_DECL (kSecAttrService, \"svce\"); SEC_CONST_DECL (kSecAttrGeneric, \"gena\"); SEC_CONST_DECL (kSecAttrSecurityDomain, \"sdmn\"); SEC_CONST_DECL (kSecAttrServer, \"srvr\"); SEC_CONST_DECL (kSecAttrProtocol, \"ptcl\"); SEC_CONST_DECL (kSecAttrAuthenticationType, \"atyp\"); SEC_CONST_DECL (kSecAttrPort, \"port\"); SEC_CONST_DECL (kSecAttrPath, \"path\"); SEC_CONST_DECL (kSecAttrVolume, \"volm\"); SEC_CONST_DECL (kSecAttrAddress, \"addr\"); SEC_CONST_DECL (kSecAttrAFPServerSignature, \"afps\"); SEC_CONST_DECL (kSecAttrAlias, \"alis\"); SEC_CONST_DECL (kSecAttrSubject, \"subj\"); SEC_CONST_DECL (kSecAttrIssuer, \"issr\"); SEC_CONST_DECL (kSecAttrSerialNumber, \"slnr\"); SEC_CONST_DECL (kSecAttrSubjectKeyID, \"skid\"); SEC_CONST_DECL (kSecAttrPublicKeyHash, \"pkhh\"); SEC_CONST_DECL (kSecAttrCertificateType, \"ctyp\"); SEC_CONST_DECL (kSecAttrCertificateEncoding, \"cenc\"); SEC_CONST_DECL (kSecAttrKeyClass, \"kcls\"); SEC_CONST_DECL (kSecAttrApplicationLabel, \"klbl\"); SEC_CONST_DECL (kSecAttrIsPermanent, \"perm\"); SEC_CONST_DECL (kSecAttrIsPrivate, \"priv\"); SEC_CONST_DECL (kSecAttrIsModifiable, \"modi\"); SEC_CONST_DECL (kSecAttrApplicationTag, \"atag\"); SEC_CONST_DECL (kSecAttrKeyCreator, \"crtr\"); SEC_CONST_DECL (kSecAttrKeyType, \"type\"); SEC_CONST_DECL (kSecAttrKeySizeInBits, \"bsiz\"); SEC_CONST_DECL (kSecAttrEffectiveKeySize, \"esiz\"); SEC_CONST_DECL (kSecAttrStartDate, \"sdat\"); SEC_CONST_DECL (kSecAttrEndDate, \"edat\"); SEC_CONST_DECL (kSecAttrIsSensitive, \"sens\"); SEC_CONST_DECL (kSecAttrWasAlwaysSensitive, \"asen\"); SEC_CONST_DECL (kSecAttrIsExtractable, \"extr\"); SEC_CONST_DECL (kSecAttrWasNeverExtractable, \"next\"); SEC_CONST_DECL (kSecAttrCanEncrypt, \"encr\"); SEC_CONST_DECL (kSecAttrCanDecrypt, \"decr\"); SEC_CONST_DECL (kSecAttrCanDerive, \"drve\"); SEC_CONST_DECL (kSecAttrCanSign, \"sign\"); SEC_CONST_DECL (kSecAttrCanVerify, \"vrfy\"); SEC_CONST_DECL (kSecAttrCanSignRecover, \"snrc\"); SEC_CONST_DECL (kSecAttrCanVerifyRecover, \"vyrc\"); SEC_CONST_DECL (kSecAttrCanWrap, \"wrap\"); SEC_CONST_DECL (kSecAttrCanUnwrap, \"unwp\"); /* Attribute Constants (Private) */ SEC_CONST_DECL (kSecAttrScriptCode, \"scrp\"); SEC_CONST_DECL (kSecAttrHasCustomIcon, \"cusi\"); SEC_CONST_DECL (kSecAttrCRLType, \"crlt\"); SEC_CONST_DECL (kSecAttrCRLEncoding, \"crle\"); SEC_CONST_DECL (kSecAttrSynchronizable, \"sync\"); SEC_CONST_DECL (kSecAttrSynchronizableAny, \"syna\"); SEC_CONST_DECL (kSecAttrTombstone, \"tomb\"); /* Search Constants */ SEC_CONST_DECL (kSecMatchPolicy, \"m_Policy\"); SEC_CONST_DECL (kSecMatchItemList, \"m_ItemList\"); SEC_CONST_DECL (kSecMatchSearchList, \"m_SearchList\"); SEC_CONST_DECL (kSecMatchIssuers, \"m_Issuers\"); SEC_CONST_DECL (kSecMatchEmailAddressIfPresent, \"m_EmailAddressIfPresent\"); SEC_CONST_DECL (kSecMatchSubjectContains, \"m_SubjectContains\"); SEC_CONST_DECL (kSecMatchCaseInsensitive, \"m_CaseInsensitive\"); SEC_CONST_DECL (kSecMatchTrustedOnly, \"m_TrustedOnly\"); SEC_CONST_DECL (kSecMatchValidOnDate, \"m_ValidOnDate\"); SEC_CONST_DECL (kSecMatchLimit, \"m_Limit\"); /* Could just use kCFBooleanTrue and kCFBooleanFalse for these 2. */ SEC_CONST_DECL (kSecMatchLimitOne, \"m_LimitOne\"); SEC_CONST_DECL (kSecMatchLimitAll, \"m_LimitAll\"); /* Return Type Key Constants */ SEC_CONST_DECL (kSecReturnData, \"r_Data\"); SEC_CONST_DECL (kSecReturnAttributes, \"r_Attributes\"); SEC_CONST_DECL (kSecReturnRef, \"r_Ref\"); SEC_CONST_DECL (kSecReturnPersistentRef, \"r_PersistentRef\"); /* Value Type Key Constants */ SEC_CONST_DECL (kSecValueData, \"v_Data\"); SEC_CONST_DECL (kSecValueRef, \"v_Ref\"); SEC_CONST_DECL (kSecValuePersistentRef, \"v_PersistentRef\"); /* Other Constants */ SEC_CONST_DECL (kSecUseItemList, \"u_ItemList\"); SEC_CONST_DECL (kSecUseTombstones, \"u_Tomb\"); #if defined(MULTIPLE_KEYCHAINS) /* Other Constants (Private) */ SEC_CONST_DECL (kSecUseKeychain, \"u_Keychain\"); SEC_CONST_DECL (kSecUseKeychainList, \"u_KeychainList\"); #endif /* !defined(MULTIPLE_KEYCHAINS) */ /* kSecAttrAccessible Value Constants. */ SEC_CONST_DECL (kSecAttrAccessibleWhenUnlocked, \"ak\"); SEC_CONST_DECL (kSecAttrAccessibleAfterFirstUnlock, \"ck\"); SEC_CONST_DECL (kSecAttrAccessibleAlways, \"dk\"); SEC_CONST_DECL (kSecAttrAccessibleWhenUnlockedThisDeviceOnly, \"aku\"); SEC_CONST_DECL (kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly, \"cku\"); SEC_CONST_DECL (kSecAttrAccessibleAlwaysThisDeviceOnly, \"dku\"); /* kSecAttrProtocol Value Constants. */ SEC_CONST_DECL (kSecAttrProtocolFTP, \"ftp \"); SEC_CONST_DECL (kSecAttrProtocolFTPAccount, \"ftpa\"); SEC_CONST_DECL (kSecAttrProtocolHTTP, \"http\"); SEC_CONST_DECL (kSecAttrProtocolIRC, \"irc \"); SEC_CONST_DECL (kSecAttrProtocolNNTP, \"nntp\"); SEC_CONST_DECL (kSecAttrProtocolPOP3, \"pop3\"); SEC_CONST_DECL (kSecAttrProtocolSMTP, \"smtp\"); SEC_CONST_DECL (kSecAttrProtocolSOCKS, \"sox \"); SEC_CONST_DECL (kSecAttrProtocolIMAP, \"imap\"); SEC_CONST_DECL (kSecAttrProtocolLDAP, \"ldap\"); SEC_CONST_DECL (kSecAttrProtocolAppleTalk, \"atlk\"); SEC_CONST_DECL (kSecAttrProtocolAFP, \"afp \"); SEC_CONST_DECL (kSecAttrProtocolTelnet, \"teln\"); SEC_CONST_DECL (kSecAttrProtocolSSH, \"ssh \"); SEC_CONST_DECL (kSecAttrProtocolFTPS, \"ftps\"); SEC_CONST_DECL (kSecAttrProtocolHTTPS, \"htps\"); SEC_CONST_DECL (kSecAttrProtocolHTTPProxy, \"htpx\"); SEC_CONST_DECL (kSecAttrProtocolHTTPSProxy, \"htsx\"); SEC_CONST_DECL (kSecAttrProtocolFTPProxy, \"ftpx\"); SEC_CONST_DECL (kSecAttrProtocolSMB, \"smb \"); SEC_CONST_DECL (kSecAttrProtocolRTSP, \"rtsp\"); SEC_CONST_DECL (kSecAttrProtocolRTSPProxy, \"rtsx\"); SEC_CONST_DECL (kSecAttrProtocolDAAP, \"daap\"); SEC_CONST_DECL (kSecAttrProtocolEPPC, \"eppc\"); SEC_CONST_DECL (kSecAttrProtocolIPP, \"ipp \"); SEC_CONST_DECL (kSecAttrProtocolNNTPS, \"ntps\"); SEC_CONST_DECL (kSecAttrProtocolLDAPS, \"ldps\"); SEC_CONST_DECL (kSecAttrProtocolTelnetS, \"tels\"); SEC_CONST_DECL (kSecAttrProtocolIMAPS, \"imps\"); SEC_CONST_DECL (kSecAttrProtocolIRCS, \"ircs\"); SEC_CONST_DECL (kSecAttrProtocolPOP3S, \"pops\"); /* kSecAttrAuthenticationType Value Constants. */ SEC_CONST_DECL (kSecAttrAuthenticationTypeNTLM, \"ntlm\"); SEC_CONST_DECL (kSecAttrAuthenticationTypeMSN, \"msna\"); SEC_CONST_DECL (kSecAttrAuthenticationTypeDPA, \"dpaa\"); SEC_CONST_DECL (kSecAttrAuthenticationTypeRPA, \"rpaa\"); SEC_CONST_DECL (kSecAttrAuthenticationTypeHTTPBasic, \"http\"); SEC_CONST_DECL (kSecAttrAuthenticationTypeHTTPDigest, \"httd\"); SEC_CONST_DECL (kSecAttrAuthenticationTypeHTMLForm, \"form\"); SEC_CONST_DECL (kSecAttrAuthenticationTypeDefault, \"dflt\"); /* kSecAttrKeyClass Value Constants. Based on CSSM_KEYCLASS_PUBLIC_KEY = 0, CSSM_KEYCLASS_PRIVATE_KEY = 1, CSSM_KEYCLASS_SESSION_KEY = 2, */ SEC_CONST_DECL (kSecAttrKeyClassPublic, \"0\"); SEC_CONST_DECL (kSecAttrKeyClassPrivate, \"1\"); SEC_CONST_DECL (kSecAttrKeyClassSymmetric, \"2\"); /* kSecAttrKeyType Value Constants. Based on CSSM_ALGORITHMS. */ SEC_CONST_DECL (kSecAttrKeyTypeRSA, \"42\"); SEC_CONST_DECL (kSecAttrKeyTypeEC, \"73\"); /* rdar://10755886 */ /* Constants used by SecKeyGeneratePair() - in SecKey.h. Never used in any SecItem apis directly. */ SEC_CONST_DECL (kSecPrivateKeyAttrs, \"private\"); SEC_CONST_DECL (kSecPublicKeyAttrs, \"public\"); /* Constants used by SecPassword - in SecPasswordStrength */ SEC_CONST_DECL (kSecPasswordMaxLength, \"PasswordMaxLength\"); SEC_CONST_DECL (kSecPasswordMinLength, \"PasswordMaxLength\"); SEC_CONST_DECL (kSecPasswordAllowedCharacters, \"PasswordAllowedCharacters\"); SEC_CONST_DECL (kSecPasswordRequiredCharacters, \"PasswordRequiredCharacters\"); -> SEC_CONST_DECL (kSecAttrGeneric, \"gena\"); Useful resources for working with iOS/ macOS Keychain API (github.com) kSecAttrAccessible Mapping SecItem.h (apple.com) -> pdmn = Protection Domain ck = kSecAttrAccessibleAfterFirstUnlock cku = kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly ak = kSecAttrAccessibleWhenUnlocked aku = kSecAttrAccessibleWhenUnlockedThisDeviceOnly 和： Database (keychain-2.db) Structure In the iOS keychain, all the keychain items are stored in 4 tables genp = kSecClassGenericPassword inet = kSecClassInternetPassword cert = kSecClassCertificate key = kSecClassKey kSecClassIdentity = kSecClassCertificate + kSecClassKey Keychain tables column names mapped to the corresponding keychain item class attributes cdat kSecAttrCreationDate Item creation date in Unix epoch time format mdat kSecAttrModificationDate Item modification date in Unix epoch time format desc kSecAttrDescription User visible string that describes the item icmt kSecAttrComment User editable comment for the item crtr kSecAttrCreator Application created (4 char) code type kSecAttrType Item type scrp kSecAttrScriptCode String script code (such as encoding type) labl kSecAttrLabel Label to be displayed to the user (print name) alis kSecAttrAlias Item alias invi kSecAttrIsInvisible Invisible nega kSecAttrIsNegative Invalid item cusi kSecAttrHasCustomIcon Existence of application specific icon (Boolean) prot kSecProtectedDataItemAttr ? Item’s data is protected (Boolean) acct kSecAttrAccount Account key (such as user id) svce kSecAttrService Service name (such as Application identifier) gena kSecAttrGeneric User defined attribute data kSecValueData Actual data (such as password, crypto key…) agrp kSecAttrAccessGroup Keychain access group pdmn kSecAttrAccessible Access restrictions (Data protection classes) crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-03 11:33:49 "},"ios_objc/":{"url":"ios_objc/","title":"ObjC","keywords":"","body":"ObjC crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-02-26 09:38:47 "},"ios_objc/runtime/":{"url":"ios_objc/runtime/","title":"运行时","keywords":"","body":"运行时 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-02-26 09:38:47 "},"ios_objc/runtime/objc_msgsend/":{"url":"ios_objc/runtime/objc_msgsend/","title":"objc_msgSend","keywords":"","body":"objc_msgSend crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-27 09:50:14 "},"ios_objc/runtime/objc_msgsend/manual_calc_arg.html":{"url":"ios_objc/runtime/objc_msgsend/manual_calc_arg.html","title":"手动计算参数","keywords":"","body":"手动计算参数 此处，对于iOS逆向中，常见的： 内存中的字符串=objc_msgSend函数的第二个参数=SEL=selector=汇编中的x1寄存器 此处如果是adrp的话，可以用如下手动方式计算出来 即： 根据adrp，手动计算出当前的： char* = 字符串 = objc_msgSend的SEL=函数名 举例说明： 对于： 0x1820ba250 : adrp x8, 302695 0x1820ba254 : add x1, x8, #0x99 ; =0x99 0x1820ba258 : bl 0x1815b9dc8 ; symbol stub for: objc_msgSend ... 0x1820ba28c : adrp x8, 304011 0x1820ba290 : add x1, x8, #0xc61 ; =0xc61 ... 0x1820ba298 : bl 0x1815b9dc8 ; symbol stub for: objc_msgSend 其中的： 0x1820ba28c : adrp x8, 304011 -》 当前PC地址 = adrp指令所在地址 = 0x1820ba28c PC地址去4KB对齐 = PC低12位清零： 0x1820ba28c 低12位清零=16进制最低3位设置为0 -》 0x1820ba000 立即数左移12位： 304011 = 0x4A38B 左移12位=16进制最低位加3个0 -》 0x4A38B000 两者相加 = PC被4KB对齐后的地址 + 立即数左移12位后的值 0x1820ba000 + 0x4A38B000 = 0x1CC445000 x8 = 0x1CC445000 0x1820ba290 : add x1, x8, #0xc61 ; =0xc61 -》 x1 = x8 + 0xc61 = 0x1CC445000 + 0xc61 = 0x1CC445C61 对应内存中的字符串的值： (lldb) po (char*)0x1CC445C61 \"_initWithCFURLRequest:\" crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-27 10:00:31 "},"ios_objc/runtime/objc_alloc.html":{"url":"ios_objc/runtime/objc_alloc.html","title":"objc_alloc","keywords":"","body":"objc_alloc 心得：iOS的ObjC：alloc分配后的=新建的空的类：描述为空 IDA伪代码： newWASignedPrekey = objc_alloc_3808((Class)&OBJC_CLASS___WASignedPrekey); Xcode汇编代码： 0x10a6b89e4 : bl 0x10a73b808 ; symbol stub for: objc_alloc_3808 运行后，返回值： (lldb) reg r x0 x0 = 0x0000000280a23400 (lldb) po $x0 即： alloc空的类，po返回空的描述信息 不过，是可以通过class查看具体是什么类的： (lldb) po [$x0 class] WASignedPrekey 符合我们的期望。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-03 09:40:38 "},"ios_objc/class/":{"url":"ios_objc/class/","title":"Class","keywords":"","body":"Class crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-02-26 09:38:47 "},"ios_objc/class/print_detail.html":{"url":"ios_objc/class/print_detail.html","title":"打印类的描述详情信息","keywords":"","body":"打印类的描述详情信息 Xcode调试期间：打印ObjC类的描述详情信息 已知的传统手段：Xcode/lldb中，po加上对应命令_ivarDescription、_propertyDescription、_methodDescription、shortMethodDescriptionpo [xxx _ivarDescription] po [xxx _propertyDescription] po [xxx _methodDescription] po [xxx _shortMethodDescription] 新的手段：tweak插件的hook代码中，调用对应命令 _ivarDescription、_propertyDescription、_methodDescription、shortMethodDescription [classObj _ivarDescription] [classObj _propertyDescription] [classObj _methodDescription] [classObj _shortMethodDescription] 相关完整代码 dynamicDebug/iOSOpenDev/jailAppleAccount/jailAppleAccount/libs/iOS/HookLogiOS.m // write string to file void writeStrToFile(char* filePath, char* outputStr){ FILE *fp = fopen(filePath, \"w\"); printf(\"fp=%p\", fp); if(fp != NULL){ fprintf(fp, \"%s\", outputStr); fclose(fp); } else { printf(\"Failed to open file %s\", filePath); } } // write class description string into file void dbgWriteClsDescToFile(char* className, id classObj){ NSString* idNSStr = [classObj _ivarDescription]; NSString* pdNSStr = [classObj _propertyDescription]; NSString* mdNSStr = [classObj _methodDescription]; NSString* smdNSStr = [classObj _shortMethodDescription]; const char *idCStr = [idNSStr cStringUsingEncoding:NSUTF8StringEncoding]; const char *pdCStr = [pdNSStr cStringUsingEncoding:NSUTF8StringEncoding]; const char *mdCStr = [mdNSStr cStringUsingEncoding:NSUTF8StringEncoding]; const char *smdCStr = [smdNSStr cStringUsingEncoding:NSUTF8StringEncoding]; // const char* smdOutputFile = \"/var/root/dev/AADeviceInfo_shortMethodDescription.txt\"; // const char* smdOutputFile = \"/var/mobile/AADeviceInfo_shortMethodDescription.txt\"; // const char* outputFilePath = \"/var/root/dev\"; // failed for no write access const char* outputFilePath = \"/var/mobile\"; // iosLogInfo(\"outputFilePath=%{public}s\", outputFilePath); // const char* idOutputFile = \"AADeviceInfo_ivarDescription.txt\"; // const char* pdOutputFile = \"AADeviceInfo_propertyDescription.txt\"; // const char* mdOutputFile = \"AADeviceInfo_methodDescription.txt\"; // const char* smdOutputFile = \"AADeviceInfo_shortMethodDescription.txt\"; char idFullPath[200]; char pdFullPath[200]; char mdFullPath[200]; char smdFullPath[200]; // snprintf(idFullPath, sizeof(idFullPath), \"%s/%s\", outputFilePath, idOutputFile); // snprintf(pdFullPath, sizeof(pdFullPath), \"%s/%s\", outputFilePath, pdOutputFile); // snprintf(mdFullPath, sizeof(mdFullPath), \"%s/%s\", outputFilePath, mdOutputFile); // snprintf(smdFullPath, sizeof(smdFullPath), \"%s/%s\", outputFilePath, smdOutputFile); snprintf(idFullPath, sizeof(idFullPath), \"%s/%s_ivarDescription.txt\", outputFilePath, className); snprintf(pdFullPath, sizeof(pdFullPath), \"%s/%s_propertyDescription.txt\", outputFilePath, className); snprintf(mdFullPath, sizeof(mdFullPath), \"%s/%s_methodDescription.txt\", outputFilePath, className); snprintf(smdFullPath, sizeof(smdFullPath), \"%s/%s_shortMethodDescription.txt\", outputFilePath, className); writeStrToFile(idFullPath, (char*)idCStr); writeStrToFile(pdFullPath, (char*)pdCStr); writeStrToFile(mdFullPath, (char*)mdCStr); writeStrToFile(smdFullPath, (char*)smdCStr); // iosLogInfo(\"Written %s description into %s\", className, outputFilePath); } 调用： dynamicDebug/iOSOpenDev/jailAppleAccount/jailAppleAccount/jailAppleAccount.xm %hook AADeviceInfo - (id)udid{ id objUdid = %orig; iosLogInfo(\"objUdid=%{public}@, self=%{public}@\", objUdid, self); dbgWriteClsDescToFile(\"AADeviceInfo\", self); return objUdid; } %end 注：最新代码详见： HookLogiOS.m crifanLib.c crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-27 11:25:59 "},"ios_objc/class/property/":{"url":"ios_objc/class/property/","title":"成员属性","keywords":"","body":"成员属性 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-05 09:37:39 "},"ios_objc/class/property/public.html":{"url":"ios_objc/class/property/public.html","title":"公开成员属性","keywords":"","body":"公开成员属性 iOS的ObjC的类，中，公开的成员属性，是那种： 比如用反编译出头文件中，类中带@property的哪些成员属性 举例 AppleStore/AuthKit_akd/headers/AKSRPContext.h ... @interface AKSRPContext { struct __AppleIDAuthSupportData *_underlyingContext; NSDictionary *_configurationParameters; } ... @property(readonly, nonatomic) NSDictionary *configurationParameters; // @synthesize configurationParameters=_configurationParameters; @property(readonly, nonatomic) struct __AppleIDAuthSupportData *underlyingContext; // @synthesize underlyingContext=_underlyingContext; @property(readonly, nonatomic) NSDictionary *status; @property(readonly, nonatomic) AKMasterToken *masterToken; @property(readonly, nonatomic) NSDictionary *serverProvidedData; ... -》 AKSRPContext 类，有公开成员属性 configurationParameters underlyingContext status masterToken serverProvidedData 查看公开属性值的方式 想要在iOS逆向期间=Xcode中lldb调试期间 当知道某个变量或地址或指针是某个类时： (lldb) po srpCxt 查看公开属性值，有多种方式： po直接加属性名 (lldb) po [srpCxt configurationParameters] { Password = \"xxxxxx\"; ... u = \"xx@xx.xx\"; } (lldb) po [srpCxt underlyingContext] (lldb) po [srpCxt status] nil (lldb) po [srpCxt masterToken] nil (lldb) po [srpCxt serverProvidedData] nil 通过点=. 此处可以去通过点=.去 读取=引用=查看 公开成员的属性值： 在变量强制转换后，也通过点.去获取属性的值 比如对于上面的公开成员属性：configurationParameters，可以用： (lldb) po ((AKSRPContext*)srpCxt).configurationParameters { Password = \"xxxxxx\"; ... u = \"xx@xx.xx\"; } (lldb) po ((AKSRPContext*)srpCxt).underlyingContext (lldb) po ((AKSRPContext*)srpCxt).status nil (lldb) po ((AKSRPContext*)srpCxt).masterToken nil (lldb) po ((AKSRPContext*)srpCxt).serverProvidedData nil crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-05 09:49:07 "},"ios_objc/class/property/private.html":{"url":"ios_objc/class/property/private.html","title":"私有成员属性","keywords":"","body":"私有成员属性 ObjC的私有成员属性 iOS的ObjC的私有属性，指的是： 大括号{}内部的 属性名往往是以下划线开头的 且外部没有对应的同名的@property的属性 举例 AAURLSession @interface AAURLSession : NSObject { ... NSObject *_sessionQueue; ... } WAPreparedRegistrationURL WhatsApp/headers/WhatsApp_v23.20.79_headers_WhatsApp/WAPreparedRegistrationURL.h #import @class NSArray, NSString, NSURL; @interface WAPreparedRegistrationURL : NSObject { NSString *_baseURLString; NSArray *_params; NSURL *_proxyURL; } - (void).cxx_destruct; - (id)urlWithTokenArray:(id)arg1; - (id)urlWithRegistrationToken:(id)arg1 backupToken:(id)arg2; - (id)initWithBaseURLString:(id)arg1 params:(id)arg2 encryptWithProxyURL:(id)arg3; @end -》 类WAPreparedRegistrationURL的私有属性 _baseURLString _params _proxyURL 访问私有成员属性的方式 下面以WAPreparedRegistrationURL为例，来介绍有多种方式可以查看私有成员属性值： Xcode调试时，有对应的类的实例： (lldb) po 0x0000000282170b80 想要查看： 类的WAPreparedRegistrationURL的私有属性=成员=变量的值 _baseURLString 具体方式： valueForKey 语法：po [objcObj valueForKey: @\"_xxx\"] 属性名不带下划线也可以：po [objcObj valueForKey: @\"xxx\"] 举例 (lldb) po [0x282170b80 valueForKey: @\"_baseURLString\"] https://v.whatsapp.net/v2/exist (lldb) po [0x282170b80 valueForKey: @\"baseURLString\"] https://v.whatsapp.net/v2/exist 指针 语法po ((ClassName*)instanceAddress)->privatePropertyName 举例(lldb) po ((WAPreparedRegistrationURL*)0x282170b80)->_baseURLString https://v.whatsapp.net/v2/exist 偏移量+内存值 == 自己计算指针和内存中的值 (lldb) p/x 0x282170b80 + 0x08 (long) $18 = 0x0000000282170b88 (lldb) x/2gx 0x0000000282170b88 0x282170b88: 0x00000002833bbf80 0x000000028680ed90 (lldb) po 0x00000002833bbf80 https://v.whatsapp.net/v2/exist 其中： 0x282170b80 + 0x08 == ((*WAPreparedRegistrationURL)0x282170b80)->_baseURLString 而内存地址是：0x00000002833bbf80 其中保存的内容，就是：NSString*类型的URL值了 常见错误 用点.去访问：不带下划线，是无法访问的 (lldb) po ((WAPreparedRegistrationURL*)0x282170b80).baseURLString error: expression failed to parse: error: :1:43: property 'baseURLString' not found on object of type 'WAPreparedRegistrationURL *' ((WAPreparedRegistrationURL*)0x282170b80).baseURLString ^ 用点.去访问：带下划线，虽然也可以打印出值的 但其实语法是错误的，但会自动会告诉你正确的语法：用指针->访问 (lldb) po ((WAPreparedRegistrationURL*)0x282170b80)._baseURLString https://v.whatsapp.net/v2/exist Fix-it applied, fixed expression was: ((WAPreparedRegistrationURL*)0x282170b80)->_baseURLString po无法，以ObjC的语法，去直接查看属性名（不论是带下划线还是不带下划线）-》 都会报错 (lldb) po [0x282170b80 baseURLString] error: Execution was interrupted, reason: Attempted to dereference an invalid ObjC Object or send it an unrecognized selector. The process has been returned to the state before expression evaluation. (lldb) po [0x282170b80 _baseURLString] error: Execution was interrupted, reason: Attempted to dereference an invalid ObjC Object or send it an unrecognized selector. The process has been returned to the state before expression evaluation. 用指针访问时，不带下划线的话，会报报语法错误：找不到属性名=成员名=member (lldb) po ((WAPreparedRegistrationURL*)0x282170b80)->baseURLString error: expression failed to parse: error: :1:44: 'WAPreparedRegistrationURL' does not have a member named 'baseURLString' ((WAPreparedRegistrationURL*)0x282170b80)->baseURLString ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^ 即可。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-05 09:38:25 "},"ios_objc/class/expanded_property.html":{"url":"ios_objc/class/expanded_property.html","title":"扩展属性","keywords":"","body":"扩展属性 NSMutableURLRequest 对于iOS中的某些类，比如此处的： NSMutableURLRequest 在Xcode中lldb调试时，po查看类的描述 (lldb) reg r x0 x1 x0 = 0x00000001db04bfe0 (void *)0x00505d81db04c008 x1 = 0x00000001cc774915 (lldb) po 0x00000001db04bfe0 NSMutableURLRequest (lldb) po (char*)0x00000001cc774915 \"ak_clientTimeHeader\" (lldb) po [0x00000001db04bfe0 _shortMethodDescription] : in NSMutableURLRequest: Class Methods: + (int) hashForPlayerID:(id)arg1; (0x982eeb81a8c38638) + (id) _gkHTTPRequestWithURL:(id)arg1 method:(id)arg2 postData:(id)arg3; (0xc811b081a8c38318) + (id) ak_anisetteHeadersWithData:(id)arg1; (0xb535781943bb2e0) + (id) ak_proxiedAnisetteHeadersWithData:(id)arg1; (0xa045d901943e358c) + (id) ak_proxiedClientInfoHeadersWithDevice:(id)arg1; (0x3e20c581943e3724) + (id) ak_clientTimeHeader; (0xb290781943bb584) + (id) ak_localeHeader; (0x1d588101943bb678) + (id) ak_timeZoneHeader; (0x2149a981943c14e4) + (id) ak_clientInfoHeader; (0x126bfa81943e310c) + (id) ak_deviceUDIDHeader; (0x231e5601943e3204) + (id) ak_anisetteHeadersWithCompanionData:(id)arg1; (0xa4016481943e32f8) + (id) ak_proxiedHeadersForDevice:(id)arg1 anisetteData:(id)arg2; (0xc85f8181943e3490) Properties: @property (copy) NSString* HTTPMethod; @property (copy) NSDictionary* allHTTPHeaderFields; ... @property BOOL assumesHTTP3Capable; (@dynamic assumesHTTP3Capable;) @property unsigned long attribution; (@dynamic attribution;) Instance Methods: - (void) setInternal:(BOOL)arg1; (0x32274f81a8c39258) ... - (void) bindToCommand:(struct __CNPluginCommand*)arg1; (0xba0f0781c581b7c0) - (void) _web_setHTTPContentType:(id)arg1; (0xee176781a56b8d34) - (void) _web_setHTTPReferrer:(id)arg1; (0x58445c81a56b8d48) - (void) _web_setHTTPUserAgent:(id)arg1; (0xc61f5601a56b8dc8) - (void) bindToHotspotHelperCommand:(id)arg1; (0x531c418195a851fc) ... - (void) ams_addAuthorizationHeaderForAccount:(id)arg1; (0xfe0abb8185e587b0) - (void) ams_setBodyParameters:(id)arg1 encoding:(long)arg2 compressBody:(BOOL)arg3 error:(id*)arg4; (0x2124cd8185a8f370) - (void) ams_addSilentEnrollmentHeadersForAccount:(id)arg1; (0xf968a28185e589d4) - (void) ak_addDeviceUDIDHeader; (0xa76e8701943e1afc) - (void) ak_addClientTimeHeader; (0x93559101943e1ba8) ... - (void) ak_addPhoneNumberHeader; (0x1d7a0c81943e2e10) ... - (void) ak_addExecutionModeHeader:(BOOL)arg1; (0x4c3d4881943e3a70) - (void) ak_addPrivateEmailKeyHeader:(id)arg1; (0xb10af301943e3ae8) - (void) fam_addiTunesHeadersWithAccount:(id)arg1; (0xe86439818f8477ac) - (void) aa_addBasicAuthPasswordWithAccount:(id)arg1; (0x627c701944c6efc) - (void) aa_addTokenAuthHeaderWithAccount:(id)arg1; (0xff511601944c6d4c) - (void) aa_addDeviceProvisioningInfoHeadersWithDSID:(id)arg1 sendEmptyValues:(BOOL)arg2; (0x7b607b01944c7ce8) ... - (void) aa_addDeviceInternalDevHeaderIfEnabled; (0x2e3ed401944c7e1c) - (void) aa_addDeviceIDHeader; (0xb25bc301944c7ea4) - (void) ic_appendHTTPCookies:(id)arg1; (0xc330c00198eb270c) - (void) ic_appendHTTPCookieWithName:(id)arg1 value:(id)arg2; (0xe4498a8198eb2628) - (void) cdp_addAuthHeaderWithContext:(id)arg1; (0xb6048f01adf4e048) - (void) cdp_addClientInfoHeader; (0x3b77b181adf4e254) - (void) setTimeoutInterval:(double)arg1; (0x9926ad01820970bc) - (void) setAllowsExpensiveNetworkAccess:(BOOL)arg1; (0x950f2281820a0ac8) - (void) setHTTPMethod:(id)arg1; (0xfd389d0182094b08) ... 除了类本身自带的属性和函数 属性 @property (copy) NSString* HTTPMethod; 函数 - (void) setTimeoutInterval:(double)arg1; (0x9926ad01820970bc) 其他还有很多：某类字母开头的属性和函数 ak + (id) ak_clientInfoHeader; (0x126bfa81943e310c) - (void) ak_addPrivateEmailKeyHeader:(id)arg1; (0xb10af301943e3ae8) aa - (void) aa_addDeviceIDHeader; (0xb25bc301944c7ea4) ams - (void) ams_addAuthorizationHeaderForAccount:(id)arg1; (0xfe0abb8185e587b0) 而之前不清楚：为何会有这些额外的属性和函数。 后来找到了： ak相关的属性的来源的头文件： 【未解决】iOS逆向Apple账号：AuthKit的NSMutableURLRequest相关 -》 /Users/crifan/dev/dev_root/iosReverse/AppleStore/iOS_system_lib/AuthKit/headers/NSMutableURLRequest-AuthKit.h // // Generated by classdumpios 1.0.1 (64 bit) (iOS port by DreamDevLost)(Debug version compiled Sep 26 2020 13:48:20). // // Copyright (C) 1997-2019 Steve Nygard. // #import @interface NSMutableURLRequest (AuthKit) ... + (id)ak_anisetteHeadersWithCompanionData:(id)arg1; + (id)ak_anisetteHeadersWithData:(id)arg1; + (id)ak_deviceUDIDHeader; + (id)ak_clientInfoHeader; + (id)ak_timeZoneHeader; + (id)ak_localeHeader; + (id)ak_clientTimeHeader; - (void)ak_addRequestUUIDHeader:(id)arg1; ... - (void)ak_addPhoneNumberCertificateHeaderWithValue:(id)arg1; - (void)ak_addPhoneNumberHeader; - (void)ak_addProxiedDeviceSerialNumberHeader:(id)arg1; ... - (void)ak_addInternalBuildHeader; @end 即： AuthKit 对于 NSMutableURLRequest 做了额外扩展（和继承） 添加了更多的：相关的属性和函数 且命名时，尽量都以ak_开头 对应的库AuthKit的首字母缩写 并且，去头文件中搜： @interface NSMutableURLRequest 又找到更多的： 继承了 = 扩展了：NSMutableURLRequest 的一些类： 4 个结果 - 4 文件 AppleAccount/headers/NSMutableURLRequest-AppleAccount.h: 8 9: @interface NSMutableURLRequest (AppleAccount) 10 - (void)aa_addAppProvidedContext:(id)arg1; AuthKit/headers/NSMutableURLRequest-AuthKit.h: 8 9: @interface NSMutableURLRequest (AuthKit) 10 + (id)ak_proxiedClientInfoHeadersWithDevice:(id)arg1; CFNetwork/headers/NSMutableURLRequest.h: 10 11: @interface NSMutableURLRequest : NSURLRequest 12 { iTunesCloud/headers/NSMutableURLRequest-ICAdditions.h: 8 9: @interface NSMutableURLRequest (ICAdditions) 10 - (void)ic_appendHTTPCookieWithName:(id)arg1 value:(id)arg2; -》 /Users/crifan/dev/dev_root/iosReverse/AppleStore/iOS_system_lib/AppleAccount/headers/NSMutableURLRequest-AppleAccount.h #import @interface NSMutableURLRequest (AppleAccount) - (void)aa_addAppProvidedContext:(id)arg1; ... - (void)aa_addTokenAuthHeaderWithAccount:(id)arg1; @end /Users/crifan/dev/dev_root/iosReverse/AppleStore/iOS_system_lib/CFNetwork/headers/NSMutableURLRequest.h #import @class NSData, NSDictionary, NSInputStream, NSString, NSURL; @interface NSMutableURLRequest : NSURLRequest { } - (void)setBoundInterfaceIdentifier:(id)arg1; @property _Bool allowsCellularAccess; // @dynamic allowsCellularAccess; @property unsigned long long networkServiceType; // @dynamic networkServiceType; - (id)copyWithZone:(struct _NSZone *)arg1; @property _Bool assumesHTTP3Capable; // @dynamic assumesHTTP3Capable; @property _Bool allowsExpensiveNetworkAccess; // @dynamic allowsExpensiveNetworkAccess; @property _Bool allowsConstrainedNetworkAccess; // @dynamic allowsConstrainedNetworkAccess; @property(copy) NSURL *mainDocumentURL; // @dynamic mainDocumentURL; @property double timeoutInterval; // @dynamic timeoutInterval; @property unsigned long long cachePolicy; // @dynamic cachePolicy; @property(copy) NSURL *URL; // @dynamic URL; - (void)setContentDispositionEncodingFallbackArray:(id)arg1; - (void)_setPayloadTransmissionTimeout:(double)arg1; - (void)_setIgnoreHSTS:(_Bool)arg1; - (void)_setPreventHSTSStorage:(_Bool)arg1; - (void)_setRequiresShortConnectionTimeout:(_Bool)arg1; - (void)_setStartTimeoutDate:(id)arg1; - (void)_setTimeWindowDuration:(double)arg1; - (void)_setTimeWindowDelay:(double)arg1; - (void)setExpectedWorkload:(unsigned long long)arg1; @property _Bool HTTPShouldUsePipelining; - (unsigned long long)requestPriority; - (void)setRequestPriority:(unsigned long long)arg1; @property _Bool HTTPShouldHandleCookies; - (void)setHTTPUserAgent:(id)arg1; - (void)setHTTPReferrer:(id)arg1; - (void)setHTTPExtraCookies:(id)arg1; - (void)setHTTPContentType:(id)arg1; @property(retain) NSInputStream *HTTPBodyStream; @property(copy) NSData *HTTPBody; - (void)addValue:(id)arg1 forHTTPHeaderField:(id)arg2; - (void)setValue:(id)arg1 forHTTPHeaderField:(id)arg2; @property(copy) NSDictionary *allHTTPHeaderFields; @property(copy) NSString *HTTPMethod; @end -》看起来是本身的类。 /Users/crifan/dev/dev_root/iosReverse/AppleStore/iOS_system_lib/iTunesCloud/headers/NSMutableURLRequest-ICAdditions.h #import @interface NSMutableURLRequest (ICAdditions) - (void)ic_appendHTTPCookieWithName:(id)arg1 value:(id)arg2; - (void)ic_appendHTTPCookies:(id)arg1; @end 对应着： ic开头的属性和函数 对应的库是：ICAdditions 至此，以后再遇到： iOS其他的类，又有额外的，xx_等开头的内容 就大概能猜出，大概率是继承了iOS原先的类 然后可以去导出的头文件中去找，对应的类了。 且去搜索的字符串的格式，大概可以用： @interface OrignalClassName 或： @interface OrignalClassName ( -》就可以找到继承该类的，其他类了 估计就能看到加了哪些额外的属性和函数了。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-26 23:02:03 "},"ios_objc/class/class_instance_state.html":{"url":"ios_objc/class/class_instance_state.html","title":"类、实例、状态","keywords":"","body":"类、实例、状态 调试期间，类和实例的对比： 概述 普通的类的对象=类的实例是(lldb) reg r x0 x0 = 0x0000000280f603f0 (lldb) po 0x0000000280f603f0 类本身是(lldb) reg r x0 x1 x0 = 0x00000001db187788 (void *)0x002d8581db1877b0 x1 = 0x00000001cc359b7e (lldb) po 0x00000001db187788 UMUserManager 详解 普通的：Instance=实例=对象=Object 典型=多数情况 register read时：后面没有额外备注 举例(lldb) reg r x0 x0 = 0x000000010210eb50 po打印输出：类名加上地址 举例 AAUISignInViewController的实例(lldb) po 0x000000010210eb50 UMUserManager的实例(lldb) po 0x0000000280f603f0 -》对应后续函数调用，ObjC写法是：-开头 举例 -[AAUISignInViewController _setEnabled: 0] 少数=特殊情况 已alloc，但还没init 现象：po打印（内部调用类的description）时，会输出特殊的提示：object was not initialized(lldb) po 0x0000000281e79600 *** -[NSURLComponents description]: object was not initialized 后续会 调用init去初始化 最后才是，已初始化好的，普通的类的实例 po打印出description描述 特殊的：Class=类 register read时：后面会有备注 举例(lldb) reg r x0 x0 = 0x00000001dba36140 (void *)0x00698f81dba36118 po打印输出：只有类名，没有地址 举例(lldb) po 0x00000001dba36140 AAPersonaUtility -》对应后续函数调用，ObjC写法是：+开头 举例 +[AAPersonaUtility verifyAndFixPersonaIfNeeded: desiredContext: ] 举例 已alloc，但还没init的实例 汇编代码: 0x19447a1b0 : adrp x8, 279478 0x19447a1b4 : ldr x0, [x8, #0xfa0] 0x19447a1b8 : bl 0x199f71380 ; objc_alloc -> (lldb) reg r x0 x0 = 0x00000001db033b48 (void *)0x003a0101db033bc0 (lldb) po 0x003a0101db033bc0 16326656130235328 (lldb) po 0x00000001db033b48 NSURLComponents 运行后，返回值： (lldb) reg r x0 x0 = 0x0000000281e79600 (lldb) po 0x0000000281e79600 *** -[NSURLComponents description]: object was not initialized 以及后续会有对应：调用init函数去初始化 0x19447a1bc : adrp x8, 227332 0x19447a1c0 : add x1, x8, #0xcfe ; =0xcfe 0x19447a1c4 : adrp x2, 300159 0x19447a1c8 : add x2, x2, #0x7a0 ; =0x7a0 0x19447a1cc : bl 0x199f6d5c0 ; objc_msgSend -》 (lldb) reg r x0 x1 x2 x0 = 0x0000000281e79600 x1 = 0x00000001cbc7ecfe x2 = 0x00000001dd8f97a0 @\"https://setup.icloud.com\" (lldb) po 0x0000000281e79600 *** -[NSURLComponents description]: object was not initialized (lldb) po (char*)0x00000001cbc7ecfe \"initWithString:\" (lldb) po 0x00000001dd8f97a0 https://setup.icloud.com 即： -[ initWithString: @\"https://setup.icloud.com\"] 返回值=初始化后，就是： 普通的，已初始化好的类，po打印其description描述了： (lldb) reg r x0 x0 = 0x0000000281e79600 (lldb) po 0x0000000281e79600 {scheme = https, user = (null), password = (null), host = setup.icloud.com, port = (null), path = , query = (null), fragment = (null)} crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-27 10:56:18 "},"ios_objc/property/":{"url":"ios_objc/property/","title":"属性值","keywords":"","body":"属性值 ObjC的类，没有函数，但对应父类有该函数 调试到： 0x107b8c808 : bl 0x107c42940 ; objc_msgSend$executeDatabaseFetchRequest:context: 看到参数是： (lldb) reg r x0 x1 x2 x3 x0 = 0x000000010f541210 ... (lldb) po $x0 以为是： -[WASignalKeyStore executeDatabaseFetchRequest:context:] 但是后来发现： -[WASignalKeyStore executeDatabaseFetchRequest:context:] 断点：加不上，加断点失败 转而发现： WASignalKeyStore类，没有这个函数：executeDatabaseFetchRequest:context: 后来才发现：是继承的子类 继承关系是： WASignalKeyStore WAAutoMigratingStorage WACheckpointingStorage WAStorage 而WAStorage：才有函数 - (id)executeDatabaseFetchRequest:(id)arg1 context:(id)arg2 error:(id *)arg3; 所以是： -[WAStorage executeDatabaseFetchRequest:context:] crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-03 09:50:13 "},"ios_objc/property/get_value/":{"url":"ios_objc/property/get_value/","title":"获取变量值","keywords":"","body":"获取变量值 获取变量值 通用的：valueForKey po [someObj valueForKey: @\"keyName\"] 举例po [$x0 valueForKey: @\"v_Data\"] (lldb) po [0x286d8a070 valueForKey: @\"_phoneNumber\"] ({ 1 8784650468 }) (lldb) po [0x112994040 valueForKey: @\"_registrationIdData\"] (lldb) po [0x282170b80 valueForKey: @\"_baseURLString\"] https://v.whatsapp.net/v2/exist 单个类自己的函数=Selector dict objectForKeypo [$x0 objectForKey: @\"v_Data\"] objectForKeyedSubscriptpo [$x0 objectForKeyedSubscript: @\"v_Data\"] crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-03 12:04:33 "},"ios_objc/property/get_value/dict.html":{"url":"ios_objc/property/get_value/dict.html","title":"dict字典","keywords":"","body":"dict字典 lldb中获取ObjC中dict中key的值 此处lldb中，ObjC的（Subscript的）dict： (lldb) po $x0 { ... \"v_Data\" = {length = 69, bytes = 0x0a2105d8 4217d833 e0d21288 0d7b833c ... a57f1bb8 1a416162 }; } 想要获取：key=v_Data的值 方式1：ObjC通用的valueForKey (lldb) po [$x0 valueForKey: @\"v_Data\"] 方式2：（subscript的）dict专门的：objectForKeyedSubscript (lldb) po [$x0 objectForKeyedSubscript: @\"v_Data\"] 详见： objectForKeyedSubscript: | Apple Developer Documentation 方式3：dict通用的：objectForKey (lldb) po [$x0 objectForKey: @\"v_Data\"] crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-03 12:01:31 "},"ios_objc/property/calclulated.html":{"url":"ios_objc/property/calclulated.html","title":"计算类的属性值","keywords":"","body":"计算类的属性值 结论 iOS的ObjC的类 其导出头文件中，不论是否有内部的属性名_xxx和property的属性名xxx 举例 WAContext 内部属性名： WAStaticPrivateKeyStore *_staticPrivateKeyStore; property属性：@property(readonly, nonatomic) WAStaticPrivateKeyStore *staticPrivateKeyStore; WAStaticPrivateKeyStore 内部属性：没有_privateKey property属性：@property(retain, nonatomic) WAEC25519PrivateKey *privateKey; 其都是有可能：是有额外代码处理逻辑的 即：有-[classObj xxx]是个独立函数，其内部有处理逻辑，用于生成对应的值 举例 -[WAStaticPrivateKeyStore privateKey] -[WAContext staticPrivateKeyStore] 即：万一想要研究某个属性值来源的话 可以转去IDA中，搜搜，是否有： -[clasObjc propertyName] 的函数 如果有：则说明是独立函数，内部有处理逻辑 想要找变量值属性值的来源，可能就要研究这个函数了 而不是去从其他地方找，则思路就错了，就会走弯路 背景细节 iOS逆向调试期间，遇到了一个现象： 本来以为的ObjC类的属性，只是获取属性值而已 但是其实内部是有额外的处理逻辑，用于生产对应的属性的值的 举例： 【未解决】iOS逆向WhatsApp：-[WAStaticPrivateKeyStore privateKey] 的： WhatsApp/headers/WhatsApp_v23.20.79_headers_SharedModules/WAStaticPrivateKeyStore.h @interface WAStaticPrivateKeyStore : NSObject { NSString *_filePath; NSString *_containerPath; _Bool _shouldUseKeychain; WAKeychainWrapper *_keychainWrapper; } @property(retain, nonatomic) WAEC25519PrivateKey *privateKey; -》之前以为： WAStaticPrivateKeyStore的privateKey 只是：返回对应的属性值而已 后记： 此处是：没有内部属性叫做：_privateKey的 但是的确有：property属性叫做：privateKey的 @property(retain, nonatomic) WAEC25519PrivateKey *privateKey; -》导致以为之前看到的： WAStaticPrivateKeyStore的实例对象，去获取属性值：privateKey (lldb) po [0x109019e00 staticPrivateKeyStore] (lldb) po [0x280e19f80 privateKey] (lldb) po [0x280208fd0 key] 就只是： 获取了属性值而已 -》导致后续寻找此处的 WAEC25519PrivateKey 的key的来源，寻找方向错误，花了大量时间，也没找到 -》没想到内部还有额外处理逻辑： 即，有个单独的函数： -[WAStaticPrivateKeyStore privateKey] 其内部是有代码逻辑的： 后续可以确认，的确有处理逻辑： IDA中能看到 Xcode调试汇编代码也能看到 进入： Xcode汇编代码： SharedModules`-[WAStaticPrivateKeyStore privateKey]: -> 0x10756f7f4 : sub sp, sp, #0x80 0x10756f7f8 : stp x24, x23, [sp, #0x40] 0x10756f7fc : stp x22, x21, [sp, #0x50] 0x10756f800 : stp x20, x19, [sp, #0x60] 0x10756f804 : stp x29, x30, [sp, #0x70] 0x10756f808 : add x29, sp, #0x70 0x10756f80c : mov x19, x0 0x10756f810 : adrp x8, 2323 0x10756f814 : ldr x8, [x8, #0x970] 0x10756f818 : ldr x8, [x8] 0x10756f81c : str x8, [sp, #0x38] 0x10756f820 : adrp x8, 3407 0x10756f824 : ldr x0, [x8, #0x658] 0x10756f828 : bl 0x10790c780 ; objc_msgSend$defaultManager 0x10756f82c : mov x29, x29 ... 0x10756f9f0 : bl 0x1078b91c4 ; sub_F291C4 0x10756f9f4 : bl 0x10789c63c ; objc_msgSend_length_x20_F0C63C 0x10756f9f8 : str x0, [sp] 0x10756f9fc : adrp x2, 1485 0x10756fa00 : add x2, x2, #0xc39 ; \"chatkey-store//cck/get/corrupted data %lu\" 0x10756fa04 : b 0x10756f93c ; 0x10756fa08 : bl 0x1078e2d40 ; symbol stub for: __stack_chk_fail 和： 【未解决】iOS逆向WhatsApp：-[WAContext staticPrivateKeyStore] 的： WhatsApp/headers/WhatsApp_v23.20.79_headers_SharedModules/WAContext.h @interface WAContext : WAScopedObjectContainer { ... WAStaticPrivateKeyStore *_staticPrivateKeyStore; ... @property(readonly, nonatomic) WAStaticPrivateKeyStore *staticPrivateKeyStore; 其中也是： -[WAContext staticPrivateKeyStore] 是个独立的函数 其内部是有额外的处理逻辑的： IDA中 Xcode中 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-04 11:21:55 "},"ios_objc/property/xcode_frida_not_same.html":{"url":"ios_objc/property/xcode_frida_not_same.html","title":"Xcode和Frida属性值不一致","keywords":"","body":"Xcode和Frida属性值不一致 iOS逆向调试时，遇到的一些特殊情况 NSXPCConnection的属性 部分属性值：Xcode中有，但Frida中没有 processName processBundleIdentifier 其他属性，倒是都正常：Xcode和Frida中都有 endpoint processIdentifier exportedInterface exportedObject remoteObjectInterface remoteObjectProxy userInfo auditSessionIdentifier effectiveUserIdentifier effectiveGroupIdentifier 详见： 【已解决】iOS逆向Apple账号：用frida打印com.apple.ak.auth.xpc的NSXPCConnection的其他属性值 【未解决】iOS逆向：通过查看NSXPCConnection的属性值搞清楚目标处理的类是哪个 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-03 12:05:33 "},"dynamic_debug/":{"url":"dynamic_debug/","title":"动态调试","keywords":"","body":"动态调试 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-02-26 09:38:47 "},"dynamic_debug/debug_logic/":{"url":"dynamic_debug/debug_logic/","title":"调试代码逻辑","keywords":"","body":"调试代码逻辑 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-02-26 09:38:47 "},"dynamic_debug/debug_logic/func_trigger/":{"url":"dynamic_debug/debug_logic/func_trigger/","title":"寻找函数触发时机","keywords":"","body":"寻找函数触发时机 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-03 10:10:47 "},"dynamic_debug/debug_logic/func_trigger/alloc_init_new.html":{"url":"dynamic_debug/debug_logic/func_trigger/alloc_init_new.html","title":"alloc和init和new","keywords":"","body":"hook类的函数：alloc、init、new 背景 iOS逆向，找函数调用逻辑，已知iOS的ObjC的函数了。但是写了hook代码，调试却没触发到。 此时，就很麻烦：找不到函数被调用的时机，没触发函数，就没法继续调试，找被调用时候的相关逻辑了。 此时，有个新思路： 去hook类的alloc+init函数（甚至new函数），看看是否触发 则往往：能触发，即可顺利找到，相关的类被alloc和init的被初始化的地方，就容易继续找到相关处理逻辑了 举例 WASignalLocalKeyBundle和WASignalKeyBundle 【已解决】iOS逆向WhatsApp：研究注册URL中baseParams参数来源和逻辑：e_keytype 的： %hook WASignalLocalKeyBundle +(id)alloc{ id allocatedSignalLocalKeyBundle = %orig; iosLogInfo(\"allocatedSignalLocalKeyBundle=%@\", allocatedSignalLocalKeyBundle); return allocatedSignalLocalKeyBundle; } - (id)init{ id initedSignalLocalKeyBundle = %orig; iosLogInfo(\"initedSignalLocalKeyBundle=%@\", initedSignalLocalKeyBundle); return initedSignalLocalKeyBundle; } %end %hook WASignalKeyBundle +(id)alloc{ id allocatedSignalKeyBundle = %orig; iosLogInfo(\"allocatedSignalKeyBundle=%@\", allocatedSignalKeyBundle); return allocatedSignalKeyBundle; } - (id)init{ id initedSignalKeyBundle = %orig; iosLogInfo(\"initedSignalKeyBundle=%@\", initedSignalKeyBundle); return initedSignalKeyBundle; } %end 以及通过加上对应断点： +[WASignalLocalKeyBundle alloc] 而找到触发的地方了： 从而可以找到被调用的地方，继续研究调用和生成逻辑了。 WAContextDependencyInversionMain 【未解决】iOS逆向WhatsApp：-[WAContextDependencyInversionMain init] 【未解决】iOS逆向WhatsApp：研究WhatsAppAppDelegate的dependencyInversion的来源和生成逻辑 的 %hook WAContextDependencyInversionMain + (id)alloc{ id newInversion = %orig; iosLogInfo(\"newInversion=%@\", newInversion); return newInversion; } - (id)init{ id initedInversion = %orig; iosLogInfo(\"initedInversion=%@\", initedInversion); return initedInversion; } %end %hook WhatsAppAppDelegate + (id)alloc{ id newAppDelegate = %orig; iosLogInfo(\"newAppDelegate=%@\", newAppDelegate); iosLogInfo(\"alloc: dependencyInversion=%@\", [newAppDelegate dependencyInversion]); return newAppDelegate; } - (id)init{ id initedApp = %orig; iosLogInfo(\"initedApp=%@\", initedApp); iosLogInfo(\"init: dependencyInversion=%@\", [initedApp dependencyInversion]); return initedApp; } +(id)new{ id newApp = %orig; iosLogInfo(\"newApp=%@\", newApp); return newApp; } %end WAEC25519PrivateKey 【未解决】iOS逆向WhatsApp：类WAEC25519PrivateKey 的 %hook WAEC25519PrivateKey + (id)alloc{ id allocedPrivKey = %orig; iosLogInfo(\"allocedPrivKey=%@\", allocedPrivKey); return allocedPrivKey; } - (id)init{ id initedKey = %orig; iosLogInfo(\"initedKey=%@\", initedKey); return initedKey; } + (id)new{ id newPrivKey = %orig; iosLogInfo(\"newPrivKey=%@\", newPrivKey); return newPrivKey; } %end crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-03 10:19:09 "},"dynamic_debug/debug_logic/func_trigger/reinstall_spawn.html":{"url":"dynamic_debug/debug_logic/func_trigger/reinstall_spawn.html","title":"重装和spawn方式","keywords":"","body":"重装和spawn方式 背景 研究iOS逆向期间，需要找某些iOS的ObjC函数的调用的时机和地方 以便于研究代码逻辑。 但是有时候，虽然找到并给函数写了hook代码，但是却没有触发 所以需要想办法，找函数被触发调用的时机 后来有了新思路： 该函数很可能是：app初始化时，仅允许一次 所以后续调试，无法再次触发 如何触发 模拟环境入手：重新安装app 且用Spawn方式启动，模拟重新安装后首次启动 或许就能触发 从代码调用入手：借助于IDA的交叉引用xref，references to，继续向上找函数调用的地方 （虽然往往也很复杂，不好找，但）往往最后也是你能找到调用的地方的 举例 -[WASignalKeyStore saveToKeychainIdentityKeypairData:registrationIdData:] 想要寻找函数： -[WASignalKeyStore saveToKeychainIdentityKeypairData:registrationIdData:] 的调用逻辑，何时被调用的，就遇到了： 写了hook代码： 但是却没触发 然后继续寻找其是如何被调用的 而后是： 借助于=主要用到了： IDA中的： List cross references to 从别的哪里调用到此处函数的 Jump to xref to operand 其他哪里有，互相的交叉引用 如此，一点点向上层，去找调用到此处代码的地方，去找更上层的调用 Down o __objc_data:00000000019DA608 __objc2_meth -》 __objc_data:00000000019DA608 __objc2_meth __objc_selrefs:0000000001911B78 selRef_saveToKeychainIdentityKeypairData_registrationIdData_ DCQ sel_saveToKeychainIdentityKeypairData_registrationIdData_ __objc_selrefs:0000000001911B78 ; DATA XREF: _objc_msgSend$saveToKeychainIdentityKeypairData_registrationIdData_↑o __objc_selrefs:0000000001911B78 ; _objc_msgSend$saveToKeychainIdentityKeypairData_registrationIdData_+4↑r __objc_selrefs:0000000001911B78 ; \"saveToKeychainIdentityKeypairData:regis\"... -》 Up o _objc_msgSend$saveToKeychainIdentityKeypairData_registrationIdData_ ADRP X1, #selRef_saveToKeychainIdentityKeypairData_registrationIdData_@PAGE Up r _objc_msgSend$saveToKeychainIdentityKeypairData_registrationIdData_+4 LDR X1, [X1,#selRef_saveToKeychainIdentityKeypairData_registrationIdData_@PAGEOFF] -》 __objc_stubs:0000000000FDD7A0 _objc_msgSend$saveToKeychainIdentityKeypairData_registrationIdData_ __objc_stubs:0000000000FDD7A0 ; CODE XREF: -[WASignalKeyStore setIdentityKeypairData:registrationIdData:]+4C↑p __objc_stubs:0000000000FDD7A0 ; -[WASignalKeyStore fetchFromKeychainIdentityKeypairData:registrationIdData:]+128↑p __objc_stubs:0000000000FDD7A0 ADRP X1, #selRef_saveToKeychainIdentityKeypairData_registrationIdData_@PAGE __objc_stubs:0000000000FDD7A4 LDR X1, [X1,#selRef_saveToKeychainIdentityKeypairData_registrationIdData_@PAGEOFF] __objc_stubs:0000000000FDD7A8 ADRP X16, #_objc_msgSend_ptr@PAGE __objc_stubs:0000000000FDD7AC LDR X16, [X16,#_objc_msgSend_ptr@PAGEOFF] __objc_stubs:0000000000FDD7B0 BR X16 __objc_stubs:0000000000FDD7B0 ; End of function _objc_msgSend$saveToKeychainIdentityKeypairData_registrationIdData_ Up p -[WASignalKeyStore setIdentityKeypairData:registrationIdData:]+4C BL _objc_msgSend$saveToKeychainIdentityKeypairData_registrationIdData_ Up p -[WASignalKeyStore fetchFromKeychainIdentityKeypairData:registrationIdData:]+128 BL _objc_msgSend$saveToKeychainIdentityKeypairData_registrationIdData_ 至此，找到了，上层的调用： -[WASignalCoordinator setIdentityKeyPair:signedPreKey:registrationID:] -[WASignalKeyStore initializeSelfIdentity:registrationIdData:] 继续向上找： 从： -[WASignalCoordinator setIdentityKeyPair:signedPreKey:registrationID:] 继续找： objc_msgSend_setIdentityKeyPair_signedPreKey_registrationID__8120 最后找到了： -[WASignalCoordinator createAndSaveIdentity] 其中的： bool __cdecl -[WASignalCoordinator createAndSaveIdentity](WASignalCoordinator *self, SEL a2) { ... if ( (signal_protocol_key_helper_generate_registration_id_BF8C(&a1, 1LL) & 0x80000000) != 0 ) ... else { v12 = (void *)x20tox0_x19tox2_F0B95C(); v17 = (unsigned int)objc_msgSend_setIdentityKeyPair_signedPreKey_registrationID__8120( v12, str_setIdentityKeyPair_signedPreKey_registrationID_, identityKeyPair, signedPreKey, registrationID) ... } 中的： signal_protocol_key_helper_generate_registration_id 后优化改名为：signal_protocol_key_helper_generate_registration_id_BF8C 就很像是我们要找的代码逻辑： 用于初始化生成RegistrationId=regId=RegistrationIdData的函数 最后经过深入研究： 和实际调试确认，的确就是的我们要找的逻辑。 具体过程详见： 【未解决】iOS逆向WhatsApp：-[WASignalKeyStore saveToKeychainIdentityKeypairData:registrationIdData:] 【未解决】iOS逆向WhatsApp：-[WASignalCoordinator createAndSaveIdentity] 【未解决】iOS逆向WhatsApp：signal_protocol_key_helper_generate_registration_id 注： 期间模拟代码首次运行，还涉及到： 修改寄存器，让代码走另外分支 详见： 修改寄存器值走期望的分支 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-03 10:42:29 "},"dynamic_debug/debug_logic/var_changed/":{"url":"dynamic_debug/debug_logic/var_changed/","title":"寻找变量改动时机","keywords":"","body":"寻找变量改动时机 寻找变量赋值=变量值改动的时机 背景 如果找不到某个变量值被改动的地方 比如某个类的属性的值被初始化了某个值 思路：用watchpoint寻找变量值被改动 初始化的地方 具体实现： lldb的watchpoint chisel的wivar 此处举例说明： iOS逆向WhatsApp时，Xcode调试函数： SharedModules`-[WASignalKeyStore fetchIdentityKeypairData:registrationIdData:]: -> 0x10ba50124 : stp x22, x21, [sp, #-0x30]! 发现此时registrationIdData已经有值了： (lldb) po [0x112994040 valueForKey: @\"_registrationIdData\"] 希望找到，哪里赋值的 但是找了各个疑似设置了该值的函数，去hook后： %hook WASignalKeyStore +(id)alloc{ id allocatedSignalKeyStore = %orig; iosLogInfo(\"allocatedSignalKeyStore=%@\", allocatedSignalKeyStore); return allocatedSignalKeyStore; } - (id)init{ id initedSignalKeyStore = %orig; iosLogInfo(\"initedSignalKeyStore=%@\", initedSignalKeyStore); return initedSignalKeyStore; } - (_Bool)initializeSelfIdentity:(id)selfIdentity registrationIdData:(id)regIdData{ iosLogInfo(\"selfIdentity=%@, regIdData=%@\", selfIdentity, regIdData); _Bool initOk = %orig; iosLogInfo(\"initOk=%d\", initOk); return initOk; } - (int)fetchFromKeychainIdentityKeypairData:(id *)outKeychainIdKeypairData registrationIdData:(id *)outRegIdData{ iosLogInfo(\"outKeychainIdKeypairData=%p, outRegIdData=%p\", outKeychainIdKeypairData, outRegIdData); int fetchRet = %orig; iosLogInfo(\"fetchRet=%d\", fetchRet); return fetchRet; } - (void)fetchIdentityKeypairData:(id *)outIdKeypairData registrationIdData:(id *)outRegIdData{ iosLogInfo(\"outIdKeypairData=%p, outRegIdData=%p\", outIdKeypairData, outRegIdData); %orig; } -(void)setRegistrationIdData:(id)newRegIdData{ iosLogInfo(\"newRegIdData=%@\", newRegIdData); %orig; } %end 却都没有触发 后来就想到： 去加上watchpoint，看看何时设置的该值 而具体watchpoint的用法，应该是： 思路：找到对应ObjC对象的实例的指针，找到对应的属性_registrationIdData的偏移量，再去给该地址加上watchpoint的write的监视 不过，用于监视某个类的属性变量值，另外有个更方便的工具： lldb的插件：chisel，中有个命令wivar 在安装了chisel后： 【已解决】M2 Max Mac中安装lldb插件：chisel 去使用： (lldb) po allocatedSignalKeyStore (lldb) wivar 0x127d0c2b0 _registrationIdData Remember to delete the watchpoint using: watchpoint delete 1 后续继续运行，即可触发： 对应的函数调用堆栈： (lldb) bt * thread #4, queue = 'net.whatsapp.crypto', stop reason = watchpoint 1 * frame #0: 0x00000001affe4100 libobjc.A.dylib`objc_storeStrong + 48 frame #1: 0x0000000107024fdc SharedModules`blake3_compress_xof_portable + 1244912 frame #2: 0x000000010702437c SharedModules`blake3_compress_xof_portable + 1241744 frame #3: 0x00000001069b8970 SharedModules`sub_6307F8 + 2343288 frame #4: 0x00000001069bee8c SharedModules`sub_6307F8 + 2369172 frame #5: 0x0000000107017bcc SharedModules`blake3_compress_xof_portable + 1190624 frame #6: 0x00000001aff6e610 libdispatch.dylib`_dispatch_call_block_and_release + 24 frame #7: 0x00000001aff6f184 libdispatch.dylib`_dispatch_client_callout + 16 frame #8: 0x00000001aff1b404 libdispatch.dylib`_dispatch_lane_serial_drain$VARIANT$mp + 608 frame #9: 0x00000001aff1be28 libdispatch.dylib`_dispatch_lane_invoke$VARIANT$mp + 468 frame #10: 0x00000001aff25314 libdispatch.dylib`_dispatch_workloop_worker_thread + 588 frame #11: 0x00000001affbeb88 libsystem_pthread.dylib`_pthread_wqthread + 276 如此，即可继续调试研究，此处是如何设置值的了。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-03 11:44:48 "},"dynamic_debug/debug_logic/var_changed/wivar.html":{"url":"dynamic_debug/debug_logic/var_changed/wivar.html","title":"wivar","keywords":"","body":"chisel的wivar 心得 只能给（带下划线的）内置属性加上监视 无法给（不带下划线的）property属性加上监视 举例： 对于定义： WhatsApp/headers/WhatsApp_v23.20.79_headers_SharedModules/WAUUID.h @interface WAUUID : NSObject { NSUUID *_uuid; ... } ... @property(readonly, nonatomic) NSUUID *uuid; // @synthesize uuid=_uuid; 具体现象： 可以给 内置属性 下划线开头的：_uuid 加上监视 (lldb) po allocedWafbUUID (null) (lldb) wivar 0x281b398a0 _uuid Remember to delete the watchpoint using: watchpoint delete 1 无法给（不带下划线的）property属性加上监视(lldb) wivar 0x281b398a0 uuid error: error: Execution was interrupted, reason: EXC_BAD_ACCESS (code=1, address=0x0). The process has been returned to the state before expression evaluation. Traceback (most recent call last): File \"/opt/homebrew/Cellar/chisel/2.0.1/libexec/fbchisellldb.py\", line 99, in runCommand command.run(args, options) File \"/opt/homebrew/Cellar/chisel/2.0.1/libexec/commands/FBDebugCommands.py\", line 69, in run ivarSize = int(fb.evaluateExpression(ivarSizeCommand), 0) TypeError: int() can't convert non-string with explicit base crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-03 11:44:13 "},"dynamic_debug/debug_logic/change_logic/":{"url":"dynamic_debug/debug_logic/change_logic/","title":"改变运行逻辑","keywords":"","body":"改变运行逻辑 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-03 10:53:48 "},"dynamic_debug/debug_logic/change_logic/edit_reg_value.html":{"url":"dynamic_debug/debug_logic/change_logic/edit_reg_value.html","title":"修改寄存器值","keywords":"","body":"修改寄存器值走期望的分支 此处通过举例说明： 如何修改寄存器的值，使得改变程序原有运行逻辑，跳转到我们所期望分支： 折腾： 【未解决】iOS逆向WhatsApp：-[WASignalManager loadWithURL:dateProvider:] 期间，此处Xcode汇编代码： 0x108fdcaec : mov x0, x25 0x108fdcaf0 : bl 0x109728a60 ; objc_msgSend$localKeysAvailable 0x108fdcaf4 : tbnz w0, #0x0, 0x108fdcb18 ; 0x108fdcaf8 : bl 0x10967c9a8 ; sub_F0C9A8 0x108fdcafc : adrp x2, 2278 0x108fdcb00 : add x2, x2, #0xb00 ; \"signal/manager/base//load/no prior keys\" 0x108fdcb04 : add x1, sp, #0x10 0x108fdcb08 : bl 0x10967bea4 ; sub_F0BEA4 0x108fdcb0c : mov x0, x25 0x108fdcb10 : bl 0x109747300 ; objc_msgSend$regenerateKeyStore 0x108fdcb14 : tbz w0, #0x0, 0x108fdccb4 ; 0x108fdcb18 : str x26, [sp] 0x108fdcb1c : mov x0, x25 0x108fdcb20 : bl 0x1097251c0 ; objc_msgSend$keyStore 当前PC在： 0x108fdcaf4 : tbnz w0, #0x0, 0x108fdcb18 ; 此时： (lldb) reg r w0 w0 = 0x00000001 (lldb) reg r x0 x0 = 0x0000000000000001 即： 代码逻辑中：localKeysAvailable=True 所以走后续的逻辑 对应着，Xcode汇编中的： 0x108fdcb18 : str x26, [sp] 0x108fdcb1c : mov x0, x25 0x108fdcb20 : bl 0x1097251c0 ; objc_msgSend$keyStore ... 对应着IDA伪代码： isLocalKeysAvailable = (__int64)objc_msgSend_localKeysAvailable_8A60(curWASignalCoordinator, str_localKeysAvailable); if ( (isLocalKeysAvailable & 1) != 0 || (v82 = sp10tox0_x0tozero_F0C9A8(isLocalKeysAvailable, (__int64)v79, v80, v81), sub_F0BEA4(v82, v140, \"signal/manager/base//load/no prior keys\"), v84 = (__int64)objc_msgSend_regenerateKeyStore_7300(curWASignalCoordinator, v83), (v84 & 1) != 0) ) { v87 = objc_msgSend_keyStore(curWASignalCoordinator, v79, v59); ... 中的： v87 = objc_msgSend_keyStore(curWASignalCoordinator, v79, v59); ... 部分 然后此处为了调试需要： 想要程序走： objc_msgSend_regenerateKeyStore_7300 的部分代码 所以去改变寄存器值： (lldb) reg write x0 0 修改后，read查看确认： (lldb) reg r x0 x0 = 0x0000000000000000 然后继续执行： 程序的确执行了，另外的分支了： 可以使得程序运行，暂时走我们要的分支了： (v82 = sp10tox0_x0tozero_F0C9A8(isLocalKeysAvailable, (__int64)v79, v80, v81), sub_F0BEA4(v82, v140, \"signal/manager/base//load/no prior keys\"), v84 = (__int64)objc_msgSend_regenerateKeyStore_7300(curWASignalCoordinator, v83) -> 0x108fdcaf8 : bl 0x10967c9a8 ; sub_F0C9A8 0x108fdcafc : adrp x2, 2278 0x108fdcb00 : add x2, x2, #0xb00 ; \"signal/manager/base//load/no prior keys\" 0x108fdcb04 : add x1, sp, #0x10 0x108fdcb08 : bl 0x10967bea4 ; sub_F0BEA4 0x108fdcb0c : mov x0, x25 0x108fdcb10 : bl 0x109747300 ; objc_msgSend$regenerateKeyStore 0x108fdcb14 : tbz w0, #0x0, 0x108fdccb4 ; -》 (lldb) reg r x0 x0 = 0x0000000283603340 (lldb) po $x0 是对的，即可去调用： regenerateKeyStore 了，是我们要的逻辑。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-26 22:44:29 "},"dynamic_debug/debug_logic/change_logic/hook_ret_val.html":{"url":"dynamic_debug/debug_logic/change_logic/hook_ret_val.html","title":"hook函数返回值","keywords":"","body":"hook函数返回值 对于之前的： 修改寄存器值 从调试的角度来说，如果每次都要改变对应分支逻辑，而要每次都去改变寄存器值去实现此目的，则：调试效率比较低 想要提高效率，可以考虑改用别的方式 比如，去hook对应的返回值 此处就是： 直接hook函数，返回False，更省事 具体步骤： hook代码： %hook WASignalCoordinator //bool isEmulateRegenerateKeys = FALSE; bool isEmulateRegenerateKeys = TRUE; -(_Bool)localKeysAvailable{ _Bool isKeyExist = FALSE; if (isEmulateRegenerateKeys) { isKeyExist = FALSE; } else { isKeyExist = %orig; } return isKeyExist; } %end 调试后，生效了 触发到此处调用： 函数调用堆栈： (lldb) bt * thread #3, queue = 'net.whatsapp.crypto', stop reason = breakpoint 43.1 * frame #0: 0x000000010e715140 HookWhatsApp.dylib`_logos_method$_ungrouped$WASignalCoordinator$localKeysAvailable(self=0x00000002805f4080, _cmd=\"localKeysAvailable\") at hook_keys.xm:226:11 frame #1: 0x000000010b898af4 SharedModules`-[WASignalManager loadWithURL:dateProvider:] + 548 frame #2: 0x000000010b89ee8c SharedModules`-[WASignalManager initWithUserContext:chatStorage:xmppConnection:preferences:localKeyValueStore:urlToKeyStore:encryptMessageCreator:decryptMessageParser:dateProvider:deviceManager:deviceManagerMain:ownDeviceManager:chatDeviceLoader:chatDeviceListLoader:abProperties:accountJIDProvider:accountMigrationService:smbCertProvider:]_block + 48 frame #3: 0x000000010bef7bcc SharedModules`-[WASignalSchedulerHelper dispatchAsyncForAction:completionQueue:completion:]_block + 24 frame #4: 0x00000001aff6e610 libdispatch.dylib`_dispatch_call_block_and_release + 24 frame #5: 0x00000001aff6f184 libdispatch.dylib`_dispatch_client_callout + 16 frame #6: 0x00000001aff1b404 libdispatch.dylib`_dispatch_lane_serial_drain$VARIANT$mp + 608 frame #7: 0x00000001aff1be28 libdispatch.dylib`_dispatch_lane_invoke$VARIANT$mp + 468 frame #8: 0x00000001aff25314 libdispatch.dylib`_dispatch_workloop_worker_thread + 588 frame #9: 0x00000001affbeb88 libsystem_pthread.dylib`_pthread_wqthread + 276 后续是 w0=0 而不是之前的： w0=1 了： 代码走了另外分支： 达到我们的期望了： 通过hook代码： -[WASignalCoordinator localKeysAvailable] 返回：False=0 实现代码走另外分支。 而无需每次去修改寄存器了。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-03 10:57:53 "},"dynamic_debug/xcode_debug/":{"url":"dynamic_debug/xcode_debug/","title":"Xcode调试","keywords":"","body":"Xcode调试 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-02-26 09:38:47 "},"dynamic_debug/xcode_debug/attach_debug/":{"url":"dynamic_debug/xcode_debug/attach_debug/","title":"Attach调试","keywords":"","body":"Attach调试 Xcode去Attach挂载调试app或二进制：通过PID或进程名 至此，目前还是和之前一样： 对于Xcode 去Attach调试（iOS的） 操作步骤：Xcode-》Debug-》Attach to Process by PID or Name -》PID or Process Name 调试内容： app=Application=应用=程序 结论：只能用PID，而无法用Name 举例 设置=Preferences 相关信息 包名：com.apple.Preferences 二进制位置：/Applications/Preferences.app/Preferences 结论：无法通过com.apple.Preferences或Preferences的Name去Attach调试 只能通过（ps -A | grep Preferences 找到的）PID值，去Attach调试 Executables=可执行文件=binary=二进制 结论：可以用Name（二进制名称） 举例 akd 二进制位置：/System/Library/PrivateFrameworks/AuthKit.framework/akd 结论：可以用akd直接去调试二进制 而无需用PID值（先用ps查看到PID，再输入PID值） 成功调试时的现象 PID or Process Name在输入PID值/Name后 图 此处要稍等等待一会（大概几十秒） 然后会出现提示：Waiting to attach PID值/Name 再稍等一下（大概几秒），就会显示正常的提示： PID值/Name 具体现象 右下角：调试窗口：显示出进程PID值/Name 右上角：状态信息显示：Running PID值/Name on iPhone 左上角：Debug Navigator中显示出PID值/Name和当前硬件信息：CPU、Memory等等 图 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-04 12:07:29 "},"dynamic_debug/xcode_debug/callstack/":{"url":"dynamic_debug/xcode_debug/callstack/","title":"函数调用堆栈","keywords":"","body":"函数调用堆栈 查看函数调用堆栈 已知的传统手段：Xcode/lldb中，用命令：bt 新的手段：tweak插件的hook代码中，调用：[NSThread callStackSymbols] [NSThread callStackSymbols]效果举例 代码： NSArray *btArr = [NSThread callStackSymbols]; 输出函数调用堆栈的信息： btArr=( 0 jailAppleAccount.dylib 0x000000010450e504 _ZL47_logos_meta_method$_ungrouped$AADeviceInfo$udidP10objc_classP13objc_selector + 80 1 AppleAccount 0x0000000195d31f14 6F5C18B1-3F20-3D13-93B5-E1821E8DB2C1 + 495380 2 AppleAccount 0x0000000195cbcd20 6F5C18B1-3F20-3D13-93B5-E1821E8DB2C1 + 15648 3 libdispatch.dylib 0x0000000183f892ec 5D722AFC-FB8C-3769-BF66-167BB94A6133 + 406252 4 libdispatch.dylib 0x0000000183f8a2f0 5D722AFC-FB8C-3769-BF66-167BB94A6133 + 410352 5 libdispatch.dylib 0x0000000183f6e5a8 5D722AFC-FB8C-3769-BF66-167BB94A6133 + 296360 6 libdispatch.dylib 0x0000000183f6ec5c 5D722AFC-FB8C-3769-BF66-167BB94A6133 + 298076 7 libsystem_pthread.dylib 0x00000001ddc36efc _pthread_wqthread + 224 8 libsystem_pthread.dylib 0x0 说明：只不过，是不带符号的，只有地址。不容易看出具体细节信息。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-26 22:51:37 "},"dynamic_debug/xcode_debug/callstack/func_not_same.html":{"url":"dynamic_debug/xcode_debug/callstack/func_not_same.html","title":"函数名不一致","keywords":"","body":"函数名不一致 心得：Xcode中UI看到的函数调用堆栈中的函数，未必准确，有时候是在bt中才能看到真正的函数 举例： 看到的是： crypto_sign_ed25519_ref10_fe_sq 切换过去，但是当前窗口没变化：没有切换到：crypto_sign_ed25519_ref10_fe_sq的汇编代码窗口 而回头才注意到： 其实bt中的函数调用堆栈： (lldb) bt * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 20.1 * frame #0: 0x000000010a411ca8 HookWhatsApp.dylib`_logos_meta_method$_ungrouped$NSURLRequest$requestWithURL$(self=NSMutableURLRequest, _cmd=\"requestWithURL:\", URL=\"https://v.whatsapp.net/v2/reg_onboard_abprop?cc=1&in=8784650468&rc=0&ab_hash=2mnxZr\") at HookWhatsApp.xm:101:12 frame #1: 0x00000001088e6798 SharedModules`+[NSMutableURLRequest(Additions) wa_requestWithURL:attribution:] + 28 frame #2: 0x0000000104bd05c4 WhatsApp`+[WARegistrationURLBuilder preChatdABPropURLRequestWithPhoneNumber:abHash:] + 56 frame #3: 0x0000000104bd75c4 WhatsApp`-[WARegistrationManager requestPreChatdABPropsForPhoneNumber:userContext:completion:] + 112 ... 其实是： frame #1: 0x00000001088e6798 SharedModules+[NSMutableURLRequest(Additions) wa_requestWithURL:attribution:] + 28` 即：真正的函数是：+[NSMutableURLRequest(Additions) wa_requestWithURL:attribution:]等相关调用 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-04 11:42:30 "},"dynamic_debug/xcode_debug/see_all_var/":{"url":"dynamic_debug/xcode_debug/see_all_var/","title":"查看当前所有变量值","keywords":"","body":"查看当前所有变量值 Xcode调试期间，正常来说，左下角可以查看到当前变量值： 如果想要查看属性值，点击大于号>，去展开： 而此处发现个更好用的： 如果想要查看： 全部变量值 = 除了当前局部变量值之外，也显示全局变量值等等 可以点击下面的Auto，切换为： All Variables, Registers, Globals and Statics 可以显示： 更多的，全局变量，寄存器、静态变量等等值： 点击展开： Floating Point Registers 可以查看到： 更多的浮点寄存器值 展开： General 可以看到： far esr exception 的值： 以及： 通用寄存器 General Purpose Registers 的值： 如此： 可以更加方便的调试程序了： 不需要经常的用： reg r 去查看所有寄存器的值了 直接从此处窗口即可查看变量值 不过也有小缺点：显示太多值，好像会拖慢调试速度。 如果如果经常频繁调试，貌似：也不太适合始终打开和显示这么多值。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-04 10:48:15 "},"dynamic_debug/xcode_debug/fetch_var_on_iphone/":{"url":"dynamic_debug/xcode_debug/fetch_var_on_iphone/","title":"Fetching Variables on iPhone","keywords":"","body":"Fetching Variables on iPhone 之前调试期间，遇到一个情况： 当：部分函数汇编代码非常长，时，触发了断点后，会出现： 卡死现象 == 等待期间，右上角状态会显示： Fetching Variables on iPhone 此处等待一段时间后，获取完成后，正常显示触发断点处的代码： crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-04 10:51:54 "},"dynamic_debug/xcode_debug/asm_tab_opening/":{"url":"dynamic_debug/xcode_debug/asm_tab_opening/","title":"汇编代码窗口保持打开状态","keywords":"","body":"汇编代码窗口保持打开状态 给汇编代码窗口保持打开状态不关闭 对于iOS逆向期间，去调试部分函数时，函数窗口当时是打开的。 但是一旦停止调试，窗口就关闭没有了。 而希望实现： 始终打开，供后续参考和研究。 即使停止调试了，也能查看该窗口中的汇编代码，供研究。 而后来无意间发现： Xcode中，打开的窗口，有个Keep Open的功能： 右键-》Keep Open 注意：在此之前，tab窗口中函数名是斜体的 -》表示临时的窗口？ 点击后： tab窗口中函数字体就变成了 非斜体，普通的字体： 且Keep Open是灰色了。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-04 11:04:47 "},"dynamic_debug/xcode_debug/2_target_arm64_arm64e/":{"url":"dynamic_debug/xcode_debug/2_target_arm64_arm64e/","title":"2个调试目标：arm64和arm64e","keywords":"","body":"2个调试目标：arm64和arm64e 现象：Xcode的目标调试iOS设备出现2个：一个是arm64一个是arm64e 结论：不是问题，无需解决 细节 此处： Xcode中，目标调试设备出现2个 本身只连接了一个iPhone设备：iPhone11_151 但是却出现了2个调试目标： iPhone11_151 (arm64e) iPhone11_151 (arm64) 的原因： 基本上确定是： 是由于之前给Architectures中，加了arm64（和arm64d）： 而导致的此处现象。 此现象： 原以为：是有问题的 以为同一iPhone设备，出现2个调试目标，会影响调试 尤其是影响此处的：iOSOpenDev项目Profiling后无法自动安装deb插件了 实际上是另外原因导致的，详见： 【已解决】iOSOpenDev的Xcode中Profiling编译后无法自动安装deb插件到目标设备iPhone11中 现在基本确认：是没有问题的 且按道理，不论选择那个目标：iPhone11_151 (arm64) 还是 iPhone11_151 (arm64e)，都可以正常调试的 原因是：此处编译出的iOS插件动态库文件jailAppleAccount.dylib，是FAT格式的，支持2种架构：arm64和arm64e 既可以在arm64的设备上运行，也可以在arm64e的设备（比如此处的iPhone11）上运行 之前就是选择了iPhone11_151 (arm64)，虽然和iPhone11（是A12，是arm64）不一致，但是都可以正常调试 补充说明 而之所以要额外加arm64e，则是由于： 为了解决libsubstrate.dylib能在arm64的A12的iPhone11中，不能正常运行的问题： iOSOpenDev自带的libsubstrate.dylib，只支持arm64，不支持arm64e，所以： 换了FAT格式的libsubstrate.dylib，支持2种架构：arm64和arm64e 同时给Architectures中额外加了arm64e 具体详见： 【已解决】iOSOpenDev的插件dylib注入iPhone11失败：mach-o file but is an incompatible architecture have arm64 need arm64e crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-04 11:11:38 "},"dynamic_debug/xcode_debug/xm_cannot_locate/":{"url":"dynamic_debug/xcode_debug/xm_cannot_locate/","title":"xm文件无法定位到源代码位置","keywords":"","body":"xm文件无法定位到源代码位置 Xcode调试iOSOpenDev的xm文件无法定位到源代码位置 现象 之前用Xcode去调试iOSOpenDev的Logos插件代码时，遇到一个问题： 部分断点 比如： %hook WARegistrationManager - (void)performSameDeviceCheckForSession:(id)session updateRegistrationTokenIfNecessary:(_Bool)isUpdateRegToken withCompletion:(id)doneBlk{ iosLogInfo(\"session=%@, isUpdateRegToken=%s, doneBlk=%@\", session, boolToStr(isUpdateRegToken), doneBlk); %orig; } 的%orig的断点： 虽然触发了，但是触发时，没有定位到xm源代码文件的对应源代码位置 而是只是显示打开了xm文件，但是是空的显示： 尝试解决的过程 此时拷贝出函数调用堆栈的第一行，是： #0 0x0000000109aabc08 in _logos_method$_ungrouped$WARegistrationManager$performSameDeviceCheckForSession$updateRegistrationTokenIfNecessary$withCompletion$(WARegistrationManager*, objc_selector*, objc_object*, bool, objc_object*) at /xxx/WhatsApp/dynamicDebug/iOSOpenDev_WhatsApp/HookWhatsApp/HookWhatsApp/hook_reg.xm:51 此时，只能切换到项目源码显示tab窗口： 然后右键该文件：hook_reg.xm Open As->Source Code 才能显示出： 真正的代码所在的行数 而此问题： 之前以为是：.xm的%orig，内部对应着的具体实现：.mm文件 而.mm文件中的代码，是多行： static void _logos_method$_ungrouped$WARegistrationManager$performSameDeviceCheckForSession$updateRegistrationTokenIfNecessary$withCompletion$(_LOGOS_SELF_TYPE_NORMAL WARegistrationManager* _LOGOS_SELF_CONST __unused self, SEL __unused _cmd, id session, _Bool isUpdateRegToken, id doneBlk){ iosLogInfo(\"session=%@, isUpdateRegToken=%s, doneBlk=%@\", session, boolToStr(isUpdateRegToken), doneBlk); _logos_orig$_ungrouped$WARegistrationManager$performSameDeviceCheckForSession$updateRegistrationTokenIfNecessary$withCompletion$(self, _cmd, session, isUpdateRegToken, doneBlk); } 不好映射会.xm中，所导致的 所以后续去加上了，单独的一行代码： gNoUse = 1; 变成： - (void)performSameDeviceCheckForSession:(id)session updateRegistrationTokenIfNecessary:(_Bool)isUpdateRegToken withCompletion:(id)doneBlk{ iosLogInfo(\"session=%@, isUpdateRegToken=%s, doneBlk=%@\", session, boolToStr(isUpdateRegToken), doneBlk); gNoUse = 1; %orig; } 此时，加断点的地方，也不给%orig加断点了，而给新加的独立的一行加断点 如此，再去调试，以为就解决问题了 但是发现并没有，而是：问题依旧 难道是： 注意到了一个细节： 最开始，各种断点，都是可以正常显示的 包括普通代码简单的行的断点 和此处复杂的，带%orig的断点 但是后来触发过：汇编代码的断点 然后就回来找不到，不容易匹配到：源代码（.xm文件）中的断点了？ 那去试试： 把之前的2个汇编断点，临时禁用掉： 注：剩下断点全部都只是iOSOpenDev的Logos代码，.xm文件中的断点了 看看效果： 还真的可以了： 此处代码： 可以触发到了： - (void)performSameDeviceCheckForSession:(id)session updateRegistrationTokenIfNecessary:(_Bool)isUpdateRegToken withCompletion:(id)doneBlk{ iosLogInfo(\"session=%@, isUpdateRegToken=%s, doneBlk=%@\", session, boolToStr(isUpdateRegToken), doneBlk); gNoUse = 1; %orig; } 中的： gNoUse = 1; 这一行代码的断点了。 而没有显示文件类型错误 至此，再去恢复之前几个断点： 触发后续汇编代码： -》果然，就又出现之前问题了： 再触发过：断点，显示过 汇编代码后 再去触发断点，要显示.xm中的断点的代码时 .xm文件被识别为音频Audio 无法打开 之前再去切换过去： 源码方式显示 才能正常代码 且也没有显示 深蓝色的底色的断点的效果。 那此处，总不能不加断点，不显示汇编代码界面啊 所以此处暂时是：知道了原因，但是没有解决方案 另外，怀疑是： 此处.xm文件被误判为Audio音频文件 能否通过彻底： 去掉此处Xcode识别.xm为音频文件，而规避问题，让此处.xm直接显示源码，永远不显示Audio图标了？ 现在去找找 所以转去： 【未解决】Xcode中如何更改.xm文件默认文件类型为不是Audio音频文件改为Objc的C++源码文件 突然想到是： 前面的，显示汇编代码后 之前的，给.xm设置的文件类型ObjC的C++，就失效了，.xm就被识别为，默认的文件类型：Audio了 -》所以问题根源是： 为何，显示汇编代码后，就会冲突掉之前给.xm自定义设置的文件类型（ObjC的C++）？ 最终问题依旧，无法解决。 规避办法 后来在： 【未解决】iOS逆向WhatsApp：-[WAContext initWithDependencyInversion:] 期间，又遇到此问题 不过另外，摸索出一个，相对来说稍微快一点点的，不用切换到项目文件列表的，手动修复方式： 对于显示为空的内容，去点击右上角：显示文件属性： 点击 Type，切换一下 比如，从当前的Objective-C Source，切换成：Objective-C++ Source 此时即可以源码 源代码方式显示文件了： 此时，再去点击左边的 Thread的最新一行 == 函数调用堆栈中当前的代码： 即可，跳转代码到，触发断点的这一行。 总体虽然麻烦点，但还算能接受。 注：只能说是是规避办法，还是无法彻底解决。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-04 11:40:02 "},"dynamic_debug/xcode_debug/realtime_debug_hook_code/":{"url":"dynamic_debug/xcode_debug/realtime_debug_hook_code/","title":"实时调试hook代码","keywords":"","body":"实时调试hook代码 背景 想要调试iOS的程序：设置=Preferences 对于设备 iPhone8 A11，iOS 15.0，palera1n普通越狱 iPhone11 A12，iOS 15.1，XinaA15的rootless越狱 之前都没有很好的效果： frida 之前偶尔还能调试 现在始终会崩溃Process terminated Xcode调试 只能iPhone11中才能调试 但是也只是Attach上去调试，无法加hook代码的 但是又和iPhone8中的逻辑，未必完全对的上，因为iOS版本不完全一样（15.0和15.1） 需求 想要在Xcode中实时调试iOSOpenDev的hook插件代码 优点：Xcode中调试会比Frida稳定多了（不会经常崩溃退出） 具体步骤 新建iOSOpenDev的hook插件项目 具体可参考： 普通的插件开发流程 · iOS逆向开发：iOSOpenDev开发插件 (crifan.org) 确保完成基本的环境： 新建iOSOpenDev的Xcode项目 写hook代码 编译 安装插件 确认插件生效 Xcode中给代码加上断点 Xcode中，写好hook代码 %hook AAUISignInViewController - (void)_nextButtonSelected:(id)arg1{ %log; NSLog(@\"AAUISignInViewController _nextButtonSelected: %@\", arg1); return %orig; } 给代码加上断点： Attach挂载进程 先确保进程是可以被调试的 然后去Xcode中，挂载进程： 找到要被调试的二进制=服务=进程=此处的：Preferences 注，此处 其他方式都不行 Xcode->Debug->Attach to Process->Getting Process List 找不到Preferences的进程 Xcode->Debug->Attach to Process by PID or Name->PID or Process Name 用name也都不行 Preferences com.apple.Preferences 只好换：PID Xcode->Debug->Attach to Process by PID or Name->PID or Process Name 说明 PID的值：可以通过ssh的命令去查找到ps -A | grep Preferences 此处输出：iPhone11-151:~ root# ps -A | grep Preferences 72 ?? 0:00.15 /System/Library/PrivateFrameworks/NanoPreferencesSync.framework/nanoprefsyncd -companion 157 ?? 0:01.29 /System/Library/PrivateFrameworks/IntlPreferences.framework/Support/localizationswitcherd 1464 ?? 0:06.02 /Applications/Preferences.app/Preferences 1720 ttys000 0:00.01 grep Preferences 得到：Preferences的PID是：1464 显示 PID 和 Running了 -> 表示Attach上了： 触发断点 此处，去app中操作页面，触发到被hook的代码的逻辑 具体此处操作是：设置中点击登录的下一步，触发到此处代码逻辑 即可触发断点： 函数调用堆栈： (lldb) bt * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 2.1 * frame #0: 0x00000001077cfe60 jailAppleAccount.dylib`_logos_method$_ungrouped$AAUISignInViewController$_nextButtonSelected$(self=0x0000000107015610, _cmd=\"_nextButtonSelected:\", arg1=0x000000012100b280) at jailAppleAccount.xm:6:2 [opt] frame #1: 0x0000000183ba6bf0 UIKitCore`-[UIApplication sendAction:to:from:forEvent:] + 100 frame #2: 0x0000000183e85b80 UIKitCore`-[UIBarButtonItem _triggerActionForEvent:] + 180 frame #3: 0x0000000183e6f880 UIKitCore`__45-[_UIButtonBarTargetAction _invoke:forEvent:]_block_invoke + 40 frame #4: 0x0000000183e6f730 UIKitCore`-[_UIButtonBarTargetAction _invoke:forEvent:] + 204 frame #5: 0x0000000183ba6bf0 UIKitCore`-[UIApplication sendAction:to:from:forEvent:] + 100 frame #6: 0x0000000183cd2a4c UIKitCore`-[UIControl sendAction:to:forEvent:] + 128 frame #7: 0x0000000183a4e2c8 UIKitCore`-[UIControl _sendActionsForEvents:withEvent:] + 352 frame #8: 0x0000000183a4e318 UIKitCore`-[UIControl _sendActionsForEvents:withEvent:] + 432 frame #9: 0x0000000183d7d7c0 UIKitCore`-[UIControl touchesEnded:withEvent:] + 536 frame #10: 0x000000018385107c UIKitCore`-[UIWindow _sendTouchesForEvent:] + 980 frame #11: 0x0000000183882a84 UIKitCore`-[UIWindow sendEvent:] + 4456 frame #12: 0x0000000183a32318 UIKitCore`-[UIApplication sendEvent:] + 828 frame #13: 0x0000000183855c30 UIKitCore`__dispatchPreprocessedEventFromEventQueue + 7904 frame #14: 0x000000018384aa1c UIKitCore`__processEventQueue + 6760 frame #15: 0x000000018384fec8 UIKitCore`__eventFetcherSourceCallback + 172 frame #16: 0x00000001812f3020 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 28 frame #17: 0x0000000181303ce0 CoreFoundation`__CFRunLoopDoSource0 + 208 frame #18: 0x000000018123dfe8 CoreFoundation`__CFRunLoopDoSources0 + 268 frame #19: 0x00000001812437f4 CoreFoundation`__CFRunLoopRun + 820 frame #20: 0x00000001812573b8 CoreFoundation`CFRunLoopRunSpecific + 600 frame #21: 0x000000019cbe738c GraphicsServices`GSEventRunModal + 164 frame #22: 0x0000000183bf76a8 UIKitCore`-[UIApplication _run] + 1100 frame #23: 0x00000001839767f4 UIKitCore`UIApplicationMain + 2092 frame #24: 0x000000010489cc0c Preferences`___lldb_unnamed_symbol132$$Preferences + 60 frame #25: 0x00000001049d5a24 dyld`start + 520 如此，即可愉快的： 用Xcode+iOSOpenDev，去实时的动态的调试iOS的app的代码逻辑了。 总体效果： 虽然有点麻烦： 每次改动插件代码后： 不能像MonkeyDev那么直接启动调试 而是要：重新编译并安装插件，再去Attach，才能调试 但是UI界面的调试，比之前的： 没有插件代码 只有frida的js脚本 且很容易崩溃 的效率要高多了 总结 此处目前是： iPhone11 iOS 15.1 XinaA15越狱 其自动重签名了debugserver，使得Xcode可以Attach挂载调试任意进程 可以去： Xcode+iOSOpenDev编译安装deb插件到iPhone11 手动启动Preferences设置后，Xcode去Attach挂载到Preferences的进程 在PID or Process Name中输入：PID值 设置页面中，正常去操作： 输入账号，点击下一步按钮 -》最终可以触发到Xcode中插件的hook代码的断点的 -》后续可以进一步去调试逻辑了。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-27 09:45:07 "},"dynamic_debug/lldb/":{"url":"dynamic_debug/lldb/","title":"LLDB","keywords":"","body":"LLDB crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-03 10:34:44 "},"dynamic_debug/lldb/regex_find/":{"url":"dynamic_debug/lldb/regex_find/","title":"正则搜索","keywords":"","body":"正则搜索 lldb用正则查找函数时记得要转义特殊字符 现象 此处lldb去搜，本身存在的函数名=符号名： +[FIRAnalytics sharedInstance]_51_block 但是却搜不到： (lldb) im loo -rn \"+[FIRAnalytics sharedInstance]_51_block\" (lldb) 原因 此处用r=regex=正则的方式去搜索，所以字符串中： 加号=+ 中括号= [] 都是：正则中特殊的字符 所以此处把正则字符串当做普通字符去搜索，导致含义不对，所以搜不到 解决办法 如果要使用普通字符，则应该加上反斜杠转义 im loo -rn \"\\+\\[FIRAnalytics sharedInstance\\]_51_block\" 即可搜到： (lldb) im loo -rn \"\\+\\[FIRAnalytics sharedInstance\\]_51_block\" 1 match found in /private/var/containers/Bundle/Application/4BD12EFB-0A75-49DC-8059-EBCDCF21522D/WhatsApp.app/Frameworks/SharedModules.framework/SharedModules: Address: SharedModules[0x0000000000b8f7c8] (SharedModules.__TEXT.__text + 12096916) Summary: SharedModules`+[FIRAnalytics sharedInstance]_51_block crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-03 11:48:00 "},"dynamic_debug/iosopendev/":{"url":"dynamic_debug/iosopendev/","title":"iOSOpenDev","keywords":"","body":"iOSOpenDev crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-02-26 09:38:47 "},"mach_o/":{"url":"mach_o/","title":"Mach-O","keywords":"","body":"Mach-O crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-03 10:03:15 "},"mach_o/image_base.html":{"url":"mach_o/image_base.html","title":"image base基地址","keywords":"","body":"Mach-O 虚拟地址基地址 Mach-O的vmaddr=image base 说明 restore-symbol调试时看到的：vmaddr=虚拟地址=虚拟地址基地址 IDA中的：image base=镜像地址基地址=镜像基地址 多种查看方式 MachOView restore-symbol调试时：__TEXT的Segment的vmaddr rabin2rabin2 -I machoFile identification信息中的：baddrrabin2 -S machoFile sections信息中的：__TEXT.__text的vaddr减去paddr后的值 jtool2jtool2 -l macoFile list中的：__TEXT中的Mem的起始地址 otoolotool -l machoFile 中的：__TEXT的Segment的vmaddr 举例 可以用相关工具，辅助验证基地址： WhatsApp WhatsApp的vmaddr=image base：0x100000000 MachOView restore-symbol调试时：__TEXT的Segment的vmaddr rabin2 rabin2 -I machoFile identification信息中的：baddr baddr 0x100000000 rabin2 -S machoFile sections信息中的：TEXT.text的vaddr减去paddr后的值 0 0x000062f0 0x249229c 0x1000062f0 0x249229c -r-x REGULAR 0.__TEXT.__text 0x1000062f0 - 0x000062f0 = 0x100000000 jtool2 jtool2 -l macoFile list中的：__TEXT中的Mem的起始地址 LC 01: LC_SEGMENT_64 Mem: 0x100000000-0x102eb0000 __TEXT otool otool -l machoFile 中的：__TEXT的Segment的vmaddr segname __TEXT vmaddr 0x0000000100000000 SharedModules SharedModules的vmaddr=image base：0x0 MachOView rabin2 rabin2 -I machoFile identification信息中的：baddr baddr 0x0 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-03 10:06:04 "},"log/":{"url":"log/","title":"log日志","keywords":"","body":"log日志 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-02-26 09:38:47 "},"log/large_1k_log.html":{"url":"log/large_1k_log.html","title":"超过1K的日志打印","keywords":"","body":"超过1K的日志打印 os_log打印超过1K的长字符串会省略截断掉 解决办法： 输出到文件 【未解决】iOS逆向Apple账号：通过插件hook去打印AADeviceInfo的类的相关信息 【已解决】iOS中如何用ObjC保存数据到文件 转成数组多次打印 【已解决】iOS逆向：os_log日志字符串内容太长超过限制时拆分字符串多次打印 【已解决】iOS的ObjC中NSString如何按照长度拆分 【已解决】iOS的ObjC中如何初始化NSString多行字符串 【已解决】iOS的ObjC的NSString多行字符串中如何包含换行符 转成数组多次打印 代码 // os_log max length 1K=1024 // int LOG_MAX_LEN_ONCE = 1024; //int LOG_MAX_LEN_ONCE = 1024 - 20; //int LOG_MAX_LEN_ONCE = 1024 - 50; //int LOG_MAX_LEN_ONCE = 1024 - 100; //int LOG_MAX_LEN_ONCE = 1024 - 200; int LOG_MAX_LEN_ONCE = 1024 - 150; void logLargeStr(NSString* largeStr); void logPossibleLargeStr(NSString* possibleLargeStr); // log for large (> 10124) string void logLargeStr(NSString* largeStr){ // NSMutableArray* splitedLineArr = splitToLines(largeStr, LOG_MAX_LEN_ONCE); NSMutableArray* splitedLineArr = [CrifanLibiOS splitToLines:largeStr maxLenPerLine:LOG_MAX_LEN_ONCE]; for(int lineIdx = 0; lineIdx LOG_MAX_LEN_ONCE){ // iosLogInfo(\"%@\", @\"log_for_large_str:\"); logLargeStr(possibleLargeStr); } else { // iosLogInfo(\"%@\", @\"log_for_normal_str:\"); iosLogInfo(\"%{public}@\", possibleLargeStr); } } ... %hook NSMutableURLRequest ... -(id)allHTTPHeaderFields{ // NSDictionary allHeaderDict = %orig; id allHeaderDict = %orig; NSURL *reqUrl = [self URL]; // if ((allHeaderDict != nil) && ([[allHeaderDict allKeys] count])) { if (nonEmptyHeader(allHeaderDict)){ if( [allHeaderDict count] > 3){ // iosLogInfo(\"allHeaderDict=%{public}@ : reqUrl=%{public}@\", allHeaderDict, reqUrl); // NSString* headerUrlNSStr = [NSString initWithFormat:@\"reqUrl=%{public}@, allHeaderDict=%{public}@\", reqUrl, allHeaderDict] // NSString* headerUrlNSStr = [NSString stringWithFormat:@\"reqUrl=%{public}@, allHeaderDict=%{public}@\", reqUrl, allHeaderDict]; // NSString* headerUrlNSStr = [NSString stringWithFormat:@\"reqUrl=%@, allHeaderDict=%@\", reqUrl, allHeaderDict]; NSString* headerUrlNSStr = [NSString stringWithFormat:@\"NSMutableURLRequest:allHTTPHeaderFields reqUrl=%@, allHeaderDict=%@\", reqUrl, allHeaderDict]; logPossibleLargeStr(headerUrlNSStr); gNoUse = 1; } } return allHeaderDict; } ... %hook NSURLRequest ... // iosLogInfo(\"allHeaderDict=%{public}@ : reqUrl=%{public}@\", allHeaderDict, reqUrl); NSString* reqHeaderUrlStr = [NSString stringWithFormat:@\"NSURLRequest:allHTTPHeaderFields allHeaderDict=%@ : reqUrl=%@\", allHeaderDict, reqUrl]; logPossibleLargeStr(reqHeaderUrlStr); ... %hook NSHTTPURLResponse ... -(NSDictionary *)allHeaderFields{ NSURL* curUrl = [self URL]; NSDictionary* allHeader = %orig; // iosLogInfo(\"curUrl=%{public}@ : allHeader=%{public}@\", curUrl, allHeader); NSString* respUrlHeaderStr = [NSString stringWithFormat:@\"NSHTTPURLResponse:allHeaderFields curUrl=%@ : allHeader=%@\", curUrl, allHeader]; logPossibleLargeStr(respUrlHeaderStr); return allHeader; } ... 最后实现： 之前没显示全的 最末尾 如果是变量，有时候是显示： 如果是字符串，往往显示： 举例 \"X-MMe-Client-Info\" = \" 输出举例 之前是： reqUrl= 默认 16:59:51.205223+0800 Preferences hook_reqResp.xm NSMutableURLRequest$allHTTPHeaderFields: allHeaderDict={type = mutable dict, count = 17, entries => 0 : X-Apple-I-MD-RINFO = 50660608 1 : X-MMe-FMFAllowed = {contents = \"true\"} 3 : Authorization = {contents = \"Basic MTk1MDg0OTk2M...UHB3PT0=\"} 6 : X-Apple-Family-GS-Token = {contents = \"MTk1MDg...0Mm9ke : reqUrl= 现在可以： 显示出多行： 默认 17:28:02.211309+0800 Preferences hook_reqResp.xm logPossibleLargeStr: NSURLRequest:allHTTPHeaderFields allHeaderDict={ Accept = \"*/*\"; \"Accept-Encoding\" = \"gzip, deflate, br\"; \"Accept-Language\" = \"zh-CN,zh-Hans\"; Authorization = \"Basic MTk1M...BPT0=\"; \"X-Apple-ADSID\" = \"001757-05-c...5-8..8-4..f-b..6-7e...ea\"; \"X-MMe-Client-Info\" = \" \"; \"X-MMe-Country\" = CN; \"X-MMe-Language\" = \"zh-Hans-CN\"; } : reqUrl=https://setup.icloud.com/setup/account/getPhoto 默认 17:28:02.216624+0800 Preferences hook_reqResp.xm logLargeStr: [0] NSHTTPURLResponse:allHeaderFields curUrl=https://bag.itunes.apple.com/bag.xml?deviceClass=iPhone&format=json&os=iOS&osVersion=15.0&product=com.apple.Preferences&productVersion=1&profile=VideoSubscriberAccount&profileVersion=1&storefront=143441-19,29 : allHeader={ \"Accept-Ranges\" = bytes; Age = 33; \"Cache-Control\" = \"max-age=1800, no-transform\"; \"Content-Encoding\" = gzip; \"Content-Length\" = 3491; \"Content-Type\" = \"application/json\"; Date = \"Mon, 05 Jun 2023 08:59:43 GMT\"; \"Last-Modified\" = \"Sat, 03 Jun 2023 16:47:49 GMT\"; Server = \"QTL_Cache/1.2.14\"; \"Strict-Transport-Security\" = \"max-age=31536000; includeSubDomains\"; \"apple-originating-system\" = MZInit2; \"apple-seq\" = \"0.0\"; \"apple-timing-app\" = \"7 ms\"; \"apple-tk\" = false; b3 = \"20...8-e6...15c\"; \"x-apple-applicatio 默认 17:28:02.216727+0800 Preferences hook_reqResp.xm logLargeStr: [1] n-instance\" = 10001; \"x-apple-application-site\" = PV00; \"x-apple-jingle-correlation-key\" = ED...A; \"x-apple-max-age\" = 1800; \"x-apple-request-store-front\" = \"143441-19,29\"; \"x-apple-request-uuid\" = \"2...f-1cbf-5b7c-7..2-a8...8\"; \"x-b3-spanid\" = e6...5c; \"x-b3-traceid\" = 20...c8; \"x-cache\" = \"REVALIDATED from NGCDN\"; \"x-cache-status\" = REVALIDATED; \"x-daiquiri-instance\" = \"daiquiri:10001:daiquiri-all-shared-dc-5..6-qn2wb:7..:23..81:daiquiri-amp-kubernetes-shared-dc-ak8s-prod-pv1-amp-daiquiri-ingress-prod, daiquiri:51..4:pv00p00it-az..ext003:7..:23..81:daiquiri-amp-aws-shared-ext-pv00-prod\"; \"x-qtl-request-id\" = 60...c; \"x-responding-instance\" = \"MZInit2:10001:::\"; \"x-via\" = \"1.1 as-cn-fjxmcm8-cache 而没有超过1K限制的，就只显示一行： 默认 17:28:02.209465+0800 Preferences hook_reqResp.xm logPossibleLargeStr: NSURLRequest:allHTTPHeaderFields allHeaderDict={ \"Accept-Language\" = \"zh-CN,zh-Hans\"; Authorization = \"Basic MTk...PT0=\"; \"X-Apple-ADSID\" = \"0...7-05-c...5-8d38-467f-b2c6-7...ea\"; \"X-MMe-Client-Info\" = \" \"; \"X-MMe-Country\" = CN; \"X-MMe-Language\" = \"zh-Hans-CN\"; } : reqUrl=https://setup.icloud.com/setup/account/getPhoto crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-26 22:47:38 "},"headers/":{"url":"headers/","title":"头文件","keywords":"","body":"头文件 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-02-26 09:38:47 "},"headers/try_diff_version.html":{"url":"headers/try_diff_version.html","title":"试试新旧不同版本","keywords":"","body":"试试新旧不同版本 iOS逆向心得：新版导出头文件是空时，可以试试旧版本或许可以导出有价值的类的定义 比如抖音的逆向 之前旧版本：17.8.0 后来新版本，比如：18.9.0 其中都是去做了： 砸壳得到ipa，从ipa的二进制去用class-dump导出头文件 结果发现，虽然导出的头文件中的文件个数，类名，基本没变化 但是： 旧版：往往都能看到类的细节 Aweme_classDump/Aweme_17.8.0_header/Aweme/AWESearchUser.h 新版：看不到任何类的细节 Aweme_classDump/Aweme_18.9.0_header/AwemeCore/AWESearchUser.h -》由此反推： 抖音的新版本，做了更强的反破解的逻辑 使得class-dump导出头文件，虽然有类，但类的定义（属性、函数等）都是空的 -》以及平时调试期间，更多的可以去： 使用（导出了更多的类的属性、函数等细节的）旧版本 作为调试的依旧，毕竟新版本很多类的信息都是空，无从下手 -》总之，核心思路是： 需要时，除了新版本外，也去试试，旧版本的，导出的头文件，有利于找到更多有价值的资料和思路，提高逆向分析和调试的效率 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-05 10:03:58 "},"capture/":{"url":"capture/","title":"抓包","keywords":"","body":"抓包 可以自己搭建服务器抓包 举例，别人的： 抓包的时候可以自己搭建服务器，用于嗅探记录，拦截请求数据包，或者叫转发数据号，记录当前传入和传出的参数，也就是请求和响应的各种参数记录下来，类似于这种效果： --- 机器参数. -- @table rfaker -- @string name 设备名称 e.g. \"“xxx”的 iPhone\" -- @string hw_machine_name e.g. \"iPhone 11 Pro Max\" -- @string ssid e.g. \"TP_LINK_E-BoJingEr-557-OFFICE\" -- @tparam integer create_time e.g. 创建时间 1654709286 -- @string locale_identifier e.g. \"CN\" -- @string remark 备注 e.g. null -- @number lon e.g. 123.98118244667 -- @string app_times e.g. null -- @string network_state e.g. \"WIFI\" -- @string localtion e.g. null -- @string idfa e.g. \"91566BBD-C5E6-48B0-85CA-6E0C68663F69\" -- @string hw_machine e.g. \"iPhone12,5\" -- @string carrier_name e.g. \"数码通\" -- @string build_version e.g. \"18G82\" -- @string system_version e.g. \"14.7.1\" -- @number lat e.g. 33.814002430383 -- @string current_radioaccess_technology e.g. \"CTRadioAccessTechnologyLTE\" -- @string mobile_network_code e.g. \"06\" --- 当前参数. -- @function faker -- @apiget http://127.0.0.1:1688/api/v1/machine/faker -- @treturn rfaker 返回当前工作参数 -- @usage -- -- 返回结果如:(json) -- { -- \"name\":\"“xxx”的 iPhone\", -- \"hw_machine_name\":\"iPhone 11 Pro Max\", -- \"ssid\":\"TP_LINK_E-BoJingEr-557-OFFICE\", -- \"create_time\":1654709286, -- \"locale_identifier\":\"CN\", -- \"remark\":null, -- \"lon\":123.98118244667, -- \"app_times\":null, -- \"network_state\":\"WIFI\", -- \"localtion\":null, -- \"idfa\":\"91566BBD-C5E6-48B0-85CA-6E0C68663F69\", -- \"hw_machine\":\"iPhone12,5\", -- \"carrier_name\":\"数码通\", -- \"build_version\":\"18G82\", -- \"system_version\":\"14.7.1\", -- \"lat\":33.814002430383, -- \"current_radioaccess_technology\":\"CTRadioAccessTechnologyLTE\", -- \"mobile_network_code\":\"06\" -- } crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-03-05 22:29:59 "},"capture/request_response.html":{"url":"capture/request_response.html","title":"request和response","keywords":"","body":"request和response 概述： 调试网络信息：request和response 如果Charles抓包抓不到详情，可以考虑写插件hook代码实现 举例 Apple账号登录过程，抓包失败 【未解决】iOS逆向Apple账号：用Charles抓包signin/v2/login的请求和响应的详情数据 【未解决】Mac中Charles抓包：https请求始终只是显示CONNECT无法查看到详情数据 后来转去用之前的插件hook代码 主要hook的点是： request NSMutableURLRequest -[NSMutableURLRequest allHTTPHeaderFields] -[NSMutableURLRequest addValue:forHTTPHeaderField:] -[NSMutableURLRequest setValue:forHTTPHeaderField:] -[NSMutableURLRequest setAllHTTPHeaderFields:] -[NSMutableURLRequest setHTTPBody:] NSURLRequest +[NSURLRequest requestWithURL:] +[NSURLRequest requestWithURL:cachePolicy:timeoutInterval:] -[NSURLRequest initWithURL:] -[NSURLRequest initWithURL:cachePolicy:timeoutInterval:] -[NSURLRequest allHTTPHeaderFields] response NSHTTPURLResponse -[NSHTTPURLResponse initWithURL：] -[NSHTTPURLResponse allHeaderFields] -[NSHTTPURLResponse initWithURL:statusCode:HTTPVersion:headerFields:] -[NSHTTPURLResponse statusCode] 如果Charles抓包抓不到详情，可以考虑写用frida去hook打印 TODO：去试试效果，把结果整理过来 详解： 写插件hook代码 代码 /*============================================================================== Request ==============================================================================*/ /*------------------------------------------------------------------------------ NSMutableURLRequest ------------------------------------------------------------------------------*/ %hook NSMutableURLRequest -(void)setHTTPBody:(NSData *)bodyData{ // iosLogInfo(\"bodyData=%@\", bodyData); NSURL *reqUrl = [self URL]; iosLogInfo(\"reqUrl=%{public}@: bodyData=%{public}@\", reqUrl, bodyData); return %orig; } //-(NSDictionary)*allHTTPHeaderFields{ //-(NSDictionary)allHTTPHeaderFields{ -(id)allHTTPHeaderFields{ // NSDictionary allHeaderDict = %orig; id allHeaderDict = %orig; NSURL *reqUrl = [self URL]; // if ((allHeaderDict != nil) && ([[allHeaderDict allKeys] count])) { if (nonEmptyHeader(allHeaderDict)){ if( [allHeaderDict count] > 3){ // iosLogInfo(\"allHeaderDict=%{public}@ : reqUrl=%{public}@\", allHeaderDict, reqUrl); // NSString* headerUrlNSStr = [NSString initWithFormat:@\"reqUrl=%{public}@, allHeaderDict=%{public}@\", reqUrl, allHeaderDict] // NSString* headerUrlNSStr = [NSString stringWithFormat:@\"reqUrl=%{public}@, allHeaderDict=%{public}@\", reqUrl, allHeaderDict]; // NSString* headerUrlNSStr = [NSString stringWithFormat:@\"reqUrl=%@, allHeaderDict=%@\", reqUrl, allHeaderDict]; NSString* headerUrlNSStr = [NSString stringWithFormat:@\"NSMutableURLRequest:allHTTPHeaderFields reqUrl=%@, allHeaderDict=%@\", reqUrl, allHeaderDict]; logPossibleLargeStr(headerUrlNSStr); gNoUse = 1; } } return allHeaderDict; } - (void)addValue:(NSString *)value forHTTPHeaderField:(NSString *)field{ NSURL *reqUrl = [self URL]; iosLogInfo(\"field=%{public}@, value=%{public}@ : reqUrl=%{public}@\", field, value, reqUrl); %orig; } - (void)setValue:(NSString *)value forHTTPHeaderField:(NSString *)field{ NSURL *reqUrl = [self URL]; iosLogInfo(\"field=%{public}@, value=%{public}@ : reqUrl=%{public}@\", field, value, reqUrl); %orig; } - (void) setAllHTTPHeaderFields:(id)newAllHeaders{ NSURL *reqUrl = [self URL]; iosLogInfo(\"newAllHeaders=%{public}@ : reqUrl=%{public}@\", newAllHeaders, reqUrl); %orig; } %end /*------------------------------------------------------------------------------ NSURLRequest ------------------------------------------------------------------------------*/ %hook NSURLRequest + (instancetype)requestWithURL:(NSURL *)URL cachePolicy:(NSURLRequestCachePolicy)cachePolicy timeoutInterval:(NSTimeInterval)timeoutInterval{ NSLog(@\"jailAppleAccount requestWithURL: URL=%@, cachePolicy=%lu, timeoutInterval=%f\", URL, (unsigned long)cachePolicy, timeoutInterval); return %orig; } + (instancetype)requestWithURL:(NSURL *)URL{ NSLog(@\"jailAppleAccount requestWithURL: URL=%@\", URL); return %orig; } - (instancetype)initWithURL:(NSURL *)URL{ NSLog(@\"jailAppleAccount initWithURL: URL=%@\", URL); return %orig; } - (instancetype)initWithURL:(NSURL *)URL cachePolicy:(NSURLRequestCachePolicy)cachePolicy timeoutInterval:(NSTimeInterval)timeoutInterval{ NSLog(@\"jailAppleAccount initWithURL: URL=%@, cachePolicy=%lu, timeoutInterval=%f\", URL, (unsigned long)cachePolicy, timeoutInterval); return %orig; } -(NSDictionary*)allHTTPHeaderFields{ NSDictionary* allHeaderDict = %orig; NSURL *reqUrl = [self URL]; // if ((allHeaderDict != nil) && ([[allHeaderDict allKeys] count])) { if (nonEmptyHeader(allHeaderDict)){ if( [allHeaderDict count] > 3){ // iosLogInfo(\"allHeaderDict=%{public}@ : reqUrl=%{public}@\", allHeaderDict, reqUrl); NSString* reqHeaderUrlStr = [NSString stringWithFormat:@\"NSURLRequest:allHTTPHeaderFields reqUrl=%@, allHeaderDict=%@\", reqUrl, allHeaderDict]; logPossibleLargeStr(reqHeaderUrlStr); gNoUse = 1; } } return allHeaderDict; } /*============================================================================== Response ==============================================================================*/ /*------------------------------------------------------------------------------ NSHTTPURLResponse ------------------------------------------------------------------------------*/ %hook NSHTTPURLResponse - (NSHTTPURLResponse*)initWithURL:(NSURL *)url statusCode:(NSInteger)statusCode HTTPVersion:(NSString *)HTTPVersion headerFields:(NSDictionary *)headerFields{ NSHTTPURLResponse* newUrlResp = %orig; iosLogInfo(\"url=%{public}@,statusCode=%ld,HTTPVersion=%@,headerFields=%{public}@ -> newUrlResp=%{public}@\", url, statusCode, HTTPVersion, headerFields, newUrlResp); return newUrlResp; } -(NSDictionary *)allHeaderFields{ NSURL* curUrl = [self URL]; NSDictionary* allHeader = %orig; // iosLogInfo(\"curUrl=%{public}@ : allHeader=%{public}@\", curUrl, allHeader); NSString* respUrlHeaderStr = [NSString stringWithFormat:@\"NSHTTPURLResponse:allHeaderFields curUrl=%@ : allHeader=%@\", curUrl, allHeader]; logPossibleLargeStr(respUrlHeaderStr); return allHeader; } -(NSInteger)statusCode{ NSURL* curUrl = [self URL]; NSInteger respStatusCode = %orig; iosLogInfo(\"respStatusCode=%ld : curUrl=%{public}@\", respStatusCode, curUrl); return respStatusCode; } %end 输出 https://setup.icloud.com/setup/signin/v2/login request headers Accept = \"/\"; \"Accept-Encoding\" = \"gzip, deflate, br\"; \"Accept-Language\" = \"zh-CN,zh-Hans\"; Authorization = \"Basic YWRtaW5AY3JpZm...3NjRlRrUzB0dW0wc0Nwang2RURMTjRpbz1QRVQ=\"; \"Content-Length\" = 694; \"Content-Type\" = \"application/xml\"; \"Device-UDID\" = abdc0dd...8433a; \"X-Apple-I-Device-Configuration-Mode\" = 0; \"X-MMe-Client-Info\" = \" \"; \"X-MMe-Country\" = CN; \"X-MMe-Language\" = \"zh-Hans-CN\"; \"X-Mme-Device-Id\" = abdc0dd...8433a; response headers \"Apple-Originating-System\" = UnknownOriginatingSystem; \"Cache-Control\" = \"no-cache, no-store, private\"; Connection = \"keep-alive\"; \"Content-Encoding\" = gzip; \"Content-Length\" = 4213; \"Content-Type\" = \"application/xml; charset=UTF-8\"; Date = \"Mon, 05 Jun 2023 09:44:17 GMT\"; Server = \"AppleHttpServer/3faf4ee9434b\"; \"Set-Cookie\" = \"show-china-terms=false;Expires=Thu, 01-Jan-1970 00:00:01 GMT;Path=/setup;HttpOnly\"; \"Strict-Transport-Security\" = \"max-age=31536000; includeSubDomains\"; Via = \"63119...319:8ef2...35a6b:hktko1\"; \"X-Apple-Edge-Response-Time\" = 3589; \"X-Apple-Jingle-Correlation-Key\" = 4QJS...P4; \"X-Apple-Request-UUID\" = \"e4132a7d-b..0-4..e-8..f-6387...7f\"; \"X-Responding-Instance\" = \"setupservice:45100103:pv43p51ic-zteg06100801:8003:2316B377:36c327430fe1\"; \"access-control-expose-headers\" = \"X-Apple-Request-UUID,Via\"; \"apple-seq\" = 0; \"apple-tk\" = false; \"x-apple-user-partition\" = 51; crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-27 09:48:59 "},"tweak_plugin/":{"url":"tweak_plugin/","title":"tweak插件","keywords":"","body":"tweak插件 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-02-26 09:38:47 "},"crash/":{"url":"crash/","title":"crash崩溃","keywords":"","body":"crash崩溃 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-04 12:08:50 "},"crash/parse_tool.html":{"url":"crash/parse_tool.html","title":"崩溃日志解析工具","keywords":"","body":"崩溃日志解析工具 iOS（和Mac）崩溃日志解析工具 通用？ atos = address to symbol iOS 15之前： symbolicatecrash iOS 15之后： CrashSymbolicator.py 位置：（Xcode中？） Contents/SharedFrameworks/CoreSymbolicationDT.framework/Resources/ /Applications/Xcode.app/Contents/SharedFrameworks/CoreSymbolicationDT.framework/Versions/A/Resources 用法：python3 CrashSymbolicator.py -d /dSYMs -o /xxxSymbo.crash -p /xxxCrash.ips crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-04 12:10:30 "},"crash/find_crash_location.html":{"url":"crash/find_crash_location.html","title":"从崩溃信息找崩溃所在位置","keywords":"","body":"从崩溃信息找崩溃所在位置 从XCode崩溃的地址寻找所属二进制的代码段和函数位置 此处XCode调试抖音ipa崩溃时： 获取崩溃时的函数地址 方式1：通过XCode自动解析iPhone中的崩溃日志 细节：抖音ipa运行崩溃时，从iPhone中得到的ips崩溃日志 或 XCode-》Window-》Device and Simulator-》Device Log中，找到的崩溃时的函数调用堆栈 方式2：通过bt (lldb) bt * thread #9, queue = 'NSOperationQueue 0x119653070 (QOS: USER_INTERACTIVE)', stop reason = signal SIGABRT ... frame #11: 0x000000010b07a1dc AwemeCore`___lldb_unnamed_symbol2502$$AwemeCore + 60 -》得到的地址： 0x000000010b07a1dc 从地址中反推寻找对应所属二进制和代码的位置 方式1：借用image lookup自动计算 image lookup -a 地址 举例： (lldb) image lookup -a 0x000000010b41a1dc Address: AwemeCore[0x00000000059961dc] (AwemeCore.__BD_TEXT.__text + 467420) Summary: AwemeCore`___lldb_unnamed_symbol2502$$AwemeCore + 60 -》所属代码是： 所属二级制文件：AwemeCore 区域：Text段 函数起始地址：0x00000000059961dc ？ 函数内偏移地址：467420 = 0x721DC 详见： 【已解决】lldb命令使用心得：image lookup 官网资料： Symbolication — The LLDB Debugger (llvm.org) 方式2：自己手动计算 (lldb) bt ... frame #11: 0x000000010b07a1dc AwemeCore`___lldb_unnamed_symbol2502$$AwemeCore + 60 思路： 用image list -o -f得到二进制起始地址=ALSR 再去手动计算： 函数偏移地址 = 当前地址 - 二进制ALSR 举例： (lldb) image list -o -f ... [ 2] 0x00000001056e4000 /Users/crifan/Library/Developer/Xcode/DerivedData/Aweme-ejnpzdlejfueeaffwupnpxokcaoj/Build/Products/Debug-iphoneos/Aweme.app/Frameworks/AwemeCore.framework/AwemeCore -》得知： AwemeCore的ALSR=起始地址=0x00000001056e4000 -> 0x000000010b07a1dc - 0x00000001056e4000 = 0x59961DC crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-04 12:09:16 "},"common/":{"url":"common/","title":"通用","keywords":"","body":"通用 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-02-26 09:38:47 "},"common/understand_asm_logic.html":{"url":"common/understand_asm_logic.html","title":"从汇编反推代码逻辑","keywords":"","body":"从汇编反推代码逻辑 iOS逆向期间，对于（静态分析或动态调试）ARM汇编代码时，直接看ARM汇编代码，肯定是很难搞定代码逻辑的，尤其是代码很多的时候。 但是，如果熟悉ARM汇编指令本身，和一些常见的逻辑，则可以： 对于部分简单的逻辑，还是能看出来的 此处以具体例子来解释说明 对于Xcode去调试iOS的ObjC函数： AppleAccount`-[NSMutableURLRequest(AppleAccount) aa_addBasicAuthorizationHeaderWithAccount:preferUsingPassword:]: -> 0x1925a95a8 : sub sp, sp, #0xa0 0x1925a95ac : stp x26, x25, [sp, #0x50] 0x1925a95b0 : stp x24, x23, [sp, #0x60] 0x1925a95b4 : stp x22, x21, [sp, #0x70] 0x1925a95b8 : stp x20, x19, [sp, #0x80] 0x1925a95bc : stp x29, x30, [sp, #0x90] 0x1925a95c0 : add x29, sp, #0x90 0x1925a95c4 : mov x21, x3 0x1925a95c8 : mov x20, x0 0x1925a95cc : mov x0, x2 0x1925a95d0 : bl 0x197c06830 ; objc_retain 0x1925a95d4 : mov x19, x0 0x1925a95d8 : cbz x0, 0x1925a9ac4 ; 0x1925a95dc : tbz w21, #0x0, 0x1925a96e0 ; 0x1925a95e0 : adrp x8, 36933 0x1925a95e4 : add x21, x8, #0x544 0x1925a95e8 : mov x0, x19 0x1925a95ec : mov x1, x21 0x1925a95f0 : bl 0x197c05000 ; objc_msgSend 0x1925a95f4 : mov x29, x29 0x1925a95f8 : bl 0x197c07f60 ; objc_retainAutoreleasedReturnValue 0x1925a95fc : mov x23, x0 ... 0x1925a96e0 : adrp x8, 38984 0x1925a96e4 : add x21, x8, #0x138 0x1925a96e8 : mov x0, x19 0x1925a96ec : mov x1, x21 0x1925a96f0 : bl 0x197c05000 ; objc_msgSend 先分别介绍，局部的，部分的，ARM汇编代码，对应的原始的ObjC的代码的逻辑。 介绍具体逻辑之前，先贴出传入参数： (lldb) reg r x0 x1 x2 x3 x0 = 0x0000000282da0150 x1 = 0x000000019bc11ada x2 = 0x00000002816b6920 x3 = 0x0000000000000001 (lldb) po 0x0000000282da0150 { URL: https://setup.icloud.com/setup/signin/v2/login } (lldb) po (char*)0x000000019bc11ada \"aa_addBasicAuthorizationHeaderWithAccount:preferUsingPassword:\" (lldb) po 0x00000002816b6920 xxx@yyy.zzz (0F...-655A-4DE7-9CEE-A3...7) (lldb) po [0x00000002816b6920 class] ACAccount (lldb) po (bool)0x0000000000000001 true 其对应着，iOS中ObjC代码的调用： objc_msgSend( { URL: https://setup.icloud.com/setup/signin/v2/login }, \"aa_addBasicAuthorizationHeaderWithAccount:preferUsingPassword:\", true ) 其中的： 0x1925a95c4 : mov x21, x3 0x1925a95c8 : mov x20, x0 是去保存传入的参数： x3 = x21 = 0x1 = true x0 = x20 = { URL: https://setup.icloud.com/setup/signin/v2/login } 0x1925a95cc : mov x0, x2 意思是： x0 = x2 = 0x1925a95d0 : bl 0x197c06830 ; objc_retain 0x1925a95d4 : mov x19, x0 意思是： objc_retain() => x0 = x19 = retain后的ACAccount -》原始代码逻辑，暂时可以写成类似的意思： curACAccount = objc_retain(inputACAccount) 尤其是，下面这句： 0x1925a95d8 : cbz x0, 0x1925a9ac4 ; 其实容易看出是： cbz = Compare and Branch on Zero = 去比较，如果是0，就跳转 此处意思是： 去比较x0=retain后的ACAccount，即传入的参数ACAccount，是否是0，如果是，则就跳转 -》则此时，就容易反推出，原始的（iOS的ObjC）代码的逻辑，就是： 去判断传入参数ACAccount，是否是空 -》写成伪代码，C代码，就类似于： curACAccount = objc_retain(inputACAccount) if (curACAccount) { // next line = : do normal process account } else { // : report error or some other process } 类似的，IDA Pro (v7.7)中，反编译后的代码=伪代码，也是类似的写法： 如此，就可以： 一点点反推出，原始代码的逻辑和含义了。 而其实可以继续分析原始代码逻辑： 0x1925a95dc : tbz w21, #0x0, 0x1925a96e0 ; ARM汇编代码本意： tbz=TBZ=Test bit and Branch if Zero = 测试某个位，看看是否是0，如果是0，就跳转 注：此处突然明白，此处也是去判断 某个内容，是否为0，为何没用上面的： cbz = Compare and Branch on Zero 而非要用另外一个汇编指令： tbz=TBZ=Test bit and Branch if Zero 其中的区别点在于： cbz是Compare，普通的内容 tbz=Test bit，是测试比较某个bit位 对应着此处代码中，用的寄存器是w21 根据之前经验，X是64位寄存器写法，比如X21 而如果改用w的32位寄存器写法，则往往意味着：此时的原始代码变量是个bool布尔变量了 bool变量的底层实现，就可以：只用1个bit位，即可表示 所以此处用tbz，而不是用cbz 所以，此处w21 = 是个bool变量 = 前面的x21 = x3 = 传入参数的：0x1=true 所以此处含义就是： if(inputPreferUsingPassword) { // next line=: some logic like: login using password } else { // jump to line : some logic like: login not using password = using auth or something else } 如此，即可反推出，原始的代码的逻辑了。 类似的，IDA中的伪代码，其实就是如此一点点反推出原始代码的逻辑，然后实现反编译的 此处IDA Pro v7.7的反编译结果，也就是上述推测出的逻辑和写法： 此处贴出，这部分代码的对应的，IDA Pro的伪代码： void __cdecl -[NSMutableURLRequest(AppleAccount) aa_addBasicAuthorizationHeaderWithAccount:preferUsingPassword:]( id a1, SEL a2, id inputAccount, bool inputPreferUsingPassword) { __int64 curACAccount; // x0 ... curACAccount = MEMORY[0x197442830](inputAccount, a2); v7 = curACAccount; if ( curACAccount ) { if ( inputPreferUsingPassword ) { v8 = MEMORY[0x197441000](curACAccount, 0x19AE2A544uLL); ... } else { v17 = MEMORY[0x197441000](curACAccount, 0x19B62D138uLL); ... } ... } ... } 如此，从ARM汇编代码中，熟悉ARM汇编指令的语法，配合iOS的ObjC的（objc_msgSend、Block等）底层知识，其实可以： 静态分析，和 动态调试，看懂大部分的代码逻辑 特殊： 当然，还有其他逻辑，是无法直接看出来的，比如上面的： curACAccount = MEMORY[0x197442830](inputAccount, a2); ... v8 = MEMORY[0x197441000](curACAccount, 0x19AE2A544uLL); 就属于通过静态分析，查看IDA反编译的伪代码，无法看懂具体的逻辑 需要的动态调试，就可以看懂具体逻辑了 比如此处： curACAccount = MEMORY[0x197442830](inputAccount, a2); 其实是： curACAccount = objc_retain(inputAccount); 而： v8 = MEMORY[0x197441000](curACAccount, 0x19AE2A544uLL); 通过Xcode的动态调试： 0x1925a95dc : tbz w21, #0x0, 0x1925a96e0 ; 0x1925a95e0 : adrp x8, 36933 0x1925a95e4 : add x21, x8, #0x544 0x1925a95e8 : mov x0, x19 0x1925a95ec : mov x1, x21 0x1925a95f0 : bl 0x197c05000 ; objc_msgSend (lldb) reg r x0 x1 x2 x0 = 0x00000002816b6920 x1 = 0x000000019b5ee544 x2 = 0x00000002816b6920 (lldb) po 0x00000002816b6920 xxx@yyy.zzz (0F...8-655A-4DE7-9CEE-A...7) (lldb) po (char*)0x000000019b5ee544 \"username\" 得知，其实是： objc_msgSend(curACAccount, \"username\") 如此，即可一点点的，通过汇编代码，反推，搞懂，原始代码逻辑。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-26 22:46:45 "},"common/hook_multiple_target.html":{"url":"common/hook_multiple_target.html","title":"必要时hook多个目标","keywords":"","body":"必要时hook多个目标 iOS逆向心得：找逆向函数时，记得hook研究多个目标 【找逆向函数时，记得hook研究多个目标 举例 】 研究Apple账号登录过程，找（以PET结尾的长密码计算的）关键点函数 除了要（frida-trace去追踪）hook研究：Preferences 系统设置的app=包名：com.apple.Preferences 还要想得起来，去（frida-trace去追踪）hook研究：akd =AuthKit的daemon守护进程=服务进程=二进制文件 详细过程： 之前已经用frida-trace去追踪了Preferences中，Apple账号登录的全过程： 【记录】iOS逆向Apple账号：重新用frida-trace追踪带NSXPCConnection的Apple账号的完整登录过程 核心命令： frida-trace -U -F com.apple.Preferences -O Preferences_accoutLogin_hook.txt 另外配合之前的调试： Xcode+iOSOpenDev的插件的动态调试 找到了，首次出现，以PET结尾的长密码字符串 AppleStore/Preferences_app/dynamicDebug/frida/hook_result/AppleAccountLogin/AuthenticationResults.coffee AKPassword = \"GdJJ3P1jNh ... VQWu/It0OM503Ik7Fk3QY=PET\"; 的来源是： shouldContinueWithAuthenticationResults -[AKAppleIDAuthenticationContextManager shouldContinueWithAuthenticationResults:error:forContextID:completion:] 但是最后追踪下去，感觉进入了死胡同： 始终找不到，到底是谁，作为client，去调用了，NSXPCConnection相关的 -[__NSXPCInterfaceProxy_AKAppleIDAuthenticationDaemonProtocol shouldContinueWithAuthenticationResults:error:forContextID:completion:] 从而无法找到到底是哪里去计算PET密码的地方了。 最后突然想到： frida-trace追踪Preferences的结果中，竟然找不到： AKAppleIDAuthenticationService 这个，之前见过的，被调用过的，关键函数之一 比如 -[AKAppleIDAuthenticationService authenticateWithContext:completion:] -[AKAppleIDAuthenticationService _authenticateWithContext:completion:] 所以后来才想到，是不是漏了什么。 所以才想到： 另外，单独再去研究akd=AuthKit的daemon程序 其中就是对应着之前早就知道的： NSXPCConnection Client端：Preferences Server端：akd 之前多数NSXPCConnection，都是Preferences发送给akd的 此处计算密码字符串等相关Authenticate=认证的过程也是一样的。 所以最后去用： frida-trace追踪akd的全过程，最后发现了： 是有：AKAppleIDAuthenticationService 是有： -[AKAppleIDAuthenticationService authenticateWithContext:completion:] 还有，其他很多之前看别人分析的（类似的）关键函数： -[AKSRPContext configureWithParameters:] +[AKSRPOperation performWithURL:SRPContext:error:] 然后就有机会去继续分析： 以PET结尾的长密码字符串，到底是如何计算的了。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-26 22:43:59 "},"common/pass_arg_special.html":{"url":"common/pass_arg_special.html","title":"特殊的参数传递","keywords":"","body":"特殊的参数传递 概述 NSString、os_log去格式化参数时，待格式化的参数的传递逻辑 基本上确定就是：通过堆栈的方式传递 而具体保存的地址 比如 NSString中见过的 [sp]、[sp+8]等地址 os_log的底层实现函数_os_log_impl的x4寄存器所指示的地址，比如 [x29 - 0x90]等地址 总之，可以确定的是： NSString、os_log这种支持不定长度的参数的格式化，其参数传递的方式： 是通过Stack=栈 而不是（默认的）寄存器 ARM的 32位：x0~x3 64位：x0~x7 详解 NSString stringWithFormat 此处调试发现个心得： 对于： +[NSString stringWithFormat: @\"Basic %@\", xxx ] 这种，NSString字符串格式化，带额外的（待格式化的）参数的话 其参数传递： 不是传统的(x64的)x0~x7，而是：stack栈 对应此处ARM汇编代码是： 0x1925a9a4c : adrp x8, 390173 0x1925a9a50 : ldr x0, [x8, #0xf10] 0x1925a9a54 : str x24, [sp] 0x1925a9a58 : adrp x2, 353681 0x1925a9a5c : add x2, x2, #0xed0 ; @\"Basic %@\" 0x1925a9a60 : mov x1, x21 0x1925a9a64 : bl 0x197c05000 ; objc_msgSend 此处除了传统的x0、x1、x2之外，还有个： 0x1925a9a54 : str x24, [sp] 即把x24，存入到了：sp=堆栈中 具体过程过程是： (lldb) reg r x0 x1 x2 x0 = 0x00000001f08fe270 (void *)0x00000001f08fe298: NSString x1 = 0x000000019b27cb32 x2 = 0x00000001e8b3aed0 @\"Basic %@\" (lldb) po 0x000000019b27cb32 6898043698 (lldb) po (char*)0x000000019b27cb32 \"stringWithFormat:\" 以为要格式化的内容是放在x3中呢，所以去看看： (lldb) reg r x3 x3 = 0x000000028211a610 (lldb) po 0x000000028211a610 10772129296 (lldb) po (char*)0x000000028211a610 \"\\x80\\xe0P\\xe7\\U00000001\" 发现不像，不是。 后来才注意到，前面还有个sp保存了x24 所以去看看x24的值 (lldb) reg r x24 x24 = 0x000000028211a5e0 (lldb) po (char*)0x000000028211a5e0 YWRtaW5AY3JpZmFuLmNvbTpHVEN2M01Ma0FGUFZ4Zlp2M3Y5YVZhYkRuMlVob1dMTWRpOUlObnQ4Y2U2OS95UmkvNjMxcko5VUVEWjNPK3ovOGp2eHB2T1VhWUV1WUliMnpISWVlOEpReC9BWW9RZDJDZU5PM1lTSDd0dkgrczRJS2liT3Q5bEFHQ0pCU1AyUFJHVjFVd1JUYUFyUDN4bzNubUlPWjI2UGJ5UmZjM0N2V0JuOStlSUZPRVNhaExLbDBWMlFUM1MwMnczOUFYUTk0OEZqSGdVQTBCbkR1RTZwWXlzd0ZCTVJnZE9yYkw4bHU2bjQ0M0ZpZlA0ak9namI5a25DVGVWdVRJSGE5K21LRDdaQVBNU2RjZG5rblFTcEt1d2dwMFZiV2dySm9tTnhqdHZuTmozcmR4ZnJ5QTMxM3diVkRLNTBlSStLenl1My8ySFNrL0dHMG9DVmtPd2xzR2VmdDNrbktJN09FSzVFZDFKNEp0WThUdTBiejRvRnBxQm80WFhoQkM2ZEVPUThRVEwrUm9yYWIxUDYzazRCKys3YXkvMnlodjJHMy9sRUIyTENBaVo4enBCd0xPVGt0aUlJdzhzdXA4ZUpKMlBGSjNzd0Y0QT1QRVQ= 果然就是要格式化的字符串。 所以才看出： 对于（NSString，以及之前见过的os_log等函数，支持）参数格式化时，额外的待格式化的参数，由于个数不确定 所以无法直接全部通过传统的寄存器（ARM中，32位的x0~x3，64位的x0~x7）去传递待格式化的参数 而是：改用Stack栈传递待格式化的参数 此处具体表现就是： 0x1925a9a54 : str x24, [sp] 这类写法，参数以此存放到当前Stack中： 参数1：[sp + 0x00] 参数2：[sp + 0x08] 参数3：[sp + 0x10] 以此类推。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-26 22:07:26 "},"common/hook_code_not_work.html":{"url":"common/hook_code_not_work.html","title":"hook代码没生效","keywords":"","body":"hook代码没生效 调试心得： 对于去调试二进制进程来说： 对于（iOSOpenDev改动了hook代码，重新编译并）安装了新版本插件，去测试新版插件时 需要先杀掉现有的二进制进程，重新（手动或触发）启动进程，才能加载到新版插件dylib，才能使得新版代码生效 举例 【未解决】iOS逆向akd：动态调试 期间，当iOSOpenDev的Xcode重新改动hook代码 重新编译安装jailAuthKitAkd插件到iPhone中（jailAuthKitAkd.dylib）后，需要去 ssh中去杀掉旧的akd的进程 方式1：killall killall -9 akd 方式2： ps -A | grep akd 找到akd的PID kill -9 然后此处（采用触发方式去重新）启动akd进程 利用iOS的app：Preferences中，点击Apple账号登录按钮，可以触发akd的进程重新启动 然后才能看到插件jailAuthKitAkd.dylib重新加载 才能重新调试，新改动的hook代码逻辑 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-26 22:55:56 "},"common/hook_slow_stuck.html":{"url":"common/hook_slow_stuck.html","title":"hook导致很慢和卡死","keywords":"","body":"hook导致很慢和卡死 不论是iOS的逆向还是安卓的逆向，如果给底层函数做了hook 比如 安卓中，用Frida给HashMap加上hook iOS中，iOSOpenDev加上hook代码 尤其是还加上参数过滤 会严重影响和拖慢原先程序运行的速度，极大地降低代码运行效率 -》从而表现出，app程序本身：启动和运行速度很慢 有时候甚至看起来像是卡死一样 举例 Frida去hook了Java的HashMap 之前用用Frida去hook某app，自加上Java的HashMap的hook（且加上过滤参数后） 导致app启动很慢： 后来，退出Frida的hook后，app启动速度正常，很快进入主页了： 然后后来才想起来，才明白，原来是： 由于Frida中，加上了hook，但是是给HashMap加的hook： 本身HashMap是Java中，最常用的最基础的类之一： 会有大量的Java代码调用到HashMap的操作 且此时，hook了： HashMap的3个函数： get put putAll 且还给get和put做了参数过滤 代码如下： static HashMap(callback_isPrintStack_put=null, callback_isPrintStack_putAll=null, callback_isPrintStack_get=null) { /******************** java.util.HashMap ********************/ var className_HashMap = \"java.util.HashMap\" // FridaAndroidUtil.printClassAllMethodsFields(className_HashMap) var cls_HashMap = Java.use(className_HashMap) console.log(\"cls_HashMap=\" + cls_HashMap) // var instance_HashMap = cls_HashMap.$new() // console.log(\"instance_HashMap=\" + instance_HashMap) // public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object) // var func_HashMap_put = cls_HashMap.put('java.lang.Object', 'java.lang.Object') // var func_HashMap_put = instance_HashMap.put('java.lang.Object', 'java.lang.Object') var func_HashMap_put = cls_HashMap.put console.log(\"func_HashMap_put=\" + func_HashMap_put) if (func_HashMap_put) { func_HashMap_put.implementation = function (keyObj, valueObj) { var funcName = \"HashMap.put(key,val)\" var funcParaDict = { \"keyObj\": keyObj, \"valueObj\": valueObj, } if (null != keyObj) { // console.log(\"keyObj=\" + keyObj) // console.log(\"keyObj.value=\" + keyObj.value) var isPrintStack = false // isPrintStack = HookApp_SomeUrl.HashMap(keyObj, valueObj) if (null != callback_isPrintStack_put){ isPrintStack = callback_isPrintStack_put(keyObj, valueObj) } if (isPrintStack) { FridaAndroidUtil.printFunctionCallAndStack(funcName, funcParaDict) } } return this.put(keyObj, valueObj) } } // public void java.util.HashMap.putAll(java.util.Map) // var func_HashMap_putAll = cls_HashMap.putAll('java.util.Map') var func_HashMap_putAll = cls_HashMap.putAll console.log(\"func_HashMap_putAll=\" + func_HashMap_putAll) if (func_HashMap_putAll) { func_HashMap_putAll.implementation = function (newMap) { var funcName = \"HashMap.putAll(map)\" var funcParaDict = { \"newMap\": newMap, } // console.log(\"newMap=\" + newMap) var isPrintStack = false if (null != callback_isPrintStack_putAll){ isPrintStack = callback_isPrintStack_putAll(newMap) } if (isPrintStack){ console.log(\"newMapStr=\" + FridaAndroidUtil.mapToStr(newMap)) FridaAndroidUtil.printFunctionCallAndStack(funcName, funcParaDict) } return this.putAll(newMap) } } // https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html#get-java.lang.Object- // public V get(Object key) var func_HashMap_get = cls_HashMap.get console.log(\"func_HashMap_get=\" + func_HashMap_get) if (func_HashMap_get) { func_HashMap_get.implementation = function (keyObj) { var funcName = \"HashMap.get(key)\" var funcParaDict = { \"keyObj\": keyObj, } var isPrintStack = false if (null != callback_isPrintStack_get){ isPrintStack = callback_isPrintStack_get(keyObj) } if (isPrintStack){ FridaAndroidUtil.printFunctionCallAndStack(funcName, funcParaDict) } var retValObj = this.get(keyObj) if (isPrintStack){ console.log(\"retValObj=\" + retValObj) } return retValObj } } } ... class HookApp_SomeUrl { static BodyPara_KeyList = [ \"xxx\", \"yyy\", ] constructor() { console.log(\"HookApp_SomeUrl constructor\") } static HashMap_put(keyObj, valueObj){ var isPrintStack = false var keyStr = keyObj.toString() // console.log(\"keyStr=\" + keyStr) if (HookApp_SomeUrl.BodyPara_KeyList.includes(keyStr)){ // console.log(\"keyStr=\" + keyStr) isPrintStack = true } return isPrintStack } static HashMap_get(keyObj){ // console.log(\"HashMap_get: keyObj=\" + keyObj) var isPrintStack = false if(null != keyObj) { var keyStr = keyObj.toString() if (HookApp_SomeUrl.BodyPara_KeyList.includes(keyStr)){ isPrintStack = true } } return isPrintStack } ... HookJava.HashMap(HookApp_SomeUrl.HashMap_put, null, HookApp_SomeUrl.HashMap_get) ... 导致每次调用到HashMap.get、HashMap.put 都要去判断和过滤参数是否满足条件（满足条件才打印堆栈调用） 从而严重影响原先的Java代码的运行效率和速度 导致看起来app启动和运行速度非常非常慢 （就类似于之前iOS逆向期间，也是hook了基础的底层函数，尤其是再加上过滤：也会导致iOS的app运行速度非常非常慢，以为是卡死了呢） crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-27 11:08:55 "},"appendix/":{"url":"appendix/","title":"附录","keywords":"","body":"附录 下面列出相关参考资料。 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-02-26 09:37:43 "},"appendix/reference.html":{"url":"appendix/reference.html","title":"参考资料","keywords":"","body":"参考资料 【未解决】iOS的app安装和使用后相关内容：数据、文件、目录 【未解决】iOS逆向WhatsApp：-[WASignalKeyStore storeSignedPreKeyRecord:prekeyId:creationDate:]_block 【未解决】iOS逆向WhatsApp：-[WASignalKeyStore executeDatabaseFetchRequest:context:] 【整理】iOS逆向：如何查看Mach-O的虚拟地址基地址vmaddr即镜像地址基地址image base 【整理】iOS逆向心得：寻找函数触发时机：hook类的alloc+init函数 【整理】iOS逆向心得：寻找函数触发时机：重新安装后以Spawn方式启动调试或交叉引用找上层调用 【整理】iOS逆向心得：app完全卸载后仍有可能有app相关的数据 【未解决】iOS逆向WhatsApp：-[WASignalKeyStore saveToKeychainIdentityKeypairData:registrationIdData:] 【未解决】iOS逆向WhatsApp：-[WASignalCoordinator createAndSaveIdentity] 【未解决】iOS逆向WhatsApp：signal_protocol_key_helper_generate_registration_id 【整理】iOS逆向调试：修改寄存器值使得程序走期望的分支 【已解决】iOS逆向WhatsApp：-[WASignalCoordinator localKeysAvailable] 【整理】iOS逆向心得：Keychain数据库 【未解决】iOS逆向WhatsApp：Keychain中genp中WhatsApp数据何时和如何被写入的 【未解决】iOS中的keychain保存位置路径 【记录】Mac中用DB Browser for SQLite查看keychain数据库文件：/var/Keychains/keychain-2.db 【已解决】Mac中如何打开iOS中的SQLite3格式的数据库.db文件 【记录】iOS逆向WhatsApp：查找keychain的数据库/var/Keychains/keychain-2.db中WhatsApp相关数据 【已解决】Mac中DB Browser for SQLite中删除genp数据表中WhatsApp的记录 【未解决】iOS逆向WhatsApp：寻找gena即kSecAttrGeneric的值0x45534916来源：从Axolotl引用入手 【未解决】iOS逆向WhatsApp：寻找gena即kSecAttrGeneric的值0x45534916来源：从SecItemAdd引用处入手 【未解决】iOS逆向WhatsApp：+[WASignalKeyStore baseKeychainQuery] 【整理】iOS逆向心得：用watchpoint或wivar监视寻找变量赋值的地方 【未解决】iOS逆向WhatsApp：用watchpoint监视寻找WASignalKeyStore的_registrationIdData值来源 【未解决】iOS逆向WhatsApp：WAFBUUID中的uuid如何初始化设置值的 【整理】iOS逆向调试：lldb用正则查找函数时记得要转义特殊字符 【已解决】iOS逆向：lldb中获取ObjC中dict中key的值 【未解决】iOS逆向WhatsApp：-[WARegistrationURLBuilder initWithPhoneNumber:language:locale:fbUUID:waUUID:chatPrivateKey:e2eKeyBundle:smbClientSignedVNameCertData:] 【未解决】iOS逆向WhatsApp：用watchpoint监视寻找WASignalKeyStore的_registrationIdData值来源 【整理】iOS逆向Xcode调试心得：查看当前所有变量值 【整理】Xcode调试心得：调试触发断点时Fetching Variables on iPhone 【已解决】从XCode崩溃的地址寻找所属二进制的代码段和函数位置 【整理】Xcode调试心得：给汇编代码窗口保持打开状态不关闭 【无需解决】Xcode的目标调试iOS设备出现2个：一个是arm64一个是arm64e 【整理】iOS逆向心得：iOS的ObjC的属性内部有可能是有额外生成属性值的处理逻辑的 【规避解决】Xcode调试iOSOpenDev的xm文件无法定位到源代码位置 【未解决】iOS逆向调试iOSOpenDev的Logos插件时%orig触发断点时无法正常打开并定位到xm源码位置 【未解决】iOS逆向WhatsApp：研究v2/reg_onboard_abprop的参数值cc、in、rc的来源和逻辑 【已解决】iOS逆向：获取iOS的app的主二进制文件路径 【整理】Xcode去Attach挂载调试app或二进制：通过PID或进程名 【整理】iOS调试心得：崩溃日志解析工具 【整理】lldb调试心得：用指针引用ObjC类的私有属性 【整理】iOS逆向：Xcode调试时访问类的实例的私有成员属性变量值 【整理】iOS逆向lldb调试心得：用点.去引用查看ObjC类的属性值 【整理】iOS逆向心得：找逆向关键函数时记得hook研究多个不同目标 【整理】iOS逆向：从ARM汇编代码反推理解出部分的原始代码逻辑 【已解决】iOS逆向时_os_log_impl的详细的参数和含义 【整理】iOS逆向心得：NSString、os_log等带格式化参数时的参数传递逻辑 【已解决】iOS逆向Apple账号：研究signin/v2/login请求的header头信息 【已解决】旧Mac中重新调试jailAppleAccount插件查看signin/v2/login等网络请求相关数据 【已解决】iOS逆向：hook代码中通过函数打印处函数调用堆栈 【整理】iOS逆向心得：对于iOS内置类比如NSMutableURLRequest的属性和函数的扩展 【已解决】iOS逆向：Xcode写hook插件看能否调试触发断点 【已解决】如何才能让Xcode中hook代码断点被触发实时调试插件hook代码 【记录】iOS逆向Apple账号：Xcode实时调试hook代码研究账号登录过程 【已解决】新建和初始化iOSOpenDev的Xcode项目：jailAppleAccount的hook插件 【已解决】换iPhone11去确保Xcode的iOSOpenDev的hook插件正常工作 【整理】Xcode去Attach挂载调试app或二进制：通过PID或进程名 【整理】iOS逆向心得：手动从汇编代码的adrp计算出字符串即objc_msgSend的参数的函数名 【整理】iOS逆向调试心得：从po打印值看出当前变量类型是实例对象还是类本身 【未解决】iOS逆向Apple账号：-[AAUISignInViewController _attemptAuthenticationWithContext:] 【整理】逆向调试心得：给被大量调用的底层函数加hook且加参数过滤会导致app运行很慢甚至卡死 【已解决】iOS逆向Apple账号：通过插件hook去打印AADeviceInfo的类的相关信息 crifan.org，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2024-09-27 11:18:56 "}}